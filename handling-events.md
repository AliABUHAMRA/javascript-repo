# Handling Events

> لديك سلطة على عقلك - وليس الأحداث الخارجية. أدرك هذا ، وسوف تجد القوة

> > Marcus Aurelius, Meditatio

![](.gitbook/assets/image%20%284%29.png)

تتعامل بعض التطبيقات مع مدخلات المستخدم ؛ مثل الأشياء التي يتم إجراؤها باستخدام الماوس ولوحة المفاتيح. هذا النوع من المدخلات غير متاح كهيكل بيانات منظم - يتم تلقيه تدريجيًا أثناء تنفيذ البرنامج ، ويجب أن يستجيب البرنامج عند استلامه.

### Event handlers  معالجات الأحداث

تخيل علاقة يكون فيها السبيل الوحيد لمعرفة ما إذا كان المفتاح مضغوطًا على لوحة المفاتيح هو قراءة الحالة الحالية لهذا المفتاح. لكي نتمكن من الرد على المفتاح الذي يتم الضغط عليه ، يجب أن نقرأ حالة المفتاح باستمرار للحصول عليه قبل تحرير المفتاح مرة أخرى. في غضون ذلك ، إذا أجرينا عملية حسابية أخرى تستغرق وقتًا طويلاً ، فهناك خطر فقدان ضغطة مفتاح.

بعض الآلات البدائية تتعامل مع مثل هذه المدخلات. خطوة واحدة بعد هذه الطريقة هي أن يلاحظ الجهاز أو نظام التشغيل ضغط المفتاح هذا ويضعه في قائمة انتظار. يمكن للبرنامج بعد ذلك التحقق بشكل دوري من قائمة الانتظار هذه بحثًا عن أحداث جديدة والتفاعل مع ما يراه. 

بالطبع ، يجب أن يتذكر إلقاء نظرة على قائمة الانتظار ، والقيام بذلك كثيرًا ، لأن أي وقت بين الضغط على المفتاح ويلاحظ البرنامج الحدث سيؤدي إلى عدم استجابة البرنامج. هذا النهج يسمى ' _polling_'. يفضل معظم المبرمجين تجنبه.

تتمثل إحدى الآليات الأفضل للنظام في إعلام برنامجنا بحدث ديناميكي. تقوم المستعرضات بذلك عن طريق تمكين تسجيل الوظائف كمعالجات لأحداث معينة.

```text
<p>Click this document to activate the handler.</p>
<script>
  window.addEventListener("click", () => {
    console.log("You knocked?");
  });
</script>
```

يشير ربط النافذة إلى كائن مضمن يوفره المتصفح. يمثل نافذة المتصفح التي تحتوي على المستند. يؤدي استدعاء طريقة addEventListener الخاصة بها إلى تسجيل الوسيطة الثانية التي يجب استدعاؤها متى حدث الحدث الموصوف بواسطة الوسيطة الأولى.

### Events and DOM nodes

يتم تسجيل كل معالج حدث مستعرض في context. استدعينا addEventListener في كائن النافذة السابقة لتسجيل برنامج تشغيل للنافذة بأكملها. هذه الطريقة متاحة أيضًا في عناصر DOM وبعض الأنواع الأخرى من الكائنات. يتم استدعاء مستمعي الأحداث فقط عندما يقع الحدث في سياق الكائن المسجلون عليه.

```text
<button>Click me</button>
<p>No handler here.</p>
<script>
  let button = document.querySelector("button");
  button.addEventListener("click", () => {
    console.log("Button clicked.");
  });
</script>
```

في المثال أعلاه ، تم تعيين برنامج تشغيل node الزر. يؤدي النقر فوق هذا الزر إلى تشغيل برنامج التشغيل ، ولكن النقر فوق أجزاء أخرى من المستند لا يؤدي إلى حدوث ذلك.

إعطاء node  سمة onclick لها تأثير مماثل. يعمل هذا مع معظم أنواع الأحداث — يمكنك إرفاق معالج من خلال السمة التي يكون اسمها هو اسم الحدث أمامها.

لكن يمكن أن تحتوي node على سمة onclick واحدة فقط ، لذا يمكنك تسجيل معالج واحد فقط لكل node بهذه الطريقة. تسمح لك طريقة addEventListener بإضافة أي عدد من المعالجات بحيث يكون من الآمن إضافة معالجات حتى إذا كان هناك معالج آخر على العنصر.

يزيل الأسلوب removeEventListener محرك الأقراص إذا تم استدعاؤه باستخدام وسيطات مشابهة لـ addEventListener.

```text
<button>Act-once button</button>
<script>
  let button = document.querySelector("button");
  function once() {
    console.log("Done.");
    button.removeEventListener("click", once);
  }
  button.addEventListener("click", once);
</script>
```

يجب أن تكون الوظيفة المعطاة لـ removeEventListener هي نفس قيمة الوظيفة المعطاة لـ addEventListener. لذلك ، لإلغاء تسجيل معالج ، ستحتاج إلى إعطاء اسم للوظيفة \(مرة واحدة ، في المثال\) لتتمكن من تمرير نفس قيمة الوظيفة إلى كلتا الطريقتين.

### Event objects

على الرغم من أننا تجاهلناها حتى الآن ، تم تمرير وسيطة إلى وظائف معالج الحدث: كائن الحدث. يحتوي هذا الكائن على معلومات إضافية حول الحدث. على سبيل المثال ، إذا أردنا معرفة زر الماوس الذي تم الضغط عليه ، فيمكننا إلقاء نظرة على خاصية button  كائن الحدث.

```text
<button>Click me any way you want</button>
<script>
  let button = document.querySelector("button");
  button.addEventListener("mousedown", event => {
    if (event.button == 0) {
      console.log("Left button");
    } else if (event.button == 1) {
      console.log("Middle button");
    } else if (event.button == 2) {
      console.log("Right button");
    }
  });
</script>
```

تختلف المعلومات المخزنة في كائن الحدث حسب نوع الحدث. سنناقش الأنواع المختلفة لاحقًا في الفصل. تحتوي خاصية نوع الكائن دائمًا على سلسلة تحدد الحدث                            \(مثل  `"click"` or `"mousedown"`\).

### Propagation

بالنسبة لمعظم أنواع الأحداث ، فإن المعالجات المسجلة على node مع children ستتلقى أيضًا الأحداث التي تحدث في children . إذا تم النقر على زر داخل فقرة ، فإن معالجات الأحداث الموجودة في الفقرة ستشاهد أيضًا حدث النقر.

ولكن إذا كان لكل من الزر والفقرة برنامج تشغيل ، فسيتم تشغيل برنامج التشغيل الأكثر وضوحًا - هنا الزر - في وقت أقرب. في هذه الحالة ، يُقال إن الحدث قد تم نشره للخارج ، من node التي حدث فيها إلى node الأصلية إلى node الجذرية في المستند. أخيرًا ، بعد استدعاء جميع السائقين المسجلين في nodes محددة بدورهم ، ستتاح الفرصة للسائقين المسجلين في النافذة بأكملها للرد على الحدث. 

في أي وقت ، يمكن لمعالج الحدث استدعاء طريقة stopPropagation على كائن الحدث لمنع المعالجات بشكل أكبر من تلقي الحدث. يمكن أن يكون هذا مفيدًا ، على سبيل المثال ، عندما يكون لديك زر داخل عنصر آخر قابل للنقر ولا تريد النقرات على الزر لتنشيط سلوك نقر العنصر الخارجي.

يسجل المثال التالي معالجات "mousedown" على كل من الزر والفقرة المحيطة به. عند النقر بزر الفأرة الأيمن ، يستدعي معالج الزر stopPropagation ، مما يمنع المعالج الموجود في الفقرة من العمل. عند النقر فوق الزر بزر ماوس آخر ، سيتم تشغيل كلا المعالجين.

```text
<p>A paragraph with a <button>button</button>.</p>
<script>
  let para = document.querySelector("p");
  let button = document.querySelector("button");
  para.addEventListener("mousedown", () => {
    console.log("Handler for paragraph.");
  });
  button.addEventListener("mousedown", event => {
    console.log("Handler for button.");
    if (event.button == 2) event.stopPropagation();
  });
</script>
```

تحتوي معظم كائنات الحدث على خاصية target تشير إلى node التي نشأت فيها. يمكنك استخدام هذه الخاصية للتأكد من أنك لا تتعامل عن طريق الخطأ مع شيء تم نشره من node لا تريد التعامل معها.

من الممكن أيضًا استخدام الخاصية target لإلقاء شبكة واسعة لنوع معين من الأحداث. على سبيل المثال ، إذا كانت لديك node تحتوي على قائمة طويلة من الأزرار ، فقد يكون من المناسب تسجيل برنامج تشغيل للنقر على node الخارجية واستخدام خاصية target للتحقق من نقرة زر بدلاً من برنامج تشغيل منفصل لكل زر.

```text
<button>A</button>
<button>B</button>
<button>C</button>
<script>
  document.body.addEventListener("click", event => {
    if (event.target.nodeName == "BUTTON") {
      console.log("Clicked", event.target.textContent);
    }
  });
</script>
```

### Default actions

العديد من الأحداث لها إجراء افتراضي مرتبط بها. إذا قمت بالنقر فوق ارتباط ، فسيتم نقلك إلى هدف الارتباط. إذا ضغطت على السهم لأسفل ، فسيقوم المتصفح بتمرير الصفحة لأسفل. إذا نقرت بزر الماوس الأيمن ، فستحصل على قائمة context. وما الى ذلك.

يتم استدعاء معالجات الأحداث في JavaScript في معظم أنواع الأحداث قبل حدوث السلوك الافتراضي. إذا كان المعالج لا يريد حدوث هذا السلوك العادي ، عادةً لأنه قد اهتم بالفعل بمعالجة الحدث ، فيمكنه استدعاء طريقة  `preventDefault`  في كائن الحدث.

يمكن استخدام هذه الطريقة لتنفيذ الاختصارات الخاصة بك أو قائمة السياق. يمكن أيضًا تحييد السلوك الذي يتوقعه المستخدم من حدث ما تمامًا. على سبيل المثال ، يوجد رابط هنا لا يمكن اتباعه.

```text
<a href="https://developer.mozilla.org/">MDN</a>
<script>
  let link = document.querySelector("a");
  link.addEventListener("click", event => {
    console.log("Nope.");
    event.preventDefault();
  });
</script>
```

حاول ألا تذهب لمثل هذه الأشياء ما لم يكن لديك سبب وجيه للقيام بذلك. لن يشعر المستخدمون الذين يستخدمون صفحة الويب الخاصة بك بالرضا عند فشل سلوكهم المتوقع.

اعتمادًا على المتصفح ، لا يمكن اعتراض بعض الأحداث على الإطلاق. على Chrome ، على سبيل المثال ، لا يمكن معالجة اختصار لوحة المفاتيح لإغلاق علامة التبويب الحالية \(control-W أو command-W\) بواسطة JavaScript.

### Key events

عند الضغط على مفتاح من لوحة المفاتيح ، يقوم المستعرض بإطلاق حدث "keydown".  عندما يتم إصداره ، تحصل على حدث "keyup".

```text
<p>This page turns violet when you hold the V key.</p>
<script>
  window.addEventListener("keydown", event => {
    if (event.key == "v") {
      document.body.style.background = "violet";
    }
  });
  window.addEventListener("keyup", event => {
    if (event.key == "v") {
      document.body.style.background = "";
    }
  });
</script>
```

على عكس اسمها ، فإن كلمة "keydown" لا تحدث فقط عند الضغط على المفتاح لأسفل. عندما يتم الضغط على مفتاح مع الاستمرار في نفس الموضع ، يتم إعادة إرسال هذا الحدث في كل مرة يتكرر فيها هذا المفتاح.  في بعض الأحيان عليك أن تكون على دراية بهذا السلوك. على سبيل المثال ، إذا كنت تريد إضافة زر إلى DOM بالضغط على مفتاح وحذفه عن طريق تحرير المفتاح ، فقد تتم إضافة مئات الأزرار بشكل عشوائي لأنه قد يتم الضغط على المفتاح لفترة أطول.

نظر المثال إلى الخاصية الرئيسية لكائن الحدث لمعرفة key الذي يدور حوله الحدث. تحتوي هذه الخاصية على سلسلة تتوافق ، بالنسبة لمعظم keys ، مع الشيء الذي سيكتبه الضغط على هذا key . بالنسبة للمفاتيح الخاصة مثل الإدخال ، فإنها تحتوي على سلسلة تسمي المفتاح \("Enter" ، في هذه الحالة\). إذا قمت بالضغط على مفتاح shift أثناء الضغط باستمرار على المفتاح ، فقد يؤثر ذلك على اسم المفتاح - "v" تصبح "V" ، و "1" تتحول إلى "!" يصبح, بالطبع ، إذا كان هذا هو ما تم إنشاؤه عند الضغط على shift-1 على لوحة المفاتيح.

تُنشئ مفاتيح التعديل مثل Shift و control و alt و meta \(مفتاح الأمر في Mac\) أحداثًا مشابهة للمفاتيح العادية. ولكن عندما تنظر إلى تكوين المفاتيح ، يمكنك معرفة ما إذا كانت هذه المفاتيح مضغوطة أيضًا. يمكن القيام بذلك من خلال النظر إلى خصائص shiftKey و ctrlKey و altKey و metaKey لأحداث الماوس ولوحة المفاتيح.

```text
<p>Press Control-Space to continue.</p>
<script>
  window.addEventListener("keydown", event => {
    if (event.key == " " && event.ctrlKey) {
      console.log("Continuing!");
    }
  });
</script>
```

تعتمد العقدة في DOM ، حيث يبدأ الحدث الرئيسي ، على العنصر الذي كان نشطًا \(وضع التركيز focus\) عند الضغط على المفتاح. لا يمكن التركيز على معظم nodes إلا إذا قمت بتعيين خاصية tabindex لها. لكن أشياء مثل الروابط والأزرار وحقول النموذج تفعل ذلك افتراضيًا. في الفصل  [Chapter 18](https://eloquentjavascript.net/18_http.html#forms) ، سنناقش حقول النموذج. عندما لا يتم التركيز أو الملاحظة على عنصر معين في الصفحة ، عندما لا يكون هناك تركيز محدد ، يعمل document.body  ك  node مستهدفة للأحداث الرئيسية.

عندما يقوم المستخدم بكتابة نص ، فإن استخدام الأحداث الرئيسية لمعرفة ما يتم كتابته يمثل مشكلة. بعض الأنظمة الأساسية ، وأبرزها لوحة المفاتيح الافتراضية على هواتف Android ، لا تطلق الأحداث الرئيسية. حتى عند استخدام لوحة مفاتيح قديمة ، فإن بعض أنواع إدخال النص لا تتطابق مع المفتاح الذي يتم الضغط عليه ، مثل برنامج IME \("محرر تسجيل الدخول"\) الذي يستخدمه الأشخاص الذين تكون الحروف الأبجدية لديهم على لوحة مفاتيح عادية. لا يمكن تنفيذه ، حيث يتم استخدام مجموعة من ضربات المفاتيح المتعددة لإنشاء الأحرف.

لتلاحظ وقت كتابة شيء ما ، والعناصر التي يمكنك الكتابة فيها ، مثل &lt;input&gt; و &lt;textarea&gt; الأحداث عندما يغير المستخدم محتواها. للحصول على المحتوى الفعلي الذي تمت كتابته ، من الأفضل قراءته مباشرة من الحقل المركز. سيوضح الفصل   [Chapter 18](https://eloquentjavascript.net/18_http.html#forms).

### Pointer events

توجد حاليًا طريقتان مستخدمة على نطاق واسع للإشارة إلى الأشياء على الشاشة: الفئران \(بما في ذلك الأجهزة التي تعمل مثل الفئران ، مثل لوحات اللمس وكرات التتبع\) وشاشات اللمس. هذه تنتج أنواعًا مختلفة من الأحداث.

#### Mouse clicks

يؤدي الضغط على زر الماوس إلى إطلاق عدد من الأحداث.   `"mousedown"` و`"mouseup" الاحداث متشابهه ل` "keydown" و "keyup" وإطلاق النار عند الضغط على الزر وتحريره. تم انشاؤها. يحدث هذا على nodes في DOM التي تكون تحت مؤشر الماوس عند الضغط على المفتاح.

بعد حدث "mouseup" ، يقع حدث "click" على العقدة الأكثر وضوحًا والتي تتضمن الضغط على المفتاح وتحريره. على سبيل المثال ، إذا ضغطنا على زر الماوس لأسفل فقرة واحدة وحركنا المؤشر فوق فقرة أخرى وحررنا الزر ، فستحدث "click" على عنصر يحتوي على كلتا الفقرتين.

في حالة حدوث نقرتين قريبتين ، يتم أيضًا إنشاء حدث "dblclick" بعد حدث النقر الثاني.

للحصول على معلومات دقيقة حول المكان الذي وقع فيه حدث الماوس ، يمكنك إلقاء نظرة على خصائص clientX و clientY الخاصة به ، التي تحتوي على إحداثيات الحدث \(بالبكسل\) بالنسبة إلى الزاوية العلوية اليسرى من النافذة ، أو pageX و pageY ، والتي تتعلق بالركن العلوي الأيسر من المستند بأكمله \(والتي قد تكون مختلفة عند تمرير النافذة\) .

فيما يلي برنامج رسم بدائي. في كل مرة تنقر فيها على المستند ، تضيف نقطة أسفل مؤشر الماوس. انظر الفصل [Chapter 19](https://eloquentjavascript.net/19_paint.html) للحصول على برنامج رسم أقل بدائية.

```text
<style>
  body {
    height: 200px;
    background: beige;
  }
  .dot {
    height: 8px; width: 8px;
    border-radius: 4px; /* rounds corners */
    background: blue;
    position: absolute;
  }
</style>
<script>
  window.addEventListener("click", event => {
    let dot = document.createElement("div");
    dot.className = "dot";
    dot.style.left = (event.pageX - 4) + "px";
    dot.style.top = (event.pageY - 4) + "px";
    document.body.appendChild(dot);
  });
</script>
```

#### Mouse motion

يتم إنشاء حدث "mousemove" في كل مرة يتحرك فيها مؤشر الماوس. يمكن استخدام هذا الحدث لمراقبة موضع الماوس. من المواقف الشائعة التي يكون فيها هذا الحدث مفيدًا عندما ننفذ شكلاً من أشكال السحب والسحب بالماوس.

على سبيل المثال ، يعرض البرنامج التالي شريطًا ويضبط معالجات الأحداث التي تجعل الشريط يتحرك يسارًا أو يمينًا لجعله أضيق أو أكثر سمكًا.

```text
<p>Drag the bar to change its width:</p>
<div style="background: orange; width: 60px; height: 20px">
</div>
<script>
  let lastX; // Tracks the last observed mouse X position
  let bar = document.querySelector("div");
  bar.addEventListener("mousedown", event => {
    if (event.button == 0) {
      lastX = event.clientX;
      window.addEventListener("mousemove", moved);
      event.preventDefault(); // Prevent selection
    }
  });

  function moved(event) {
    if (event.buttons == 0) {
      window.removeEventListener("mousemove", moved);
    } else {
      let dist = event.clientX - lastX;
      let newWidth = Math.max(10, bar.offsetWidth + dist);
      bar.style.width = newWidth + "px";
      lastX = event.clientX;
    }
  }
</script>
```

لاحظ أن عامل التشغيل "mousemove" مسجل للنافذة بأكملها. حتى إذا تحرك الماوس خارج بيئة الشريط أثناء تغيير الحجم ، ما زلنا نعتزم تغيير حجمه طالما استمر الضغط على زر الماوس.

يجب أن نتوقف عن تغيير حجم الشريط عند تحرير زر الماوس. لذلك ، يمكننا استخدام خاصية buttons  \(لاحظ الجمع\) ، والتي تخبرنا عن الأزرار التي يتم الضغط عليها حاليًا. عندما يكون هذا صفرًا ، لا توجد أزرار معطلة. عند الضغط على الأزرار ، تكون قيمتها هي مجموع أكواد تلك الأزرار - الزر الأيسر يحتوي على الرمز 1 ، والزر الأيمن 2 ، والزر الأوسط 4. مع الضغط على الزرين الأيمن والأيسر ، على سبيل المثال ، ستكون قيمة الأزرار 3.

لاحظ أن ترتيب هذه الرموز يختلف عن الترتيب المستخدم بواسطة button ، فالزر الأوسط يأتي قبل الزر الأيمن. كما ذكرنا ، الثبات ليس شيئًا يمكن اعتباره حقًا قوة لواجهة برمجة المتصفح.

#### Touch events

في الوقت الذي كانت فيه الشاشات التي تعمل باللمس نادرة جدًا ، تم تصميم نمط متصفحات الرسوم التي نستخدمها للعمل مع الماوس. من أجل "العمل" على الويب على هواتف اللمس الأساسية ، في المتصفحات التي تم إنشاؤها لتلك الهواتف ، كانت أحداث اللمس إلى حد ما مماثلة لأحداث الماوس. إذا نقرت على شاشتك ، فستحصل على                             events`"mousedown"`, `"mouseup"`, `"click"` .

لكن هذه الحيلة ليست قوية جدًا. تختلف طريقة عمل شاشة اللمس تمامًا عن الماوس: لا تحتوي شاشة اللمس على مفاتيح متعددة ، ولا يمكنك ملاحظة إصبع عندما لا يكون على الشاشة \(لمحاكاة "mousemove"\) ويمكن أن يكون لديك عدة أصابع على الشاشة في نفس الوقت كان لديه عرض.

تغطي أحداث الماوس تفاعل اللمس فقط في الحالات المباشرة — إذا أضفت معالج "النقر" إلى click ، فسيظل بإمكان مستخدمي اللمس استخدامه. لكن شيئًا مثل الشريط القابل لتغيير الحجم في المثال السابق لا يعمل على شاشة تعمل باللمس.

هناك أنواع أحداث معينة يتم إطلاقها عن طريق التفاعل باللمس. عندما يبدأ إصبعك في لمس الشاشة ، تحصل على حدث "touchstart". عندما يتم تحريكه أثناء اللمس ، يتم إطلاق أحداث "touchmove". أخيرًا ، عندما يتوقف عن لمس الشاشة ، سترى حدث "touchend".

نظرًا لأن العديد من الشاشات التي تعمل باللمس يمكنها التعرف على أصابع متعددة في وقت واحد ، فإن هذه الأحداث لا تحتوي على مجموعة واحدة من إحداثيات النقاط.  بدلاً من ذلك ، تحتوي الكائنات في هذه الأحداث على خاصية تسمى اللمسات ، والتي تحتوي على مجموعة من الكائنات النقطية ، ولكل منها خصائص clientX و clientY و pageX و pageY الخاصة بها.

يمكنك رسم دائرة حمراء حول المناطق التي تم لمسها بإصبعك باستخدام رمز مشابه للرمز أدناه.

```text
<style>
  dot { position: absolute; display: block;
        border: 2px solid red; border-radius: 50px;
        height: 100px; width: 100px; }
</style>
<p>Touch this page</p>
<script>
  function update(event) {
    for (let dot; dot = document.querySelector("dot");) {
      dot.remove();
    }
    for (let i = 0; i < event.touches.length; i++) {
      let {pageX, pageY} = event.touches[i];
      let dot = document.createElement("dot");
      dot.style.left = (pageX - 50) + "px";
      dot.style.top = (pageY - 50) + "px";
      document.body.appendChild(dot);
    }
  }
  window.addEventListener("touchstart", update);
  window.addEventListener("touchmove", update);
  window.addEventListener("touchend", update);
</script>
```

ستحتاج غالبًا إلى استدعاء منع التشغيل الافتراضي"preventDefault" في معالجات الأحداث التي تعمل باللمس لتجاوز السلوك الافتراضي للمتصفح \(والذي قد يتضمن التمرير في الصفحة عند التمرير السريع\) ولمنع أحداث الماوس من التشغيل ، والتي قد يكون لديك أيضًا معالج لها.

### Scroll events

في كل مرة يتم فيها تمرير عنصر ، يتم تنفيذ حدث "scroll" عليه. هذا الموضوع له استخدامات مختلفة. مثل معرفة ما يبحث عنه المستخدم حاليًا\(لتعطيل الرسوم المتحركة خارج الشاشة أو إرسال تقارير التجسس إلى مقر الشركه الخاص بك\) أو تظهر بعض المؤشرات على التقدم\(بتمييز جزء من جدول المحتويات أو إظهار رقم الصفحة\).

المثال التالي يرسم شريط تقدم أعلى المستند ويحدّثه ليملأ أثناء التمرير لأسفل:

```text
<style>
  #progress {
    border-bottom: 2px solid blue;
    width: 0;
    position: fixed;
    top: 0; left: 0;
  }
</style>
<div id="progress"></div>
<script>
  // Create some content
  document.body.appendChild(document.createTextNode(
    "supercalifragilisticexpialidocious ".repeat(1000)));

  let bar = document.querySelector("#progress");
  window.addEventListener("scroll", () => {
    let max = document.body.scrollHeight - innerHeight;
    bar.style.width = `${(pageYOffset / max) * 100}%`;
  });
</script>
```

إذا قمنا بتعيين postionعنصر fixed، فستكون النتيجة مماثلة لاستخدام تحديد الموضع  `absolute` ، ولكن في هذه الحالة لم يعد يتم تمرير العنصر الآخر مع الصفحة. التأثير هو جعل شريط التقدم الخاص بنا يظل في الأعلى. يتم تغيير عرضه للإشارة إلى التقدم الحالي. نستخدم٪ ، بدلاً من px ، كوحدة عند ضبط العرض بحيث يتناسب حجم العنصر مع عرض الصفحة.

يمنحنا المتغير العام innerHieght ارتفاع الصفحة الذي تحتاجه لطرحه من إجمالي الارتفاع القابل للتمرير - لا يمكنك الاستمرار في التمرير عندما تصل إلى نهاية المستند. يعطى. يوجد أيضًا  `innerWidth`  لعرض الصفحة. من خلال مشاركة pageYOffset ، موضع التمرير الحالي ، على أقصى موضع للتمرير ومضروبًا في 100 ، نحصل على النسبة المئوية للتقدم لشريط التقدم.

لا يمنع استدعاء preventDefault في حدث تمرير scroll من الحدوث. في الواقع ، لا يتم استدعاء معالج الأحداث إلا بعد حدوث التمرير.

### Focus events

عندما يكتسب عنصر التركيز ، يطلق المستعرض حدث "foucs" عليه. عندما يفقد التركيز ، يحصل العنصر على حدث "blur".

على عكس الأحداث التي نوقشت سابقًا ، فإن هذين الحدثين لا ينتشران. لا يتم إخطار معالج على عنصر أصلي عندما يكتسب عنصر فرعي التركيز أو يفقده.

يعرض المثال التالي نص التعليمات لحقل النص الذي تم التركيز عليه حاليًا:

```text
<p>Name: <input type="text" data-help="Your full name"></p>
<p>Age: <input type="text" data-help="Your age in years"></p>
<p id="help"></p>

<script>
  let help = document.querySelector("#help");
  let fields = document.querySelectorAll("input");
  for (let field of Array.from(fields)) {
    field.addEventListener("focus", event => {
      let text = event.target.getAttribute("data-help");
      help.textContent = text;
    });
    field.addEventListener("blur", event => {
      help.textContent = "";
    });
  }
</script>
```

سيتلقى كائن النافذة أحداث "focus" و "blur" عندما ينتقل المستخدم من أو إلى علامة تبويب المتصفح أو النافذة التي يظهر فيها المستند.

### Load event

عند انتهاء تحميل الصفحة ، يبدأ حدث "load" على النافذة وكائنات نص المستند. غالبًا ما يستخدم هذا لجدولة إجراءات التهيئة التي تتطلب إنشاء المستند بالكامل. تذكر أن محتوى علامات&lt;script&gt;  يتم تشغيله فورًا عند مصادفة العلامة. قد يحدث هذا قبل ذلك بكثير ، على سبيل المثال ، عندما يحتاج البرنامج النصي للعمل مع أجزاء من المستند تأتي بعد علامة&lt;script&gt;  ..

تحتوي عناصر مثل الصور وعلامات البرنامج النصي التي تقوم بتحميل ملف خارجي أيضًا على حدث "load" يشير إلى تحميل الملفات التي تشير إليها. مثل الأحداث المتعلقة بالتركيز ، لا يتم نشر أحداث التحميل.

عند إغلاق الصفحة أو التنقل بعيدًا عنها \(على سبيل المثال ، باتباع ارتباط\) ، يتم تنفيذ حدث قبل  "beforeunload".يتمثل الاستخدام الرئيسي لهذا الحدث في منع المستخدم من فقدان العمل عن طريق إغلاق مستند. إذا قمت بمنع السلوك الافتراضي في هذا الحدث وقمت بتعيين خاصية returnValue في كائن الحدث إلى سلسلة ، فسيعرض المتصفح للمستخدم مربع حوار يسأل عما إذا كان يريد حقًا مغادرة الصفحة. قد يتضمن مربع الحوار هذا السلسلة الخاصة بك ، ولكن نظرًا لأن بعض المواقع الضارة تحاول استخدام مربعات الحوار هذه لإرباك الأشخاص للبقاء في صفحتهم للنظر في إعلانات فقدان الوزن المراوغة ، فإن معظم المتصفحات لم تعد تعرضها.

### Events and the event loop <a id="timeline"></a>

في سياق حلقة الحدث ، كما تمت مناقشته في الفصل  [Chapter 11](https://eloquentjavascript.net/11_async.html) ، تتصرف معالجات أحداث المستعرض مثل غيرها من الإشعارات غير المتزامنة. يتم جدولتها عند وقوع الحدث ولكن يجب انتظار انتهاء البرامج النصية الأخرى قيد التشغيل قبل أن تتاح لها فرصة للتشغيل.

حقيقة أن هذه الأحداث لا يمكن معالجتها إلا في حالة عدم تشغيل أي شيء آخر يعني أنه إذا كانت حلقة الحدث مرتبطة بأشياء أخرى ، سيتم تأخير أي تفاعل مع الصفحة \(الذي يتم بواسطة الأحداث\) طالما أن هناك وقتًا لمعالجته. لذلك إذا قمت بجدولة الكثير من العمل ، سواء مع معالجات الأحداث التي تستغرق وقتًا طويلاً أو مع عدد كبير من المعالجات الصغيرة ، فستتباطأ الشاشة ويصبح استخدامها أكثر صعوبة.

بالنسبة للحالات التي تحتاج فيها حقًا إلى القيام ببعض المهام التي تستغرق وقتًا طويلاً في الخلفية ولا تتعطل الصفحة ، توفر المتصفحات شيئًا يسمى عمال الويب. الخادم هو عملية جافا سكريبت يتم تشغيلها بجانب النص الرئيسي ولها جدول زمني خاص بها.

تخيل أن تربيع رقم هو عملية حسابية ثقيلة وطويلة المدى نريد إجراؤها في سلسلة منفصلة. يمكننا كتابة ملف يسمى code / squareworker.js يستجيب للرسائل عن طريق حساب مربع وإعادة إرسال رسالة.

```text
addEventListener("message", event => {
  postMessage(event.data * event.data);
});
```

لتجنب مشاكل وجود سلاسل رسائل متعددة تلامس نفس البيانات ، لا يشارك العاملون نطاقهم العالمي أو أي بيانات أخرى مع بيئة البرنامج النصي الرئيسي. بدلاً من ذلك ، عليك التواصل معهم عن طريق إرسال الرسائل ذهابًا وإيابًا.

تحدد التعليمات البرمجية التالية وسيطًا يقوم بتنفيذ برنامج نصي ؛ يرسل عدة رسائل إليه ويرسل الإجابات إلى الإخراج.

```text
let squareWorker = new Worker("code/squareworker.js");
squareWorker.addEventListener("message", event => {
  console.log("The worker responded:", event.data);
});
squareWorker.postMessage(10);
squareWorker.postMessage(24);
```

تقوم وظيفة postMessage بإرسال رسالة تؤدي إلى تشغيل حدث "message" في المستلم. يقوم البرنامج النصي الذي أنشأه العامل بإرسال الرسائل واستلامها من خلال كائن العامل ، حيث يتصل الخادم بالبرنامج النصي الذي أنشأه عن طريق الإرسال والاستماع مباشرة على أرضه العالمية. يمكن فقط إرسال القيم التي يمكن عرضها كرسائل JSONs - يتلقى الجانب الآخر نسخة منها ، وليس نفسها.

### Timers

في الفصل   [Chapter 11](https://eloquentjavascript.net/11_async.html) ، تعلمنا عن وظيفة setTimeout. تقوم هذه الوظيفة بجدولة وظيفة أخرى لاستدعاءها بعد وقت معين إلى جزء من الألف من الثانية.

في بعض الأحيان يكون من الضروري إلغاء تنفيذ الوظيفة التي قمت بجدولتها. يتم ذلك عن طريق حفظ القيمة التي تم إرجاعها من دالة setTimeout واستدعاء clearTimeout عليها.

```text
let bombTimer = setTimeout(() => {
  console.log("BOOM!");
}, 500);

if (Math.random() < 0.5) { // 50% chance
  console.log("Defused.");
  clearTimeout(bombTimer);
}
```

تعمل وظيفة إلغاء الرسوم المتحركة بنفس الطريقة التي تعمل بها وظيفة clearTimeout - حيث يؤدي استدعائها إلى قيمة إرجاع بواسطة requestAnimationFrame إلى إلغاء هذا الإطار \(بافتراض أنه لم يتم استدعاؤه من قبل\).

يتم استخدام مجموعة مماثلة من الوظائف ، setInterval و clearInterval ، لضبط المؤقتات التي يجب تكرارها كل X ألف جزء من الثانية.

```text
let ticks = 0;
let clock = setInterval(() => {
  console.log("tick", ticks++);
  if (ticks == 10) {
    clearInterval(clock);
    console.log("stop.");
  }
}, 200);
```

### Debouncing

بعض أنواع الأحداث لديها القدرة على إطلاق النار بسرعة ، عدة مرات متتالية \(على سبيل المثال أحداث "تحريك الماوس" و "التمرير"\). عند التعامل مع مثل هذه الأحداث ، يجب أن تكون حريصًا على عدم القيام بأي شيء يستغرق وقتًا طويلاً وإلا سيستغرق معالجك وقتًا طويلاً بحيث يبدأ التفاعل مع المستند في الظهور ببطء.

إذا كنت بحاجة إلى القيام بشيء غير بديهي في مثل هذا المعالج ، فيمكنك استخدام setTimeout للتأكد من أنك لا تفعل ذلك كثيرًا. عادة ما يطلق عليه شطب الحدث. هناك عدة طرق مختلفة قليلا لهذا.

في المثال الأول ، نريد الرد عندما يكتب المستخدم شيئًا ما ، لكننا لا نريد أن نفعل ذلك على الفور لكل حدث إدخال. عندما يكتبون بسرعة ، نريد فقط الانتظار حتى يحدث توقف مؤقت. بدلاً من تنفيذ إجراء على الفور في معالج الحدث ، قمنا بتعيين مهلة. نقوم أيضًا بمسح المهلة السابقة \(إن وجدت\) بحيث عندما تقع الأحداث بالقرب من بعضها البعض \(أقرب من تأخير المهلة\) ، سيتم إلغاء المهلة من الحدث السابق.

```text
<textarea>Type something here...</textarea>
<script>
  let textarea = document.querySelector("textarea");
  let timeout;
  textarea.addEventListener("input", () => {
    clearTimeout(timeout);
    timeout = setTimeout(() => console.log("Typed!"), 500);
  });
</script>
```

لا يؤثر إعطاء قيمة غير محددة لـ clearTimeout أو استدعائها في وقت انتهاء المهلة التي تم إطلاقها بالفعل. وبالتالي ، لا يتعين علينا توخي الحذر بشأن وقت تسميتها ، ونحن ببساطة نفعل ذلك في كل حدث.

يمكننا استخدام نمط مختلف قليلاً إذا أردنا تفريغ الاستجابات بحيث يتم فصلها بطول معين على الأقل من الوقت ولكننا نريد إطلاقها أثناء سلسلة من الأحداث ، وليس بعد ذلك فقط. على سبيل المثال ، قد نرغب في الرد على أحداث "mousemove" بإظهار الإحداثيات الحالية للماوس ولكن كل 250 مللي ثانية فقط.

```text
<script>
  let scheduled = null;
  window.addEventListener("mousemove", event => {
    if (!scheduled) {
      setTimeout(() => {
        document.body.textContent =
          `Mouse at ${scheduled.pageX}, ${scheduled.pageY}`;
        scheduled = null;
      }, 250);
    }
    scheduled = event;
  });
</script>
```







