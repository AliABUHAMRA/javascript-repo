# Project: A Platform Game

> الحقيقة كلها لعبة

> > Iain Banks, The Player of Games

![](.gitbook/assets/image%20%2817%29.png)

بدأ معظم افتتاني الأول بأجهزة الكمبيوتر ، مثل العديد من الأطفال الآخرين ، بألعاب الكمبيوتر. لقد انجذبت إلى عوالم محاكاة صغيرة يمكنني التعامل معها وحيث يتم سرد القصص - أعتقد أن الأمر يتعلق بتوسيع خيالي في الألعاب أكثر من إمكانيات الألعاب نفسها.

لا أتمنى لأي شخص مهنة برمجة ألعاب الكمبيوتر. مثل صناعة الموسيقى ، فإن التناقض بين عدد الشباب المتحمسين الراغبين في العمل فيها والطلب الفعلي على هؤلاء الأشخاص يخلق بيئة غير صحية إلى حد ما. لكن كتابة الألعاب من أجل المتعة أمر ممتع.

في هذا الفصل ، سنقوم بتنفيذ لعبة قفز صغيرة. ألعاب السكوبا \(أو ألعاب الحركة والقفز\) هي ألعاب يتعين على اللاعب فيها تحريك شخصية في عالم اللعبة ، والتي تكون عادةً ثنائية الأبعاد ويتم عرضها من الجانب ، ويمكن للشخصية القفز فوق \(وداخل\) الأشياء.

### The game

ستستند لعبتنا بشكل عام إلى لعبة Dark Blue التي أنشأها Thomas Pulf. اخترت هذه اللعبة لأنها ممتعة وسهلة في نفس الوقت ، ولا تتطلب الكثير من الترميز لكتابتها. ستكون اللعبة على النحو التالي.

![](.gitbook/assets/image%20%2812%29.png)

يمثل المستطيل الداكن شخصية اللعبة التي تتمثل مهمتها في جمع المستطيلات الصفراء \(العملات المعدنية\) دون الاصطدام بالأشياء الحمراء \(الحمم\). تكتمل مرحلة من اللعبة عندما يتم جمع كل القطع النقدية.

يمكن للاعب التحرك باستخدام المفاتيح اليمنى واليسرى للوحة المفاتيح والقفز بالضغط على المفتاح العلوي. القفز قدرة خاصة لهذه الشخصية. يمكنه القفز عدة مرات من ارتفاعه وتغيير اتجاهه في الهواء. اللعبة ليست واقعية تمامًا ، لكنها تمنح اللاعب الشعور بأن شخصية اللعبة تحت سيطرته تمامًا.

تتكون اللعبة من خلفية ثابتة مصممة على شكل شبكة grid مع عناصر متحركة موضوعة في الخلفية. كل حقل على الشبكة إما فارغ أو صلب أو حمم. العناصر المتحركة هي اللاعب والعملات وقطع معينة من الحمم البركانية. مواضع هذه العناصر ليست مقيدة بالشبكة - قد تكون إحداثياتها كسرية ، مما يسمح بالحركة السلسة.

### The technology

سنستخدم المتصفح DOM لعرض اللعبة ، وسنقرأ مدخلات المستخدم من خلال التعامل مع الأحداث الرئيسية.

إن الكود المرتبط بالشاشة ولوحة المفاتيح ليس سوى جزء صغير من العمل الذي يتعين علينا القيام به لبناء هذه اللعبة. نظرًا لأن كل شيء يشبه الصناديق الملونة ،الرسم غير معقد: نقوم بإنشاء عناصر DOM ونستخدم التصميم لمنحهم لون الخلفية وحجمها وموضعها.

يمكننا تمثيل الخلفية كجدول لأنها شبكة مربعات غير متغيرة. يمكن تراكب العناصر الحرة الحركة باستخدام عناصر متوضعة تمامًا.

في الألعاب والبرامج الأخرى التي يجب أن تقوم بتحريك الرسومات والاستجابة لمدخلات المستخدم دون تأخير ملحوظ ، تعد الكفاءة مهمة. على الرغم من أن DOM لم يتم تصميمه في الأصل للرسومات عالية الأداء ، إلا أنه في الواقع أفضل مما تتوقع. لقد رأيت بعض الرسوم المتحركة في الفصل [Chapter 14](https://eloquentjavascript.net/14_dom.html#animation). في جهاز حديث ، تؤدي لعبة بسيطة كهذه أداءً جيدًا ، حتى لو لم نقلق كثيرًا بشأن التحسين.

في الفصل التالي ، سننتقل إلى تقنية متصفح أخرى ، علامة &lt;canvas&gt; ، والتي توفر طريقة أكثر جذرية لرسم الصور ؛ استخدم الأشكال والبكسل بدلاً من استخدام عناصر DOM.

### Levels

سنرغب في طريقة يمكن للبشر قراءتها وتعديلها لتحديد المستويات. نظرًا لأنه من المقبول أن يبدأ كل شيء على شبكة ، يمكننا استخدام سلاسل كبيرة يمثل فيها كل حرف عنصرًا - إما جزء من شبكة الخلفية أو عنصر متحرك.

قد تبدو خطة المستوى الصغير كما يلي:

```text
let simpleLevelPlan = `
......................
..#................#..
..#..............=.#..
..#.........o.o....#..
..#.@......#####...#..
..#####............#..
......#++++++++++++#..
......##############..
......................`;
```

النقاط عبارة عن مساحة فارغة ، وأحرف التجزئة \(\#\) عبارة عن جدران ، وعلامات الجمع هي حمم. وضع بداية اللاعب هو العلامة \(@\). كل حرف O عبارة عن عملة معدنية ، وعلامة المساواة \(=\) في الجزء العلوي عبارة عن كتلة من الحمم البركانية تتحرك ذهابًا وإيابًا أفقيًا.

سندعم نوعين إضافيين من الحمم المتحركة: حرف الأنبوب \(\|\) ينشئ نقاطًا متحركة رأسياً ، و v يشير إلى تقطر الحمم البركانية - تتحرك عموديًا الحمم التي لا ترتد ذهابًا وإيابًا ولكنها تتحرك فقط لأسفل ، وتقفز مرة أخرى إلى موضع البداية عندما تضرب الأرض.

تتكون اللعبة بأكملها من مستويات متعددة يجب على اللاعب إكمالها. يكتمل المستوى عندما يتم جمع جميع العملات. إذا لمس اللاعب الحمم البركانية ، تتم استعادة المستوى الحالي إلى موضع البداية ، وقد يحاول اللاعب مرة أخرى.

### Reading a level <a id="level"></a>

يخزن الفصل التالي كائن المستوى level. يجب أن تكون وسيطتها هي السلسلة التي تحدد المستوىlevel.

```text
class Level {
  constructor(plan) {
    let rows = plan.trim().split("\n").map(l => [...l]);
    this.height = rows.length;
    this.width = rows[0].length;
    this.startActors = [];

    this.rows = rows.map((row, y) => {
      return row.map((ch, x) => {
        let type = levelChars[ch];
        if (typeof type == "string") return type;
        this.startActors.push(
          type.create(new Vec(x, y), ch));
        return "empty";
      });
    });
  }
}
```

يتم استخدام طريقة trim لإزالة المسافة البيضاء في بداية ونهاية سلسلة الخطة. يسمح هذا لمثالنا التصميم بالبدء في سطر جديد بحيث تكون جميع الخطوط أسفل بعضها مباشرة. يتم تقسيم السلسلة المتبقية وفقًا لأحرف السطر الجديد ، ويتم توزيع كل سطر داخل مصفوفة ويتم إنشاء مصفوفة من الأحرف.

لذلك تحتوي rows على مصفوفة من مصفوفات الأحرف ، صفوف الخطة. يمكننا اشتقاق عرض المستوى وارتفاعه من هذه. لكن لا يزال يتعين علينا فصل العناصر المتحركة عن grid الخلفية. سوف نطلق على العناصر المتحركة الجهات الفاعلة. سيتم تخزينها في مجموعة من العناصر. ستكون الخلفية عبارة عن مصفوفة من مصفوفات السلاسل ، أنواع الحقول  مثل "null" أو "wall" أو "lava".

لإنشاء هذه المصفوفات ، نقوم بتعيين الصفوف ثم فوق محتواها. تذكر أن الخريطة تمرر فهرس المصفوفة كوسيطة ثانية إلى وظيفة التعيين ، والتي تخبرنا بإحداثيات x و y لحرف معين. سيتم تخزين المواضع في اللعبة على شكل أزواج من الإحداثيات ، بحيث يكون أعلى اليسار 0،0 وكل مربع خلفية يكون ارتفاعه وعرضه وحدة واحدة.

لتفسير الأحرف الموجودة في الخطة ، يستخدم مُنشئ level كائن levelChars ، الذي يقوم بتعيين عناصر الخلفية إلى السلاسل وشخصيات الممثل إلى الفئات. عندما تكون type فئه الممثلين, يتم استخدام طريقة create الثابتة لإنشاء كائن, الذي تمت إضافته إلى startActor, وتقوم وظيفة التعيين بإرجاع "empty" لمربع الخلفية هذا.

يتم تخزين موضع الممثل ككائن Vec. هذا متجه ثنائي الأبعاد ، كائن له خصائص x و y ، كما هو موضح في تمارين الفصل   [Chapter 6](https://eloquentjavascript.net/06_object.html#exercise_vector).

أثناء تشغيل اللعبة ، سينتهي الأمر بالممثلين في أماكن مختلفة أو حتى يختفون تمامًا \(كما يحدث عند جمع العملات المعدنية\). سنستخدم فصل دراسي تابع للولاية لتتبع حالة لعبة الجري.

```text
class State {
  constructor(level, actors, status) {
    this.level = level;
    this.actors = actors;
    this.status = status;
  }

  static start(level) {
    return new State(level, level.startActors, "playing");
  }

  get player() {
    return this.actors.find(a => a.type == "player");
  }
}
```

ستتحول خاصية statusإلى "lost" أو "won" عند انتهاء اللعبة.

هذا مرة أخرى بنية بيانات ثابتة - يؤدي تحديث حالة اللعبة إلى إنشاء حالة جديدة وترك الحالة القديمة سليمة.

### Actors

تمثل كائنات الممثل الوضع الحالي والحالة لعنصر متحرك معين في لعبتنا. تتوافق جميع كائنات الجهات الفاعلة مع نفس الواجهة. تحتفظ خاصية pos الخاصة بهم بإحداثيات الزاوية العلوية اليسرى للعنصر ، وخاصية size الخاصة بهم تحمل حجمها.

ثم لديهم طريقة update ، والتي تُستخدم لحساب حالتهم الجديدة وموقعهم بعد خطوة زمنية معينة. إنه يحاكي الشيء الذي يقوم به الممثل - التحرك استجابة لمفاتيح الأسهم للاعب والارتداد ذهابًا وإيابًا للحمم البركانية - وإرجاع كائن ممثل جديد ومحدث.

تحتوي خاصية النوع على سلسلة تحدد نوع الممثل — "player" أو "coin" أو "lava". هذا مفيد عند رسم اللعبة - شكل المستطيل المرسوم للممثل يعتمد على نوعه.

تحتوي فئات الممثل على طريقة create ثابتة يستخدمها مُنشئ المستوى لإنشاء ممثل من شخصية في خطة المستوى. يتم إعطاؤه إحداثيات الشخصية والحرف نفسه ، وهو أمر ضروري لأن فئة Lava تتعامل مع عدة أحرف مختلفة.

هذه هي فئة Vec التي سنستخدمها لقيمنا ثنائية الأبعاد ، مثل موضع وحجم الممثلين.

```text
class Vec {
  constructor(x, y) {
    this.x = x; this.y = y;
  }
  plus(other) {
    return new Vec(this.x + other.x, this.y + other.y);
  }
  times(factor) {
    return new Vec(this.x * factor, this.y * factor);
  }
}
```

طريقة times تغير حجم متجه وفقًا للرقم المستلم. سيكون مفيدًا عندما نحتاج إلى ضرب متجه السرعة خلال فترة زمنية للحصول على المسافة المقطوعة خلال ذلك الوقت.

الأنواع المختلفة من الممثلين لها فصولها الخاصة ، لأن سلوكياتهم مختلفة جدًا. دعونا نحدد هذه الفئات. سنناقش طرق update الخاصة بهم لاحقًا.

فئة player لها خاصية تسمى speed تخزن سرعتها الحالية لمحاكاة الزخم.

```text
class Player {
  constructor(pos, speed) {
    this.pos = pos;
    this.speed = speed;
  }

  get type() { return "player"; }

  static create(pos) {
    return new Player(pos.plus(new Vec(0, -0.5)),
                      new Vec(0, 0));
  }
}

Player.prototype.size = new Vec(0.8, 1.5);
```

نظرًا لأن ارتفاع اللاعب يساوي مرة ونصف ارتفاع المربع ، يتم تعيين موضعه الأولي على نصف المربع أعلى الموضع الذي يظهر فيه الحرف @. سيؤدي هذا إلى محاذاة الجزء السفلي مع الجزء السفلي من المربع الذي يظهر فيه.

خاصية size هي نفسها لجميع العينات المأخوذة من player ، لذا يمكن تخزينها في النموذج الأولي بدلاً من تخزينها في prototype . يمكننا استخدام نوع getter مثل النوع ، ولكن في هذه الحالة ، سيتم إنشاء كائن Vec جديد وإعادته في كل مرة يتم فيها استدعاء الخاصية ، وهو أمر عديم الفائدة. \(لا تحتاج الأنظمة إلى إعادة إنشائها في كل مرة يتم فيها تقييمها ، لأنها غير قابلة للتغيير\).

عند إنشاء ممثل Lava ، يجب تعيين الكائن بشكل مختلف اعتمادًا على الشخصية القائمة عليه. . تتحرك الحمم الديناميكية بسرعتها الحالية حتى تصطدم بعقبة. في هذه المرحلة ، إذا كان لديها خاصية reset ، فستعود إلى موضعها الأصلي \(dripping\).إذا لم يحدث ذلك ، تنعكس سرعته وتستمر في التحرك في الاتجاه المعاكس \(bouncing\).

تبحث طريقة create في الأحرف المرسلة بواسطة مُنشئ المستوى وتقوم بإنشاء الجهات الفاعلة المناسبة في الحمم.

```text
class Lava {
  constructor(pos, speed, reset) {
    this.pos = pos;
    this.speed = speed;
    this.reset = reset;
  }

  get type() { return "lava"; }

  static create(pos, ch) {
    if (ch == "=") {
      return new Lava(pos, new Vec(2, 0));
    } else if (ch == "|") {
      return new Lava(pos, new Vec(0, 2));
    } else if (ch == "v") {
      return new Lava(pos, new Vec(0, 3), pos);
    }
  }
}

Lava.prototype.size = new Vec(1, 1);
```

الجهات الفاعلة في coin بسيطة نسبيًا. معظمهم يبقون في مكانهم. ولكن لإضافة القليل من الديناميكية إلى اللعبة ، نقوم بنقلها في مكانها. ولكن لإضفاء الحيوية على اللعبة قليلاً ، يتم إعطاؤهم "wobble" ، حركة رأسية خفيفة ذهابًا وإيابًا. لتتبع هذا ، يخزن كائن عملة معدنية موضعًا أساسيًا بالإضافة إلى خاصية wobble التي تتعقب مرحلة حركة الارتداد. معًا ، تحدد هذه العناصر الموقع الفعلي للعملة \(المخزنة في خاصية نقاط البيع\).

```text
class Coin {
  constructor(pos, basePos, wobble) {
    this.pos = pos;
    this.basePos = basePos;
    this.wobble = wobble;
  }

  get type() { return "coin"; }

  static create(pos) {
    let basePos = pos.plus(new Vec(0.2, 0.1));
    return new Coin(basePos, basePos,
                    Math.random() * Math.PI * 2);
  }
}

Coin.prototype.size = new Vec(0.6, 0.6);
```

في الفصل   [Chapter 14](https://eloquentjavascript.net/14_dom.html#sin_cos) ، رأينا أن Math.sin تعطينا إحداثي y لنقطة على دائرة. ينتقل هذا الإحداثي ذهابًا وإيابًا في شكل موجي سلس بينما نتحرك على طول الدائرة ، مما يجعل وظيفة الجيب مفيدة لنمذجة حركة متموجة.

لمنع جميع العملات من الصعود والنزول في نفس الوقت ، يتم تحديد مرحلة البداية لكل عملة بشكل عشوائي. . الطور الموجي لـ Math.sin هو الطول الموجي الذي ينتجه ويساوي 2π. . اضرب القيمة المرجعة لـ Math.random في هذا الرقم لإعطاء موضع بداية عشوائي للعملة على الموجة.

يمكننا الآن تحديد كائن levelChars يقوم بتعيين أحرف الرسم لأنواع grid الخلفية أو فئات الممثلين.

```text
const levelChars = {
  ".": "empty", "#": "wall", "+": "lava",
  "@": Player, "o": Coin,
  "=": Lava, "|": Lava, "v": Lava
};
```

هذا يعطينا جميع المكونات اللازمة لإنشاء عينة level.

```text
let simpleLevel = new Level(simpleLevelPlan);
console.log(`${simpleLevel.width} by ${simpleLevel.height}`);
// → 22 by 9
```

المهمة المقبلة هي عرض هذه المستويات على الشاشة ووضع نموذج للوقت والحركة بداخلها.

### Encapsulation as a burden

تمت كتابة معظم الكود في هذا الفصل بدون تغليف ، وذلك لسببين.. أولاً ، يتطلب التغليف المزيد من العمل منا. يجعل البرنامج أكبر ويتطلب المزيد من المفاهيم والواجهات. نظرًا لأنه لا يمكن عرض الكثير من التعليمات البرمجية هنا وسيكون الأمر مملًا للقارئ ، فقد حاولت إبقاء البرنامج صغيرًا.

ثانيًا ، العناصر المختلفة داخل اللعبة مرتبطة ارتباطًا وثيقًا ، وإذا تغير سلوك أحدها ، فمن غير المرجح أن تظل العناصر الأخرى كما هي. قد تؤدي العلاقة بين هذه العناصر إلى العديد من الافتراضات حول كيفية عمل اللعبة. هذا يقلل بشكل كبير من فعالية هذه العلاقات - في كل مرة تقوم فيها بتغيير جزء من النظام ، لا يزال عليك القلق بشأن كيفية تأثيره على الأجزاء الأخرى لأن علاقاتهم لا تلبي المتطلبات الجديدة.

يمكن فصل بعض نقاط القطع في النظام جيدًا من خلال واجهات صارمة ، لكن البعض الآخر لا يفعل ذلك. إن محاولة تغليف شيء ليس بالحدود المناسبة هي طريقة أكيدة لإهدار الكثير من الطاقة. عندما ترتكب هذا الخطأ ، ستلاحظ عادةً أن واجهاتك أصبحت كبيرة ومفصلة بشكل محرج وأنه يجب تغييرها كثيرًا مع تطور البرنامج.

هناك شيء واحد سنقوم بتغليفه ، وهو نظام الرسم الفرعي. والسبب في ذلك هو أننا سنعرض نفس اللعبة بطريقة مختلفة في الفصل  [next chapter](https://eloquentjavascript.net/17_canvas.html#canvasdisplay)  من خلال وضع الرسم خلف الواجهة ، يمكننا تحميل نفس برنامج اللعبة هناك وتوصيل وحدة عرض جديدة.

### Drawing <a id="domdisplay"></a>

يتم تغليف رمز الرسم عن طريق تحديد كائن عرض ، والذي يعرض مستوى وحالة معينين. نوع العرض الذي نحدده في هذا الفصل يسمى DOMDisplay لأنه يستخدم عناصر DOM لإظهار المستوى.

سنستخدم ورقة أنماط لتعيين الألوان الفعلية والخصائص الثابتة الأخرى للعناصر التي تتكون منها اللعبة. سيكون من الممكن أيضًا التعيين المباشر لخاصية نمط العناصر عند إنشائها ، ولكن هذا من شأنه أن ينتج المزيد من البرامج المطولة.

توفر الوظيفة المساعدة التالية طريقة موجزة لإنشاء عنصر وإعطائه بعض السمات والعقد الفرعية:

```text
function elt(name, attrs, ...children) {
  let dom = document.createElement(name);
  for (let attr of Object.keys(attrs)) {
    dom.setAttribute(attr, attrs[attr]);
  }
  for (let child of children) {
    dom.appendChild(child);
  }
  return dom;
}
```

يتم إنشاء العرض من خلال إعطائها عنصرًا رئيسيًا يجب أن تلحق به وكائن مستوى.

```text
class DOMDisplay {
  constructor(parent, level) {
    this.dom = elt("div", {class: "game"}, drawGrid(level));
    this.actorLayer = null;
    parent.appendChild(this.dom);
  }

  clear() { this.dom.remove(); }
}
```

يتم رسم شبكة الخلفية للمستوى ، والتي لا تتغير أبدًا ، مرة واحدة. يتم إعادة رسم الممثلين في كل مرة يتم فيها تحديث الشاشة بحالة معينة. ستُستخدم الخاصية actLayer لتعقب العنصر الذي يحمل الممثلين بحيث يمكن إزالتها واستبدالها بسهولة.

يتم تتبع إحداثياتنا وأحجامنا في وحدات الشبكة ، حيث يعني الحجم أو المسافة 1 كتلة شبكة واحدة. . عند تعيين أحجام البكسل ، سيتعين علينا توسيع نطاق هذه الإحداثيات - كل شيء في اللعبة سيكون صغيرًا بشكل يبعث على السخرية عند بكسل واحد لكل مربع. يعطي ثابت المقياس عدد البيكسلات التي تشغلها وحدة واحدة على الشاشة.

```text
const scale = 20;

function drawGrid(level) {
  return elt("table", {
    class: "background",
    style: `width: ${level.width * scale}px`
  }, ...level.rows.map(row =>
    elt("tr", {style: `height: ${scale}px`},
        ...row.map(type => elt("td", {class: type})))
  ));
}
```

كما ذكرنا ، يتم رسم الخلفية كعنصر&lt;table&gt; . يتوافق هذا بشكل جيد مع بنية خاصية الصفوف للمستوى - يتم تحويل كل صف من الشبكة إلى صف جدول \(عنصر&lt;tr&gt; \).يتم استخدام السلاسل الموجودة في الشبكة كأسماء فئة لعناصر خلية الجدول \(td\). يتم استخدام عامل الانتشار \(النقطة الثلاثية\) لتمرير مصفوفات من العقد الفرعية إلى elt كوسيطات منفصلة.

يجعل CSS التالي الجدول يبدو مثل الخلفية التي نريدها:

```text
.background    { background: rgb(52, 166, 251);
                 table-layout: fixed;
                 border-spacing: 0;              }
.background td { padding: 0;                     }
.lava          { background: rgb(255, 100, 100); }
.wall          { background: white;              }
```







