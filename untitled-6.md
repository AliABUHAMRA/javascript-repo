# Bugs and Errors

> تعد إصلاحات الأخطاء ضعف صعوبة الترميز الأساسي. لذلك إذا كان الكود الذي تكتبه ذكيًا جدًا ، فلن تتمكن من إصلاح الخطأ بحكم التعريف.

> Brian Kernighan and P.J. Plauger, The Elements of Programming Style

![](.gitbook/assets/image%20%285%29.png)

في برامج الكمبيوتر ، يُشار إلى الأخطاء عادةً باسم الأخطاء. هذه التسمية منطقية للمبرمجين لأنهم يفكرون في عيوب البرنامج كحشرات صغيرة تزحف داخل البرنامج. بالطبع ، لقد أنشأنا هذه الأخطاء بأنفسنا.

إذا كان البرنامج عبارة عن فكرة متبلورة ، فيمكنك تصنيف الأخطاء تقريبًا إلى تلك التي تسببها الأفكار التي يتم الخلط بينها وتلك التي تسببها الأخطاء التي يتم تقديمها أثناء تحويل الفكرة إلى رمز. عادةً ما يكون اكتشاف الفئة الأولى من الأخطاء وإصلاحها أكثر صعوبة من الفئة الثانية.

### Language

عند البرمجة ، إذا كان الكمبيوتر يعرف ما يكفي عما نحاول القيام به ، فيمكنه اكتشاف العديد من الأخطاء وإظهارها لنا تلقائيًا. لكن نظام التسامح القائم على JavaScript بحد ذاته يمثل عقبة. تعتبر مفاهيم المتغيرات والخصائص في JavaScript غامضة بدرجة كافية لدرجة أن JavaScript نادرًا ما يمكنها اكتشاف الأخطاء المطبعية قبل تشغيل البرنامج. وحتى ذلك الحين ، فهي تتيح لك القيام ببعض الأشياء التي لا معنى لها تمامًا مثل                 حساب \("القرد" \*  true\)  دون حدوث أخطاء.

هناك حالات تتفاعل فيها JavaScript معها. على سبيل المثال ، سيؤدي كتابة برنامج لا يتبع القواعد النحوية للغة إلى حدوث خطأ. حالات أخرى ، مثل استدعاء شيء ليس من نوع دالة أو الإشارة إلى خاصية على قيمة غير محددة ، تتسبب في الإبلاغ عن خطأ عند تنفيذ هذا الأمر.

ولكن في كثير من الأحيان ، تنتج العمليات الحسابية التي لا معنى لها NaN \(قيمة غير رقمية\) أو قيمة غير محددة undefiend، بينما يستمر البرنامج بسعادة ، مقتنعًا بأنه يفعل شيئًا ذا مغزى. سيظهر الخطأ في وقت لاحق فقط ، بعد انتقال القيمة الزائفة عبر عدة وظائف. قد لا يولد خطأ على الإطلاق ، لكنه سينتج مخرجات خاطئة في البرنامج عندما تنطفئ الأضواء. قد يكون العثور على مصدر مثل هذه الأخطاء أمرًا صعبًا حقًا.

 عملية البحث عن الأخطاء '**bugs**' في البرامج يسمى  '_**debugging**'_.

### Strict mode الوضع الصارم

من خلال تنشيط الوضع المتشدد'strict' ، يمكنك جعل JavaScript أكثر صرامة, يمكن القيام بذلك عن طريق وضع سلسلة "use strict" في أعلى ملف أو نص دالة:

```text
function canYouSpotTheProblem() {
  "use strict";
  for (counter = 0; counter < 10; counter++) {
    console.log("Happy happy");
  }
}

canYouSpotTheProblem();
// → ReferenceError: counter is not defined
```

عادة ، عندما تنسى وضع let  أمام الربط الخاص بك , كما هو الحال معا counter في المثال. ينشئ JavaScript بهدوء ارتباطًا عالميًا ويستخدم ذلك في strict mode , سيظهر لك خطأ بدلاً من ذلك.             هذا مفيد جدا. لاحظ ، مع ذلك ، أنه إذا تم تعريف المتغير بالفعل علنًا ، فلن يحدث خطأ ، ويتم إعادة تعيين قيمته بواسطة متغير يحمل نفس الاسم في الحلقة.

هناك اختلاف آخر في الحالة strict  وهو أنه في الوظائف التي لا تُسمى طرق ، سيكون للمتغير this القيمة undefined. عند إجراء مثل هذه المكالمة خارج الوضع المتشدد ، يشير this إلى كائن النطاق العالمي.         وهو كائن خصائصه هي الارتباطات العالمية. لذلك إذا اتصلت ب method   أوconstructor  بشكل غير صحيح في الوضع المتشدد. سوف ينتج عن JavaScript خطأ بمجرد محاولته قراءة شيء ما من this ، بدلاً من الكتابة بسعادة إلى النطاق العالمي.

على سبيل المثال ، ضع في اعتبارك الكود التالي ، الذي يستدعي دالة مُنشئ بدون الكلمة الأساسية new بحيث لا يشير this إلى كائن تم إنشاؤه حديثًا:

```text
function Person(name) { this.name = name; }
let ferdinand = Person("Ferdinand"); // oops
console.log(name);
// → Ferdinand
```

لذلك سيتم تنفيذ استدعاء person الوهمي هذا ولكنه يولد قيمة undefined  وينشئ متغير name في المساحة العامة. في حالة صارمة ستكون النتيجة مختلفة.

```text
"use strict";
function Person(name) { this.name = name; }
let ferdinand = Person("Ferdinand"); // forgot new
// → TypeError: Cannot set property 'name' of undefined
```

يتم إعلامنا على الفور بوجود خطأ ، وهو أمر مفيد للغاية.

لحسن الحظ ، فإن المنشئين الذين تم إنشاؤهم باستخدام تدوين calss سيشتكون دائمًا إذا تم استدعاؤهم بدون new إنها تولد أخطاء تقلل المشكلة قليلاً حتى في الوضع غير الصارم.

في الوضع المتشدد ، تحدث عدة أشياء أخرى. لا يسمح بإعطاء دالة معلمات متعددة بنفس الاسم , و كما أنه يزيل بعض الأجزاء الإشكالية من اللغة تمامًا. \(مثل الأمر with ، الذي لم يناقش في هذا الكتاب لأنه لا فائدة منه.\)

### Types

تهتم بعض لغات البرمجة بالحصول على نوع المتغيرات والعبارات المتاحة قبل تشغيل البرنامج. من خلال القيام بذلك ، سيقومون بإعلامك بمجرد إساءة استخدام نوع من البيانات. . تأخذ JavaScript في الاعتبار أنواع البيانات فقط عند تشغيل البرنامج ، حتى في نفس الوقت تحاول تحويل القيم ضمنيًا إلى ما تتوقعه ، وهو أمر غير مفيد للغاية.

ومع ذلك ، توفر أنواع البيانات إطار عمل مفيدًا لمناقشة التطبيقات. تحدث العديد من الأخطاء بسبب وجود غموض حول نوع البيانات التي يتم إرسالها أو استلامها من إحدى الوظائف. إذا كانت لديك مثل هذه المعلومات كتابيًا ، فستكون أقل ارتباكًا.

يمكنك إضافة تعليق مثل التالي قبل وظيفة targetOrientedRobot من الفصل السابق لوصف نوعها

```text
// (VillageState, Array) → {direction: string, memory: Array}
function goalOrientedRobot(state, memory) {
  // ...
}
```

هناك العديد من أنماط تضمين أنواع البيانات في تطبيقات JavaScript.

شيء واحد حول الأنواع هو أنها تحتاج إلى تقديم تعقيدها الخاص لتكون قادر على وصف ما يكفي من التعليمات البرمجية لتكون مفيدة. ما رأيك في نوع دالة randomPick التي تُرجع عنصرًا عشوائيًا من مصفوفة؟       ستحتاج إلى إدخال متغير نوع T. والتي يمكن استخدامها لأي نوع ؛ نتيجة لذلك ، يمكنك تعيين نوع مشابه

  `([T]) → T` \(function from an array of _T_s to a _T_\).

بمجرد معرفة أنواع بيانات البرنامج ، يمكن الآن استخدام الكمبيوتر للتحقق منها حتى نتمكن من اكتشاف الأخطاء قبل التنفيذ. هناك العديد من لهجات JavaScript التي تضيف وتتحقق من أنواع البيانات في اللغة.وأكثرها شيوعًا هو  [TypeScript](https://www.typescriptlang.org/) . إذا كنت ترغب في إضافة المزيد من الصلابة إلى برامجك ، أقترح عليك التعرف عليها.

في هذا الكتاب ، سنستمر في استخدام كود جافا سكريبت خام وخطير وغير نوع.

### Testing

إذا كانت لغة البرمجة لن تساعدنا في العثور على الأخطاء ، فعلينا إيجادها بطريقة أصعب: عن طريق تشغيل البرنامج ومعرفة ما إذا كان يعمل بشكل صحيح.

يعد القيام بذلك يدويًا وبأعداد كبيرة فكرة سيئة حقًا. إنه ليس مزعجًا فحسب ، بل سيكون غير فعال بالفعل ؛ لأنه مع كل تغيير صغير ، يتم قضاء الكثير من الوقت في تجربة كل شيء من البداية.

تقوم أجهزة الكمبيوتر بمهام متكررة بشكل جيد للغاية ، وهي مثالية لتجربة مهمة متكررة. الاختبار الآلي هو العملية التي يتم من خلالها كتابة برنامج لاختبار برنامج آخر. تتطلب كتابة الاختبار عملاً أكثر من اختبار البرنامج يدويًا ، ولكن بمجرد كتابته ، ستكتسب نوعًا من القوة الخارقة للطبيعة: لن يستغرق الأمر سوى بضع ثوانٍ للتأكد من أن برنامجك يعمل بشكل صحيح في جميع المواقف التي كتبت فيها الاختبار. أم لا.  عندما يواجه جزء من البرنامج مشكلة ، ستلاحظها على الفور ، حتى تصادفها عن طريق الخطأ في المستقبل.

عادةً ما تتم كتابة الاختبارات في شكل برامج صغيرة ، يتم تصنيف كل منها ، والتي تراجع بعض جوانب التعليمات البرمجية الخاصة بك. على سبيل المثال ، قد تبدو مجموعة الاختبار لطريقة toUpperCase \(ربما تم اختبار الطرق القياسية من قبل الآخرين\) كما يلي:

```text
function test(label, body) {
  if (!body()) console.log(`Failed: ${label}`);
}

test("convert Latin text to uppercase", () => {
  return "hello".toUpperCase() == "HELLO";
});
test("convert Greek text to uppercase", () => {
  return "Χαίρετε".toUpperCase() == "ΧΑΊΡΕΤΕ";
});
test("don't convert case-less characters", () => {
  return "مرحبا".toUpperCase() == "مرحبا";
});
```

تنتج اختبارات الكتابة مثل الاختبار أعلاه رمزًا مكررًا وغير مناسب نسبيًا. لحسن الحظ ، هناك برامج تساعدك على بناء وتشغيل مجموعات الاختبار\( _test suites_\). يتم ذلك من خلال توفير لغة \(في شكل وظائف وطرق\) 

\(in the form of functions and methods \) 

مناسبة لإنتاج الاختبار. ، قم بإنتاج معلومات مفيدة عند فشل test. عادة ما تسمى هذه البرامج عداء الاختبار \(test runner\).

بعض التعليمات البرمجية أسهل في الاختبار من التعليمات البرمجية الأخرى. بشكل عام ، كلما زاد عدد الكائنات الخارجية التي تتفاعل معها الشفرة ، زادت صعوبة إعداد السياق الذي يتم اختباره فيه. يميل أسلوب البرمجة الموضح في  [previous chapter](https://eloquentjavascript.net/07_robot.html), الفصل السابق  ، والذي يستخدم قيمًا ثابتة قائمة بذاتها بدلاً من تغيير الكائنات ، إلى أن يكون من السهل اختباره.

### Debugging

بمجرد أن تلاحظ وجود خطأ ما في برنامجك لأنه يسيء التصرف أو ينتج عنه أخطاء ، فإن الخطوة التالية هي معرفة ماهية المشكلة.

أحيانا يكون ذلك واضحا. ستشير رسالة الخطأ إلى سطر معين من برنامجك ، وإذا نظرت إلى وصف الخطأ وسطر التعليمات البرمجية هذا ، يمكنك غالبًا رؤية المشكلة.

لكن ليس دائما. في بعض الأحيان يكون الخطاء الذي أثار المشكلة هو ببساطة المكان الأول الذي يتم فيه استخدام القيمة غير المستقرة الذي تم انشاءوها  في مكان آخر بطريقة غير صالحة. إذا كنت قد قمت بحل التمارين في فصول سابقة ، فمن المحتمل أنك واجهت مثل هذه المواقف بالفعل.

يحاول البرنامج المثال التالي تحويل عدد صحيح إلى سلسلة في أساس معين \(عشري ، ثنائي ، وما إلى ذلك\) عن طريق اختيار آخر رقم بشكل متكرر ثم قسمة الرقم للتخلص من هذا الرقم. لكن المخرجات الغريبة التي تنتجها حاليًا تشير إلى وجود خطأ.

```text
function numberToString(n, base = 10) {
  let result = "", sign = "";
  if (n < 0) {
    sign = "-";
    n = -n;
  }
  do {
    result = String(n % base) + result;
    n /= base;
  } while (n > 0);
  return sign + result;
}
console.log(numberToString(13, 10));
// → 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e-3181.3…
```

حتى إذا كنت ترى المشكلة بالفعل ، فتظاهر للحظة أنك لست كذلك. نحن نعلم أن برنامجنا به خلل ، ونريد معرفة السبب.

هذه هي اللحظة التي يتعين عليك فيها مقاومة إغراء إجراء تغييرات عشوائية لحل مشكلة ما. بدلاً من ذلك ، فكر في هذه على أنها إجراءات يجب عليك اتخاذها على أساس منتظم. افحص ما يحدث وابحث عن نظرية يمكن أن تشرح هذه الوظيفة. بعد ذلك ، قم بإجراء المزيد من الملاحظات لاختبار هذه النظرية - أو إذا لم يكن لديك أي نظريات حتى الآن ، فقم بإجراء المزيد من الملاحظات لمساعدتك في العثور على نظرية.

يعد وضع بعض console.log الإستراتيجي في التطبيق طريقة جيدة للحصول على مزيد من المعلومات حول كيفية عمل التطبيق. نريد من n ان تاخذ  قيمه 13,1  وثم 0 , دعنا نكتب قيمتها في بداية الحلقة.



```text
13
1.3
0.13
0.013
…
1.5e-323
```

هذا صحيح. قسمة 13 على 10 لا ينتج عنها أعداد صحيحة. بدلاً من استخدام n / = base ، ما نحتاجه بالفعل هو \(n = Math.floor \(n / base\) ، وفي هذه الحالة يتم إعطاء الرقم بشكل صحيح على يمين "التحول".

أحد البدائل لاستخدام console.log لإلقاء نظرة خاطفة على سلوك البرنامج هو استخدام إمكانيات مصحح الأخطاء في متصفحك, تحتوي المستعرضات على ميزة يمكن استخدامها لإنشاء نقطة توقف\(breakpoint\) على سطر معين من التعليمات البرمجية. عندما يصل تنفيذ البرنامج إلى سطر به نقطة توقف ، يتم إيقافه مؤقتًا ، ويمكنك فحص قيم الارتباطات في تلك المرحلة.لن أخوض في التفاصيل ، لأن أدوات تصحيح الأخطاء تختلف من متصفح لآخر ، ولكن ابحث في أدوات مطور\(Developer Tools\) المتصفح أو ابحث في الويب للحصول على مزيد من المعلومات.

هناك طريقة أخرى لتعيين نقطة توقف وهي تضمين عبارة مصحح الأخطاء\( `debugger` \) \(تتكون من تلك الكلمة الأساسية\) في برنامجك . إذا كانت أدوات المطور في متصفحك نشطة ، فسيتوقف البرنامج مؤقتًا عندما يصل إلى مثل هذا البيان.

### Error propagation  انتشار الخطأ

لسوء الحظ ، لا يمكن للمبرمج منع جميع المشكلات. إذا كان برنامجك يتواصل مع العالم الخارجي بأي شكل من الأشكال ، فمن الممكن الحصول على مدخلات مشوهة ، أو أن تصبح مثقلًا بالعمل ، أو تعطل الشبكة.

إذا كنت تقوم بالبرمجة لنفسك فقط ، فيمكنك تجاهل مثل هذه المشكلات حتى تحدث. . ولكن إذا كنت تقوم ببناء شيء سيستخدمه الآخرون ، فمن الضروري عادةً ألا يتعطل البرنامج تمامًا وأن يتفاعل بشكل أفضل في حالة حدوث مشكلة. أحيانًا يكون الشيء الصحيح الذي يجب فعله هو الاستمرار في تشغيل البرنامج على الرغم من تلقي مدخلات غير مناسبة. في حالات أخرى ، من الأفضل إبلاغ المستخدم بالخطأ الذي حدث ثم يستسلم. ولكن في كلتا الحالتين ، يتعين على البرنامج أن يفعل شيئًا بنشاط استجابةً للمشكلة.

افترض أن لديك وظيفة تسمى "promptNumber" تطلب من المستخدم إدخال رقم لإرجاعه. إذا أرسل المستخدم المدخلات "orange" ، فماذا سيكون ناتج الوظيفة؟

يمكن أن يكون الخيار لإرجاع قيمة معينة. الخيار الشائع لهذه الشروط هو null أو undefined أو 1-.

```text
function promptNumber(question) {
  let result = Number(prompt(question));
  if (Number.isNaN(result)) return null;
  else return result;
}

console.log(promptNumber("How many trees do you see?"));
```

الآن يجب أن يتحقق أي رمز يستدعي وظيفة "promptNumber" من قراءة رقم حقيقي ، وإلا فإنه يجب تجاوزه بطريقة ما - ربما عن طريق إعادة طلب أو إرسال قيمة رقمية افتراضية, . ويمكنه أيضًا إرجاع قيمة معينة إلى المتصل للإشارة إلى حدوث مشكلة او انه فشل في تنفيذ  ماطلب .

في كثير من الحالات ، غالبًا عندما تكون الأخطاء شائعة ويجب على المتصل أخذها في الاعتبار بشكل صريح ، فإن إرجاع قيمة خاصة يعد طريقة جيدة للإشارة إلى خطأ. هذه طريقة جيدة ولكن لها أيضًا مشاكلها, أولاً ، ماذا لو أن الدالة يمكن أن تُرجع أي قيمة محتملة؟ في وظيفة بهذه الميزة ، عليك أن تفعل شيئًا لتتمكن من التمييز بين النجاح والفشل ؛ مثل وضع نتيجة دالة داخل كائن.

```text
function lastElement(array) {
  if (array.length == 0) {
    return {failed: true};
  } else {
    return {element: array[array.length - 1]};
  }
}
```

المشكلة التالية في إرجاع قيم معينة هي أن هذا قد يؤدي إلى رمز غير صحيح . إذا كان الرمز يستدعي الدالة 'promptNumber'  على  10 مرات ، فيجب أن تتحقق 10 مرات لمعرفة ما إذا تم إرجاع قيمةnull .         وإذا كانت استجابتها لإيجاد قيمة nullهي ببساطة إرجاع القيمة null نفسها ، فسيتعين على مستدعي الوظيفة بدورهم التحقق منها ، وهكذا.

### Exceptions  استثناءات

عندما لا تستطيع إحدى الوظائف الاستمرار في العمل بشكل طبيعي ، فإن الشيء الصحيح الذي يجب فعله هو إيقاف الوظيفة ونقل التحكم في البرنامج فورًا إلى الجزء الذي يعرف كيفيه التعامل معا المشكلات . هذا ما تفعله إدارة الاستثناءات.

الاستثناءات هي آلية تجعل من الممكن للشفرة التي تواجه مشكلة أن تثير \(أو ترمي \) استثناءً. يمكن أن يكون الاستثناء أي قيمة. يشبه رفع واحد إلى حد ما عائدًا فائق الشحن من دالة: فهو يقفز ليس فقط من الوظيفة الحالية ولكن أيضًا من المتصلين بها ، وصولاً إلى الاستدعاء الأول الذي بدأ التنفيذ الحالي. وهذا ما يسمى بفك المكدس. قد تتذكر مجموعة استدعاءات الوظائف التي تم ذكرها في  [Chapter 3](https://eloquentjavascript.net/03_functions.html#stack).. هناك استثناء يقوم بتكبير حجم هذه المجموعة ، مما يؤدي إلى التخلص من جميع سياقات الاستدعاء التي يواجهها.

إذا كانت الاستثناءات تنتقل دائمًا إلى نهاية الحزمة ، فإنها لم تفعل شيئًا مفيدًا. من خلال القيام بذلك ، فإنهم يقدمون فقط طريقة جديدة لتعطيل خطتك. تكمن قوتهم في حقيقة أنه يمكنك إنشاء "catch" في المكدس بحيث يمكنك التقاط هذه الاستثناءات أثناء تكديسها. بمجرد حصولك على استثناء ، يمكنك القيام بشيء ما لإصلاح المشكلة وبعد ذلك سيستمر تشغيل البرنامج.

فكر في مثال:

```text
function promptDirection(question) {
  let result = prompt(question);
  if (result.toLowerCase() == "left") return "L";
  if (result.toLowerCase() == "right") return "R";
  throw new Error("Invalid direction: " + result);
}

function look() {
  if (promptDirection("Which way?") == "L") {
    return "a house";
  } else {
    return "two angry bears";
  }
}

try {
  console.log("You see", look());
} catch (error) {
  console.log("Something went wrong: " + error);
```

يتم استخدام كلمة throw لإثارة استثناء. يتم اصطياد واحد من خلال لف جزء من التعليمات البرمجية في كتلة المحاولة ، متبوعًا بالكلمة الرئيسية التقاط. عندما يتسبب الكود الموجود في كتلة try في ظهور استثناء ، يتم تقييم كتلة catch ، مع ربط الاسم بين قوسين بقيمة الاستثناء. بعد انتهاء كتلة catch - أو إذا انتهت كتلة try دون مشاكل - يتابع البرنامج أسفل جملة try / catch بأكملها.

في هذا المثال ، استخدمنا مُنشئ Errorلإنشاء قيمة الاستثناء. هذه الوظيفة عبارة عن مُنشئ JavaScript قياسي يقوم بإنشاء كائن بخاصية تسمى message. في معظم بيئات JavaScript ، تحتوي المثيلات التي تم إنشاؤها باستخدام هذا المُنشئ على معلومات حول مكدس الاستدعاءات الذي كان موجودًا عند حدوث استثناء ، يُسمى  \(_stack trace_\) يتم تخزين هذه المعلومات في خاصية stack ويمكن أن تكون مفيدة أثناء تصحيح الأخطاء: يظهر لنا الوظيفة التي حدثت فيها المشكلة والوظائف التي استدعت المشكلة بها.

لاحظ أن وظيفة look لا تأخذ في الحسبان احتمال وجود مشاكل في وظيفة promptDirection . هذه ميزة كبيرة لاستخدام الاستثناءات: رمز إدارة الخطأ مطلوب فقط عند حدوث الخطأ أو حيث تتم إدارة الخطأ. قد لا تعمل الدالات بين الاثنين على الإطلاق.

جيد جدًا ، تقريبًا…

### Cleaning up after exceptions  التنظيف بعد الاستثناءات

تأثير الاستثناء في التطبيق هو نوع آخر من تدفق التحكم. أي إجراء يُنشئ استثناءً ، وتقريبًا أي استدعاء للدالة والوصول إلى الخاصية ,  قد يتحكم في البرنامج من التعليمات البرمجية الخاصة بك.

هذا يعني أنه عندما يكون للرمز آثار جانبية متعددة ، حتى إذا كان تدفق التحكم العادي يبدو ثابتًا ، فقد يمنع استثناء بعض منها من العمل.

ستجد هنا رمزًا سيئًا للغاية يقوم بالعمل المصرفي:

```text
const accounts = {
  a: 100,
  b: 0,
  c: 20
};

function getAccount() {
  let accountName = prompt("Enter an account name");
  if (!accounts.hasOwnProperty(accountName)) {
    throw new Error(`No such account: ${accountName}`);
  }
  return accountName;
}

function transfer(from, amount) {
  if (accounts[from] < amount) return;
  accounts[from] -= amount;
  accounts[getAccount()] += amount;
}
```

تقوم وظيفة transfer بتحويل بعض الأموال من حساب معين إلى حساب آخر وتطلب اسم حساب آخر أثناء العملية. إذا أعطيت اسم حساب غير صالح ، فإن getAccount يطرح استثناءً.

لكن التحويل أولاً يزيل الأموال من الحساب ثم يستدعي getAccount قبل إضافته إلى حساب آخر. إذا تم كسرها من قبل استثناء في تلك المرحلة ، فستجعل المال يختفي.

كان من الممكن كتابة هذا الرمز بطريقة أكثر ذكاءً ، على سبيل المثال عن طريق استدعاء getAccount قبل أن يبدأ في نقل الأموال. لكن غالبًا ما تحدث مشكلات مثل هذه بطرق أكثر دقة. . حتى الوظائف التي لا يُفترض أن تنتج استثناء قد تفعل ذلك في ظروف معينة أو في الحالات التي يرتكب فيها المبرمج خطأ.

طريقة واحدة للتغلب على هذه المشكلة هي استخدام آثار جانبية أقل. مرة أخرى ، سيكون أسلوب البرمجة الذي يتم فيه إجراء العمليات الحسابية على القيم الجديدة بدلاً من تغيير البيانات الحالية مفيدًا للغاية. . إذا توقف الرمز في منتصف إنشاء قيمة جديدة ، فلن يتلقى أي شخص قيمة شبه كاملة ولن تنشأ مشكلة.

لكن هذا ليس ممكن دائما. لذلك ، يتم توفير ميزة أخرى لها في الأمر try. يمكن أن يتبعهم كتلة finaly إما بدلاً من أو بالإضافة إلى كتلة catch. تقول الكتلة final"بغض النظر عما يحدث ، قم بتشغيل هذا الرمز بعد محاولة تشغيل الكود في كتلة try."

```text
function transfer(from, amount) {
  if (accounts[from] < amount) return;
  let progress = 0;
  try {
    accounts[from] -= amount;
    progress = 1;
    accounts[getAccount()] += amount;
    progress = 2;
  } finally {
    if (progress == 1) {
      accounts[from] += amount;
    }
  }
}
```

يتتبع هذا الإصدار من الوظيفة مدى تقدمه ، وإذا لاحظ ، عند مغادرته ، أنه قد تم إجهاضه في نقطة كان قد أنشأ فيها حالة برنامج غير متسقة ، فإنه يصلح الضرر الذي أحدثته.

لاحظ أنه على الرغم من تشغيل الكود finallyعند طرح استثناء في كتلة try ، إلا أنه لا يتداخل مع الاستثناء. بعد تشغيل الكتلة finally، يستمر المكدس في فك اللف.

من الصعب جدًا كتابة برامج تعمل دائمًا بشكل مثالي ، حتى عند حدوث استثناء في مواقف غير متوقعة. كثير من المبرمجين لا يضايقون أنفسهم ، ولأن الاستثناءات تحدث عادة في مواقف معينة ، نادرًا ما تحدث هذه المشكلة ولا يلاحظها أحد. يعتمد الخير أو السيئ على مقدار الضرر الذي سيحدثه في حالة حدوثه.

### Selective catching  خذ الاستثناءات بشكل انتقائي

عندما ينتقل استثناء إلى نهاية الحزمة دون أن يشغل مساحة ، تتم إدارته في النهاية بواسطة البيئة القابلة للتنفيذ. يختلف معنى هذه العبارة باختلاف البيئات. في المتصفحات,  عادةً ما تتم كتابة وصف الخطأ في وحدة تحكم JavaScript \(والتي يمكن العثور عليها في شريط أدوات المتصفح \(Developer Menu\) أو قائمة المطور\). في node.js ، البيئة الخالية من المستعرضات القائمة على JavaScript والتي سنناقشها في  [Chapter 20](https://eloquentjavascript.net/20_node.html) تكون أكثر حرصًا بشأن تلف البيانات. إذا كان هناك استثناء غير مُدار ، فستتوقف عملية البرنامج بأكملها.

بالنسبة لأخطاء المبرمج ، من الأفضل غالبًا ترك الخطأ يسير في طريقه. يعد الاستثناء غير المُدار سببًا جيدًا لحدوث مشكلة في البرنامج ، وتوفر وحدة تحكم JavaScript في المتصفحات الحديثة معلومات حول المكالمات التي كانت على المكدس عند حدوث المشكلة.

يعد إيقاف البرنامج بسبب استثناء غير مُدار والذي كان من الممكن أن نتوقعه مسبقًا استراتيجية سيئة للغاية.

الاستخدام غير السليم للغة ، مثل الإشارة إلى متغير غير موجود ، أو طلب خاصية ذات قيمة null، أو استدعاء شيء ليس وظيفة ، يولد أيضًا استثناءات. يمكن أيضًا أخذ هذه الاستثناءات وإدارتها.

عندما يتم إدخال جسم catch ، كل ما نعرفه هو أن شيئًا ما في جسم try تسبب في استثناء. لكننا لا نعرف ما الذي حدث أو أي استثناء تسببت فيه.

جافا سكريبت \(في إغفال صارخ إلى حد ما\) لا تقدم دعمًا مباشرًا لاستثناءات الالتقاط الانتقائي: إما أن تلتقطها كلها أو لا تلتقطها. هذا يجعل من المغري أن تفترض أن الاستثناء الذي تحصل عليه هو الاستثناء الذي كنت تفكر فيه عندما كتبت كتلة catch.

لكنها قد لا تكون كذلك. قد يتم انتهاك بعض الافتراضات الأخرى ، أو ربما تكون قد أدخلت خطأً يسبب استثناءً.  إليك مثال يحاول الاستمرار في استدعاء التوجيه الفوري حتى يحصل على إجابة صحيحة:

```text
for (;;) {
  try {
    let dir = promtDirection("Where?"); // ← typo!
    console.log("You chose ", dir);
    break;
  } catch (e) {
    console.log("Not a valid direction. Try again.");
  }
}
```

البناء for \(؛؛\) هو طريقة لإنشاء حلقة لا تنتهي من تلقاء نفسها. نخرج من الحلقة فقط عندما يتم إعطاء اتجاه صحيح. لكننا أخطأنا في الهجاء promptDirection مما سينتج عنه  “undefined variable” . لأن كتلة catch تتجاهل تمامًا قيمة الاستثناء الخاصة بها \(e\) ، بافتراض أنها تعرف ما هي المشكلة ،يتعامل بشكل خاطئ مع خطأ الربط على أنه يشير إلى إدخال غير صحيح. لا يتسبب هذا في حدوث حلقة لا نهائية فحسب ، بل إنه "يدفن" رسالة الخطأ المفيدة حول الربط الذي يحتوي على أخطاء إملائية.

كقاعدة عامة ، لا تقم بإجراء استثناءات شاملة إلا إذا كان الغرض منها "توجيهها" في مكان ما - على سبيل المثال ، عبر الشبكة لإخبار نظام آخر بتعطل برنامجنا. وحتى ذلك الحين ، فكر جيدًا في كيفية إخفاء المعلومات.

لذلك نريد أن نلتقط نوعًا معينًا من الاستثناءات. يمكننا القيام بذلك عن طريق التحقق في كتلة catch ما إذا كان الاستثناء الذي حصلنا عليه هو الاستثناء الذي نهتم به وإعادة طرحه بطريقة أخرى. لكن كيف نتعرف على الاستثناء؟

يمكننا مقارنة خاصية massage برسالة الخطأ التي نتوقعها. لكن هذه طريقة مهزوزة لكتابة التعليمات البرمجية - سنستخدم المعلومات المخصصة للاستهلاك البشري \(the massage \) لاتخاذ قرار برمجي . بمجرد قيام شخص ما بتغيير \(translates\) الرسالة ، سيتوقف الرمز عن العمل

بدلاً من ذلك ، دعنا نحدد نوعًا جديدًا من الخطأ ونستخدم  `instanceof` لتعريفه.

```text
class InputError extends Error {}

function promptDirection(question) {
  let result = prompt(question);
  if (result.toLowerCase() == "left") return "L";
  if (result.toLowerCase() == "right") return "R";
  throw new InputError("Invalid direction: " + result);
}
```

تمدد فئة الخطأ الجديدة Error. لا يحدد المُنشئ الخاص به ، مما يعني أنه يرث مُنشئ الخطأ ، والذي يتوقع massage سلسلة كوسيطة. في الواقع ، لا يحدد أي شيء على الإطلاق - الفصل فارغ. تتصرف كائنات InputError مثل كائنات Error ، باستثناء أن لها فئة مختلفة يمكننا من خلالها التعرف عليها.

الآن يمكن للحلقة التقاط هذه بعناية أكبر.

```text
for (;;) {
  try {
    let dir = promptDirection("Where?");
    console.log("You chose ", dir);
    break;
  } catch (e) {
    if (e instanceof InputError) {
      console.log("Not a valid direction. Try again.");
    } else {
      throw e;
    }
  }
}
```

سيؤدي هذا إلى التقاط حالات InputError فقط والسماح للاستثناءات غير ذات الصلة بالمرور. إذا أعدت تقديم الخطأ المطبعي ، فسيتم الإبلاغ عن خطأ الربط غير المحدد بشكل صحيح.

### Assertions

التأكيدات هي عمليات تحقق داخل برنامج تتحقق من أن شيئًا ما على ما هو مفترض أن يكون عليه. يتم استخدامها ليس للتعامل مع المواقف التي يمكن أن تحدث في التشغيل العادي ولكن للعثور على أخطاء المبرمج.

على سبيل المثال ، إذا تم وصف العنصر firstElement كدالة لا يجب استدعاؤها مطلقًا في المصفوفات الفارغة ، فقد نكتبها على النحو التالي:

```text
1
function firstElement(array) {
2
  if (array.length == 0) {
3
    throw new Error("firstElement called with []");
4
  }
5
  return array[0];
6
}

```

الآن ، بدلاً من إرجاع غير محدد بصمت \(والذي تحصل عليه عند قراءة خاصية مصفوفة غير موجودة\) ، سيؤدي ذلك إلى تفجير برنامجك بصوت عالٍ بمجرد إساءة استخدامه. هذا يجعل من غير المرجح أن تمر مثل هذه الأخطاء دون أن يلاحظها أحد ويسهل العثور على أسبابها عند حدوثها.

لا أوصي بمحاولة كتابة تأكيدات لكل نوع ممكن من المدخلات السيئة. سيكون هذا كثيرًا من العمل وسيؤدي إلى رمز مزعج للغاية. ستحتاج إلى الاحتفاظ بها للأخطاء التي يسهل ارتكابها \(أو التي تجد نفسك ترتكبها\).

### Summary











