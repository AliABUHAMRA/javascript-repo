# The Secret Life of Objects

> يتم التعرف على نوع البيانات المجردة من خلال كتابة نوع خاص من البرامج \[...\] الذي يحدد النوع من حيث العمليات التي يمكن إجراؤها عليه

![](.gitbook/assets/image%20%2815%29.png)

في  [فصل 4](http://eloquentjs.ir/04_data.html) ، قدمنا ​​الكائنات في JavaScript. في ثقافة البرمجة ، هناك مفهوم يسمى البرمجة الشيئية ؛ مجموعة من التقنيات التي يتم فيها استخدام الكائنات \(والمفاهيم ذات الصلة\) كمبدأ مركزي لتنظيم البرنامج.

على الرغم من عدم اتفاق أحد على تعريفها الدقيق ، إلا أن البرمجة الموجهة للكائنات قد شكلت تصميم العديد من لغات البرمجة ، مثل JavaScript نفسها. يشرح هذا الفصل كيفية تنفيذ هذه الفكرة في JavaScript.

### Encapsulation صنع كبسولة

الفكرة الأساسية في البرمجة الشيئية هي تقسيم البرامج إلى أجزاء أصغر وجعل كل قطعة مسؤولة عن إدارة حالتها الخاصة.

بهذه الطريقة ، يمكن تخزين بعض المعلومات حول كيفية عمل جزء من البرنامج محليًا 'local ' لنفس الجزء .شخص ما يعمل على أجزاء أخرى من البرنامج لا يحتاج إلى تذكر هذه المعلومات أو حتى أن يكون على علم بها على الإطلاق. إذا تغيرت هذه التفاصيل المحلية ، فسنحتاج فقط إلى تحديث الكود الموجود حولها مباشرة.

تستخدم أجزاء مختلفة من هذه البرامج واجهات'interface' للتواصل مع بعضها البعض؛ مجموعة محدودة من الوظائف أو المتغيرات التي تنشئ إمكانيات مفيدة على مستوى أعلى من التجريد وتخفي التفاصيل الدقيقة لتنفيذها عن المستخدم.

تم تصميم أجزاء من هذه البرامج حسب الكائنات. تحتوي واجهتهم على مجموعة محددة من الأساليب والخصائص. تسمى مجموعة الخصائص التي تشكل جزءًا من الواجهة عامة 'public' ، وتلك الخصائص التي لا يجب أن يكون للكود الخارجي حق الوصول إليها تسمى الخصائص الخاصة 'private'.

توفر العديد من لغات البرمجة طريقة للتمييز بين الخصائص الخاصة والعامة ومنع التعليمات البرمجية الخارجية من الوصول إلى الخصائص الخاصة. مرة أخرى ، لا يعمل JavaScript بهذه الطريقة عن طريق اختيار الطريقة الدنيا - على الأقل حتى الآن. بالطبع ، يجري العمل على إضافة هذه الميزة إلى اللغة.

على الرغم من أن اللغة نفسها لا تدعم هذا التمييز داخليًا ، إلا أن مبرمجي JavaScript يستخدمون هذا المفهوم بنجاح. عادةً ما يستخدمون أوصاف البرامج أو الوثائق لتحديد العلاقات المتاحة. ومن الطرق الشائعة أيضًا لتحديد الخصائص الخاصة استخدام حرف الواصلة \(\_\) في بداية هذه الخصائص.

يعد إنشاء واجهة منفصلة للعمل مع الكائنات وفصلها عن التنفيذ فكرة رائعة. وهذا ما يسمى عادة بالتغليف أو الإخفاء.

### Methods طرق <a id="obj_methods"></a>

الأساليب ليست أكثر من خصائص تحتوي على قيم دالة. هذه طريقة بسيطة:

```text
let rabbit = {};
rabbit.speak = function(line) {
  console.log(`The rabbit says '${line}'`);
};

rabbit.speak("I'm alive.");
// → The rabbit says 'I'm alive.'
```

تعمل الطرق عادةً على الكائن الذي يتم استدعاؤها عليه. عندما يتم استدعاء دالة كطريقة اي ك "method" - يتم البحث عنها كخاصية ويتم استدعاؤها على الفور مثل object.method \(\) - يشير متغير يسمى '**this**'  تلقائيًا إلى الكائن الذي يتم استدعاؤه.

```text
function speak(line) {
  console.log(`The ${this.type} rabbit says '${line}'`);
}
let whiteRabbit = {type: "white", speak};
let hungryRabbit = {type: "hungry", speak};

whiteRabbit.speak("Oh my ears and whiskers, " +
                  "how late it's getting!");
// → The white rabbit says 'Oh my ears and whiskers, how
//   late it's getting!'
hungryRabbit.speak("I could use a carrot right now.");
// → The hungry rabbit says 'I could use a carrot right now.'
```

يمكنك اعتبار this كمعامل إضافي يتم تمريره بطريقة مختلفة. إذا كنت تريد إرسالها بشكل عام ، فيمكنك استخدام طريقة استدعاء اي "**call**" الوظيفة,تأخذ هذه الطريقة قيمة **this** باعتبارها الوسيطة الأولى وتفسر الحجج الأخرى كمعلمات عاديه.

```text
speak.call(hungryRabbit, "Burp!");
// → The hungry rabbit says 'Burp!'
```

نظرًا لأن كل دالة لها هذا الارتباط الخاص بها ، والتي تعتمد قيمتها على طريقة تسميتها ، لا يمكنك الرجوع إلى نطاق الالتفاف this في دالة عادية محددة بالكلمة الأساسية للوظيفة.

تعمل دوال الأسهم بشكل مختلف - لا تقصر هذه الوظائف على أي مكان ، لكن يمكنها رؤية هذا المتغير في محيطها. وبالتالي ، باستخدام رمز مثل المثال التالي ، يمكن الإشارة إلى هذا من داخل دالة محلية:

```text
function normalize() {
  console.log(this.coords.map(n => n / this.length));
}
normalize.call({coords: [0, 2, 3], length: 5});
// → [0, 0.4, 0.6]
```

إذا كنت قد كتبت الوسيطة لوظيفة الخريطة باستخدام الكلمة الأساسية للوظيفة ، فلن يعمل الرمز أعلاه.

### Prototypes <a id="prototypes"></a>

Watch closely.

```text
let empty = {};
console.log(empty.toString);
// → function toString(){…}
console.log(empty.toString());
// → [object Object]
```

لقد استخرجت خاصية من كائن فارغ. سحر!

بالطبع ، هذا ليس هو الحال بالفعل. النقطة المهمة هي أنني لم أشرح بعد بعض المعلومات حول كيفية عمل الكائنات في JavaScript. بالإضافة إلى خصائصها prototype ، تمتلك معظم الكائنات خاصية تسمى النموذج الأولي. النموذج الأولي هو كائن آخر يستخدم كمصدر بديل للخصائص.عندما يتلقى كائن طلبًا لخاصية ولا يحتوي على هذه الخاصية ، يتم إجراء بحث على النموذج الأولي الخاص به ، ثم يتم البحث عن النموذج الأولي الذي ينتمي إلى النموذج الأولي الخاص به ، وهكذا.

إذن ما هو النموذج الأولي لهذا الكائن الفارغ؟ نعم ، إنه النموذج الأولي للسلف العظيم للكائن الذي يقف وراء كل الأشياء تقريبًا:  `Object.prototype`.

```text
console.log(Object.getPrototypeOf({}) ==
            Object.prototype);
// → true
console.log(Object.getPrototypeOf(Object.prototype));
// → null
```

كما قد تتخيل ، يتم استخدام object.getPrototypeOf للحصول على النموذج الأولي لكائن.



تشكل العلاقات بين النماذج الأولية في كائنات JavaScript بنية شجرة يكون جذرها Object.prototype يوجد داخل هذا الكائن عدة طرق موجودة في جميع الكائنات ، مثل toString ، والتي تحول الكائن إلى سلسلة.

لا تحتوي العديد من الكائنات على Object.prototype مباشرةً كنموذج أولي لها ، ولكن بدلاً من ذلك تحتوي على كائن آخر يوفر مجموعة مختلفة من الخصائص الافتراضية.الدوال مشتقة من Function.prototype والمصفوفات مشتقة من Array.prototype.

```text
console.log(Object.getPrototypeOf(Math.max) ==
            Function.prototype);
// → true
console.log(Object.getPrototypeOf([]) ==
            Array.prototype);
// → true
```

تحتوي هذه النماذج الأولية نفسها على نموذج أولي ، والذي غالبًا ما يكون هو نفسه Object.prototype. لذا فهم يقدمون بشكل غير مباشر أساليب مثل toString. 

يمكنك استخدام طريقة Object.create لإنشاء كائن بنموذج أولي محدد.

```text
let protoRabbit = {
  speak(line) {
    console.log(`The ${this.type} rabbit says '${line}'`);
  }
};
let killerRabbit = Object.create(protoRabbit);
killerRabbit.type = "killer";
killerRabbit.speak("SKREEEE!");
// → The killer rabbit says 'SKREEEE!'
```

خاصية مشابهة للتحدث \(line\) في تعريف الكائن هي الشكل المختصر لتعريف طريقة. هذا يحدد خاصية تسمى speak ويعطيها وظيفة كقيمة.

يستخدم "ProtoRabbit" كحاوية للخصائص المشتركة لجميع الأرانب. كائن أرنب منفصل ، مثل killerRabbit ، له خصائص فريدة خاصة به فقط - وفي هذا المثال إلى الأنواع الخاصة به - وله أيضًا خصائص مشتركة يأخذها من نموذجه الأولي.

### Classes <a id="classes"></a>

يمكن تفسير نظام النموذج الأولي لجافا سكريبت على أنه مفهوم غير رسمي نسبيًا لمفهوم الفئات في البرمجة الموجهة للكائنات. تحدد الفئة طبيعة الكائن - لديها عدد من الأساليب والخصائص. للكائنات التي تم إنشاؤها من الطبقات, يسمى هذا الكائن مثيلاً \(instance\).

النماذج "Prototypes" مفيدة في تحديد الخصائص التي تشترك فيها جميع مثيلات الفئة بنفس القيمة ، مثل الطرق'methods'. الخصائص التي تختلف في كل حالة, مثل خاصية type في مثال الأرنب ، يجب تخزينها مباشرة في الكائنات نفسها.

حتى تتمكن من إنشاء مثيل لفئة معينة ، يجب عليك إنشاء كائن مأخوذ من نموذج أولي حقيقي. يجب عليك أيضًا التأكد من أن هذا الكائن يحتوي على الخصائص التي من المفترض أن تمتلكها مثيلات الفئة بالفعل. هذا ما تفعله دالة المُنشئ.

```text
function makeRabbit(type) {
  let rabbit = Object.create(protoRabbit);
  rabbit.type = type;
  return rabbit;
}
```

يوفر JavaScript طريقة لتسهيل تحديد هذه الوظائف. إذا قمت بوضع وظيفة كلمة رئيسية new في بداية المكالمة ، فستعمل هذه الوظيفة كوظيفة مُنشئconstructor. هذا يعني أنه يتم إنشاء كائن بالنموذج الأولي الصحيح تلقائيًا, يرتبط this  داخل الوظيفة ويعاد في نهاية الوظيفة.

يتم العثور على كائن النموذج الأولي المستخدم عند إنشاء الكائنات عن طريق أخذ خاصية النموذج prototype الأولي لوظيفة المُنشئ.

```text
function Rabbit(type) {
  this.type = type;
}
Rabbit.prototype.speak = function(line) {
  console.log(`The ${this.type} rabbit says '${line}'`);
};

let weirdRabbit = new Rabbit("weird");
```

يأخذ المنشئون"Constructors" \(جميع الوظائف تقريبًا\) تلقائيًا خاصية تسمى النموذج الأولي, هذه الخاصية بشكل افتراضي, ، يحمل كائنًا فارغًا مأخوذ من Object.prototype نفسه. يمكنك تغيير هذه الخاصية واستبدالها بكائن آخر إذا أردت. أو يمكنك إضافة خصائص إلى الكائن الفارغ الحالي ، كما في المثال.

من المعتاد أن تبدأ الأسماء الكبيرة بأحرف كبيرة بحيث يمكن تمييزها بسهولة عن الوظائف العادية.

من المهم أن نفهم الفرق بين كيفية ارتباط النموذج الأولي بالمُنشئ \(من خلال خاصية النموذج الأولي\) وكيف يمكن أن يكون للكائنات نموذج أولي \(يمكن الحصول عليه بواسطة Object.getPrototypeOf\). النموذج الأولي الفعلي للمُنشئ هو في الواقع Function.prototype ، لأن التركيبات هي أنواع دالة. تحافظ خاصية النموذج الأولي للمُنشئ على النموذج الأولي الذي تُصنع منه عينات الكائن.

```text
console.log(Object.getPrototypeOf(Rabbit) ==
            Function.prototype);
// → true
console.log(Object.getPrototypeOf(weirdRabbit) ==
            Rabbit.prototype);
// → true
```

### Class notation

وبالتالي فإن مفهوم فئات JavaScript هي نفس وظائف المُنشئ مع خاصية النموذج الأولي. إنهم يعملون بنفس الطريقة ، وحتى عام 2015 ، كانت هذه الطريقة هي الطريقة الوحيدة لتنفيذها. في هذه الأيام ، لدينا طريقة أفضل لتطبيق الفصول الدراسية.

```text
class Rabbit {
  constructor(type) {
    this.type = type;
  }
  speak(line) {
    console.log(`The ${this.type} rabbit says '${line}'`);
  }
}

let killerRabbit = new Rabbit("killer");
let blackRabbit = new Rabbit("black");
```

تؤدي الكلمة الأساسية للفصل إلى إعلان فئة يسمح لنا بتعريف المُنشئ ومجموعة الطرق معًا. يمكن وضع أي عدد من الطرق المطلوبة بين أقواس تعريف الفئة. يتم تفسير الطريقة المكتوبة كمنشئ ' `constructor` 'بطريقة خاصة. توفر هذه الطريقة دالة منشئ حقيقية تسمى Rabbit. يتم حزم طرق أخرى داخل النموذج الأولي للشركة المصنعة. لذلك ، فإن تعريف الفئة أعلاه يعادل تعريف المُنشئ في القسم السابق. انها فقط تبدو أجمل.

في تعريف الصنف ، فقط الطرق - الخصائص التي تحتوي على وظائف - يمكن تعريفها لإضافتها إلى النموذج الأولي 'prototype'. يمكن أن يكون هذا القيد مشكلة عندما تريد حفظ نوع غير وظيفي. لمثل هذه الخصائص ، لا يزال بإمكانك تعديل النموذج الأولي'prototype' مباشرة بعد تعريف الفئة.

يمكن استخدام class تمامًا مثل function كعبارة وأمر. إذا تم استخدامه كتعبير ، فإنه لا يعرّف متغيرًا وينتج المُنشئ كقيمة. يمكنك إزالة اسم الفئة من التعريف في هذه الطريقة.

```text
let object = new class { getWord() { return "hello"; } };
console.log(object.getWord());
// → hello
```

### Overriding derived properties إعادة كتابة وتغيير الخصائص المشتقة

عند إضافة خاصية إلى كائن ، ستتم إضافة الخاصية إلى الكائن نفسه ، بغض النظر عما إذا كان في النموذج الأولي أم لا. إذا كانت هناك خاصية تحمل الاسم نفسه في النموذج الأولي ، فستكون الخاصية في النموذج الأولي غير فعالة وسيتم إخفاء الكائن خلف الخاصية نفسها.

```text
Rabbit.prototype.teeth = "small";
console.log(killerRabbit.teeth);
// → small
killerRabbit.teeth = "long, sharp, and bloody";
console.log(killerRabbit.teeth);
// → long, sharp, and bloody
console.log(blackRabbit.teeth);
// → small
console.log(Rabbit.prototype.teeth);
// → small
```

يوضح الرسم البياني التالي الشروط التي تحدث بعد تنفيذ الكود أعلاه. يتم وضع نماذج Rabbit وObject خلف killerRabbit ، مثل الخلفية ، والتي تتم الإشارة إليها في غياب الخصائص في الكائن نفسه.

![](.gitbook/assets/image%20%283%29.png)

يمكن أن يكون تعديل الخصائص وإعادة كتابتها في النموذج الأولي مفيدًا. كما هو موضح في مثال rabbit teeth ، يمكن استخدامه لتحديد خصائص الاستثناء في مثال كائنات من فئة أكثر عمومية ، مما يسمح للكائنات العادية بتلقي القيمة القياسية من نموذجها الأولي.

تُستخدم التجاوزات أيضًا لتحديد إصدار مختلف من طريقة toString للوظيفة 'function' القياسية ونماذج 'Array'. طريقة تختلف عن الكائن الافتراضي toString الأساسي.

```text
console.log(Array.prototype.toString ==
            Object.prototype.toString);
// → false
console.log([1, 2].toString());
// → 1,2
```

استدعاء toString في مصفوفة هو نتيجة استدعاء .join \("،"\). سيكون عليه - الذي يضعه بين قيم مصفوفة الفاصلة. يؤدي الاستدعاء المباشر لـ Object.prototype.toString مع مصفوفة إلى إنشاء سلسلة مختلفة. لا تعرف هذه الوظيفة شيئًا عن المصفوفات ، لذا فهي ببساطة تطبع كلمة object واسم نوع البيانات بين زوج من الأقواس.

```text
console.log(Object.prototype.toString.call([1, 2]));
// → [object Array]
```

### Maps هيكل البيانات

تعرفنا على map الكلمات في   [previous chapter](https://eloquentjavascript.net/05_higher_order.html#map). تم استخدامه لتغيير هيكل البيانات من خلال تطبيق وظيفة على عناصرها. قد يكون الأمر محيرًا بعض الشيء ، ولكن في البرمجة ، يتم استخدام نفس المصطلح لموضوع مختلف نسبيًا.

الخريطة هي بنية بيانات تربط القيم \(المفاتيح\) بقيم أخرى. على سبيل المثال ، قد ترغب في تعيين الأسماء إلى الأعمار. يمكن استخدام كائن لهذا الغرض.

```text
let ages = {
  Boris: 39,
  Liang: 22,
  Júlia: 62
};

console.log(`Júlia is ${ages["Júlia"]}`);
// → Júlia is 62
console.log("Is Jack's age known?", "Jack" in ages);
// → Is Jack's age known? false
console.log("Is toString's age known?", "toString" in ages);
// → Is toString's age known? true
```

في هذا المثال ، يتم تعيين خصائص الكائن على قدم المساواة مع أسماء الأشخاص ويتم تعيين قيمتها على قدم المساواة مع عمر الأشخاص. لكن بالطبع ، ليس لدينا أي شخص اسمه toString من بين الأسماء. نعم ، نظرًا لأن الكائنات البسيطة مشتقة من Object.prototype ، يبدو أن هذه الخاصية موجودة هناك.

لذلك ، هناك مخاطر في استخدام الكائنات البسيطة بدلاً من الخرائط. هناك طرق مختلفة للهروب من هذه المشكلة.  أولاً ، يمكن إنشاء كائن بدون نموذج أولي. إذا قمت بإرسال قيمة null إلى أسلوب Object.create, لم يعد كائن الإخراج مبنيًا على Object.prototype ويمكن استخدامه بأمان كخريطة'map'.

```text
console.log("toString" in Object.create(null));
// → false
```

يجب أن يكون اسم خاصية الكائن من نوع سلسلة. إذا كنت بحاجة إلى تعيين لا يمكن تحويل مفاتيحه بسهولة إلى سلاسل \(مثل استخدام الكائنات كمفاتيح\) ، فلا يمكنك استخدام كائن لتنفيذ هذا التعيين.

لحسن الحظ ، توفر JavaScript فئة تسمى Map ، تمت كتابتها لهذا الغرض فقط. تستخدم هذه الفئة لتخزين الخرائط بأي نوع مفتاح.

```text
let ages = new Map();
ages.set("Boris", 39);
ages.set("Liang", 22);
ages.set("Júlia", 62);

console.log(`Júlia is ${ages.get("Júlia")}`);
// → Júlia is 62
console.log("Is Jack's age known?", ages.has("Jack"));
// → Is Jack's age known? false
console.log(ages.has("toString"));
// → false
```

طرق get و set و has هي أجزاء من واجهة كائن الخريطة. إن كتابة بنية بيانات يمكن استخدامها لتحديث مجموعة كبيرة من القيم والبحث عنها بسرعة ليست مهمة سهلة ، ولكن لا داعي للقلق بشأنها. قام شخص ما بهذا من أجلنا من قبل ويمكننا الانتقال إلى هذه الواجهة البسيطة واستخدام عملهم.

إذا كان لديك كائن بسيط وتحتاج لسبب ما إلى استخدامه كهيكل خريطة ، فيجب أن تعلم أن Object.keys ترجع فقط مفاتيح كائن ، وليس مفاتيح نموذجها الأولي. كبديل للمعامل in ، يمكنك استخدام طريقة hasOwnProperty ، والتي لا تعتبر النموذج الأولي للكائن.

```text
console.log({x: 1}.hasOwnProperty("x"));
// → true
console.log({x: 1}.hasOwnProperty("toString"));
// → false
```

### Polymorphism تعدد

عندما تستدعي وظيفة String \(التي تحول قيمة إلى سلسلة\) على كائن ، يتم استدعاء طريقة toString لهذا الكائن وتحاول إنشاء سلاسل ذات معنى من الكائن. لقد ذكرت سابقًا أن بعض النماذج الأولية القياسية تحدد نسختها الخاصة من toString بحيث يمكنها إنشاء معلومات أكثر فائدة من "\[object Object\]". يمكنك أن تفعل الشيء نفسه.

```text
Rabbit.prototype.toString = function() {
  return `a ${this.type} rabbit`;
};

console.log(String(blackRabbit));
// → a black rabbit
```

هذا مثال بسيط لفكرة قوية. عندما تتم كتابة التعليمات البرمجية للعمل مع كائنات لها واجهة محددة - في هذا المثال, طريقة toString - باستخدام هذا الرمز ، يمكن تضمين أي كائن آخر يدعم هذه الواجهة واستخدامه بشكل صحيح.

هذه التقنية تسمى تعدد الأشكال. يمكن أن يعمل الرمز متعدد الأشكال مع قيم الأشكال المختلفة طالما أن هذه الأشكال تدعم الواجهة التي تتوقعها .

لقد ذكرت في  [Chapter 4](https://eloquentjavascript.net/04_data.html#for_of_loop) أن حلقة for / of يمكن أن تدور حول عدة أنواع من هياكل البيانات. هذه حالة أخرى من تعدد الأشكال - مثل هذه الحلقات تتوقع أن تعرض بنية البيانات واجهة معينة ، وهو ما تفعله المصفوفات والسلاسل. ويمكننا أيضًا إضافة هذه الواجهة إلى العناصر الخاصة بك! لكن قبل أن نتمكن من القيام بذلك ، نحتاج إلى معرفة الرموز.

### Symbols

يمكن استخدام نفس اسم الخاصية للعديد من المهام لعدة واجهات مختلفة. على سبيل المثال ، يمكنني تحديد واجهة يحول فيها أسلوب toString افتراضيًا كائنًا إلى سلسلة. لكن لا يمكن أن يتطابق الكائن مع كل من الواجهة التي حددناها وتنفيذ معيار toString.

هذه ليست فكرة جيدة وليست مشكلة شائعة. معظم مبرمجي JavaScript لا يفكرون في ذلك. لكن مصممي اللغة ، نفس الأشخاص الذين تتمثل مهمتهم في التفكير في هذه القضايا ، قدموا لنا حلاً على أي حال.

لم أستخدم العبارة بالضبط قبل الادعاء بأن أسماء الخصائص عبارة عن سلسلة. نعم ، عادة ما تكون سلاسل ، لكنها يمكن أن تكون رمزية' _symbol_ ' أيضًا. الرموز هي القيم التي تم إنشاؤها باستخدام وظيفة الرمز. على عكس السلاسل ، تعتبر الرموز المنشأة حديثًا فريدة - لا يمكن إنشاء نفس الرمز مرتين.

```text
let sym = Symbol("name");
console.log(sym == Symbol("name"));
// → false
Rabbit.prototype[sym] = 55;
console.log(blackRabbit[sym]);
// → 55
```

يتم استخدام السلسلة التي ترسلها إلى وظيفة Symbol عند تحويل الرمز إلى سلسلة ويمكن أن تسهل التعرف عليها ، على سبيل المثال ، عند عرضها على وحدة التحكم. ليس لها معنى آخر - يمكن تعريف عدة رموز باسم واحد.

تفرد واستخدام خاصية كاسم يجعل استخدام الرموز خيارًا جيدًا لتحديد العلاقات التي يمكن تعريفها بسهولة إلى جانب الخصائص الأخرى بغض النظر عن اسمها.

```text
const toStringSymbol = Symbol("toString");
Array.prototype[toStringSymbol] = function() {
  return `${this.length} cm of blue yarn`;
};

console.log([1, 2].toString());
// → 1,2
console.log([1, 2][toStringSymbol]());
// → 2 cm of blue yarn
```

عند تحديد كائن أو فئة ، يمكن استخدام الخصائص التي تكون أسماؤها رمزية بوضع أقواس حول أسمائها. يؤدي هذا إلى تقييم اسم الخاصية ، مثل استخدام الأقواس للوصول إلى الخصائص. من خلال القيام بذلك ، فإننا نشير إلى المتغير الذي يحمل رمزًا.

```text
let stringObject = {
  [toStringSymbol]() { return "a jute rope"; }
};
console.log(stringObject[toStringSymbol]());
// → a jute rope
```

### The iterator interface واجهة مكرر

من المتوقع أن يكون الكائن المعطى لحلقة for / of قابلاً للتكرار. أي أنه يحتوي على طريقة تسمى Symbol.iterator \(قيمة من نوع الرمز تحددها اللغة نفسها ويتم تخزينها كخاصية لوظيفة Symbol\).

عندما يتم استدعاء هذه الطريقة ، سيكون ناتجها كائنًا يوفر الواجهة الثانية ، واجهة المكرر ، الواجهة التي تنفذ عملية التكرار. هذا المكرر لديه طريقة تسمى next والتي تُرجع النتيجة التالية. يجب أن تكون هذه النتيجة كائنًا بخاصية تسمى value التي تحتوي على القيمة التالية ، إن وجدت, يجعله متاحًا وله خاصية أخرى تسمى done ، وفي حالة عدم وجود نتائج أخرى ، التي يجب أن تكون true عندما لا توجد نتائج أخرى وتكون false بخلاف ذلك.

لاحظ أن أسماء الخصائص next  وvalue  وdone هي من نوع السلسلة البسيط ، وليس من نوع الرمز. إنه مجرد Symbol.iterator ، وهو في الواقع رمز ومن المحتمل أن يضاف إلى العديد من الكائنات المختلفة.

**يمكننا استخدام هذه الواجهة مباشرة.**

```text
let okIterator = "OK"[Symbol.iterator]();
console.log(okIterator.next());
// → {value: "O", done: false}
console.log(okIterator.next());
// → {value: "K", done: false}
console.log(okIterator.next());
// → {value: undefined, done: true}
```

دعنا ننفذ بنية قابلة للتكرار. في المثال التالي ، سننشئ فئة مصفوفة تعمل كمصفوفة ثنائية الأبعاد:

```text
class Matrix {
  constructor(width, height, element = (x, y) => undefined) {
    this.width = width;
    this.height = height;
    this.content = [];

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        this.content[y * width + x] = element(x, y);
      }
    }
  }

  get(x, y) {
    return this.content[y * this.width + x];
  }
  set(x, y, value) {
    this.content[y * this.width + x] = value;
  }
}
```

تخزن الطبقة العليا محتواها في مصفوفة بعدد من عناصر   _width_ × _height._ يتم تخزين العناصر صفًا تلو الآخر ، على سبيل المثال, العنصر الثالث في الصف الخامس \(باستخدام الفهرسة الصفرية\) مخزن في الموضع       4 × _width_ + 2.

تأخذ وظيفة المُنشئ طولًا وعرضًا ووظيفة اختيارية للمحتوى ، والتي تُستخدم للتهيئة. تم تعريف أساليب get وset لتحديث العناصر واستلامها في المصفوفة.

عند اجتياز مصفوفة ، من المهم عادةً معرفة موضع العناصر بقدر ما هي العناصر نفسها ، لذا فإن المكررات لدينا هي كائنات لها خصائص x , z  و value

```text
class MatrixIterator {
  constructor(matrix) {
    this.x = 0;
    this.y = 0;
    this.matrix = matrix;
  }

  next() {
    if (this.y == this.matrix.height) return {done: true};

    let value = {x: this.x,
                 y: this.y,
                 value: this.matrix.get(this.x, this.y)};
    this.x++;
    if (this.x == this.matrix.width) {
      this.x = 0;
      this.y++;
    }
    return {value, done: false};
  }
}
```

يتم تسجيل إحصاء تقدم التكرار على طول مصفوفة بواسطة الخاصيتين x و y. تبدأ الطريقة next بالتحقق مما إذا كنا قد وصلنا إلى نهاية المصفوفة. إذا لم يتم الانتهاء منه ، فإنه يقوم أولاً بإنشاء كائن يحمل القيمة الحالية ، ثم يقوم بتحديث موضعه وينتقل إلى الصف التالي إذا لزم الأمر.

دعونا نكرر فئة matrix. في هذا الكتاب ، أحيانًا بعد تحديد الفئات ، سأقوم بمعالجة النموذج الأولي لإضافة طرق إليها ، لذلك ستبقى الشفرة منفصلة وصغيرة ولن تعتمد على أجزاء أخرى. في برنامج نموذجي ، حيث لا نحتاج إلى تقسيم الكود إلى أجزاء أصغر ، يمكنك تحديد هذه الطرق مباشرة داخل جسم الفصل.

```text
Matrix.prototype[Symbol.iterator] = function() {
  return new MatrixIterator(this);
};
```

يمكننا الآن إجراء حلقة على مصفوفة باستخدام for / of.

```text
let matrix = new Matrix(2, 2, (x, y) => `value ${x},${y}`);
for (let {x, y, value} of matrix) {
  console.log(x, y, value);
}
// → 0 0 value 0,0
// → 1 0 value 1,0
// → 0 1 value 0,1
// → 1 1 value 1,1
```

### Getters, setters, and statics

تتكون العلاقات في الغالب من طرق ، ولكن يمكن أن تحتوي أيضًا على خصائص لا تحتوي على قيم دالة. على سبيل المثال ، تحتوي كائنات map على خاصية تسمى size تحتوي على عدد المفاتيح المخزنة فيها.

في مثل هذه الكائنات ، ليس من الضروري حساب وتخزين خاصية مثل size مباشرة في نموذج الكائن نفسه. حتى الخصائص التي يمكن الوصول إليها مباشرة قد تستدعي طريقة سرًا. تسمى هذه الأنواع من الخصائص getter ، والتي يتم تعريفها عن طريق كتابة get في بداية اسم الطريقة في عبارة تعريف كائن أو فئة.

```text
let varyingSize = {
  get size() {
    return Math.floor(Math.random() * 100);
  }
};

console.log(varyingSize.size);
// → 73
console.log(varyingSize.size);
// → 49
```

عندما يطلب شخص ما قيمة خاصية size ، يتم استدعاء الطريقة التي يتم ربطها بها. يمكنك أن تفعل الشيء نفسه لتعيين خاصية تسمى  _setter_ .

```text
class Temperature {
  constructor(celsius) {
    this.celsius = celsius;
  }
  get fahrenheit() {
    return this.celsius * 1.8 + 32;
  }
  set fahrenheit(value) {
    this.celsius = (value - 32) / 1.8;
  }

  static fromFahrenheit(value) {
    return new Temperature((value - 32) / 1.8);
  }
}

let temp = new Temperature(22);
console.log(temp.fahrenheit);
// → 71.6
temp.fahrenheit = 86;
console.log(temp.celsius);
// → 30
```

تتيح لك فئة Temperature في المثال أعلاه كتابة درجة الحرارة بالدرجة المئوية أو الفهرنهايت. لكن داخل الفصل ، يتم تخزين هذه القيمة بالدرجة المئوية فقط ويتم استلامها تلقائيًا بواسطة طرق الاستلام والتمرير    \(setter, getter\) يصبح  `fahrenheit` .

في بعض الأحيان تريد الحصول على بعض الخصائص مباشرة في دالة المُنشئ بدلاً من النموذج الأولي. لن تتمكن هذه الأساليب من الوصول إلى مثيل الفئة ، ولكن يمكن استخدامها كطرق أخرى لتوليد المثيل.

ضمن تعريف الفئة ، يتم تخزين الطرق التي يتم بها كتابة الكلمة الأساسية الثابتة 'static' في البداية على وظيفة المُنشئ. لذلك في فئة Temperature يمكنك استخدام

Temperature.fromFahrenheit\(100\)

 لتوليد درجة الحرارة بالدرجات فهرنهايت.

### Inheritance ميراث

تُعرف بعض المصفوفات بالمصفوفات المتماثلة. إذا قمت بعكس مصفوفة متماثلة حول القطر العلوي-الأيسر-السفلي-الأيمن ، فلا فرق في شكلها.بمعنى آخر ، القيمة في x ، y هي دائمًا نفس القيمة y ، x.

تخيل أننا بحاجة إلى بنية بيانات مثل matrix. لكنه يفرض حقيقة أن المصفوفة متماثلة ولا تزال متماثلة. يمكننا كتابة بنية البيانات هذه من البداية ، لكنها تجعلنا نكرر الكود الذي كتبناه بالفعل مشابهًا.

يتيح لنا نظام النموذج الأولي في JavaScript إنشاء فئة جديدة بناءً على فئة أخرى ولكن عن طريق إعادة تعريف بعض خصائصها. النموذج الأولي للفئة الجديدة مشتق من النموذج الأولي القديم ولكنه يضيف تعريفًا جديدًا لـطريقه set.

في البرمجة الشيئية ، يسمى هذا بالوراثة. ترث الطبقة الجديدة الخصائص والسلوكيات من فئة أخرى.

```text
class SymmetricMatrix extends Matrix {
  constructor(size, element = (x, y) => undefined) {
    super(size, size, (x, y) => {
      if (x < y) return element(y, x);
      else return element(x, y);
    });
  }

  set(x, y, value) {
    super.set(x, y, value);
    if (x != y) {
      super.set(y, x, value);
    }
  }
}

let matrix = new SymmetricMatrix(5, (x, y) => `${x},${y}`);
console.log(matrix.get(2, 3));
// → 3,2
```

استخدام الكلمة extends يشير إلى أن هذه الفئة لا ينبغي أن تعتمد بشكل مباشر على الافتراضي  `Object` النموذج الأولي ولكن في فئة أخرى. هذا ما يسمى  _superclass ._ الفئة المشتقة هي فئة فرعية.

لتهيئة عينة من SymmetricMatrix ، يقوم المُنشئ باستدعاء مُنشئ الطبقة الفائقة من خلاله , الشركة المصنعة, تستدعي دالة المُنشئ صنفها الأصلي \(superclass\) بالكلمة الرئيسية super. هذا ضروري لأنه إذا كان هذا الكائن الجديد سيتصرف \(تقريبًا\) مثل matrix . سوف تحتاج إلى الخصائص التي تمتلكها المصفوفات. لضمان تناظر المصفوفة ، وظيفة المنشئ, تحتوي الطريقة على Element لنقل الإحداثيات إلى القيم السفلية للقطر الأصلي.

ال set  تستخدم مره اخرى super, لكن الهدف هذه المرة ليس استدعاء خالقها 'constructor'  ولكن لاستدعاء طريقه معينه "specific method" من مجموعة طرق الطبقة العليا. نعيد كتابه set ولكننا نريد استخدام السلوك الاصلي. لان this.set يشير الى طريقه المجموعه الجديده new set .لايمكن استخدامه ضمن طرق الفصل  ، يوفر super طريقة لاستدعاء الطرق كما تم تعريفها في الطبقة العليا.

بمساعدة الوراثة ، يمكننا إنشاء أنواع مختلفة من البيانات من أنواع البيانات الحالية مع عمل أقل نسبيًا. بالإضافة إلى التغليف وتعدد الأشكال ، يعتبر الوراثة أحد المفاهيم الأساسية للبرمجة الموجهة للكائنات. بالطبع ، تُعرف السمتان الأوليان عمومًا بالأفكار العظيمة ، ولكن هناك اختلافات في الرأي حول الميراث.

بينما يمكن استخدام التغليف وتعدد الأشكال لفصل الكود وتقليل الفوضى الكلية للبرنامج ، فإن الوراثة تجعل الفئات مترابطة بشكل أساسي وتخلق بطريقة ما المزيد من التشابك او الفوضى . عندما ترث من فصل او فئه.  عادة ما تحتاج إلى معرفة المزيد عن كيفية عملها أكثر من مجرد استخدامها. يجب أن تعرف المزيد عن كيفية عمل هذا الفصل. يمكن أن يكون الوراثة أداة مفيدة ، وأنا أستخدمها بين الحين والآخر في برامجي الخاصة , لكن لا ينبغي أن يكون الخيار الأول الذي تذهب إليه. وقد لا يكون من الجيد البحث عن الفرص التي يمكن من خلالها إنشاء تسلسل هرمي للفئات  \(family trees of classes\).

### The instanceof operator المشغل أو العامل

نحتاج أحيانًا إلى معرفة ما إذا كان الكائن مشتقًا من فئة معينة. لهذا ، توفر JavaScript عامل تشغيل ثنائي يسمى  `instanceof`.

```text
console.log(
  new SymmetricMatrix(2) instanceof SymmetricMatrix);
// → true
console.log(new SymmetricMatrix(2) instanceof Matrix);
// → true
console.log(new Matrix(2, 2) instanceof SymmetricMatrix);
// → false
console.log([1] instanceof Array);
// → true
```

يستكشف هذا المشغل أنواع الورثة,  على سبيل المثال ، SymmetricMatrix هو مثال على Matrix . يمكن أيضًا استخدام هذا المشغل لمنشئي المعايير مثل Array. جميع الكائنات تقريبًا هي أمثلة على object .

### Summary











