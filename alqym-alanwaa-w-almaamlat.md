# القيم، الأنواع و المعاملات



> تحت مستوى الآلة يوجد البرنامج الذي يتحرك ويتوسع ويتقلص بسهولة. تنتشر الإلكترونات وتعيد تجميعها في وئام تام. الأشكال على الشاشة ليست سوى موجات على الماء. المادة الرئيسية أدناه تظل غير مرئية.

![](http://eloquentjs.ir/img/chapter_picture_1.jpg)

داخل عالم الحاسوب، لا يوجد سوى بيانات.يمكنك قراءة البيانات، تعديلها أو انشاء واحدة جديدة، ولكن أي شيء لا ينتمي لهذه الأخيرة فهو غير موجود داخل الحاسوب. كل هذه البيانات مخزنة على شكل سلسلة طويلة من البِتّات، وبالتالي فهي متشابهة في أساسها.

 و البِتّات هي أي نوع من شيئين لهما قيمة، وتكون عادةً إما صفراً أو واحدا. داخل الحاسوب، تأخذ البِتّات أشكالاً كشحنة كهربائية مرتفعة او منخفضة، اشارة قوية او ضعيفة، بقعة لامعة او معتمة على سطح قرص مضغوط CD، أي جزء من معلومات منفصلة يمكن جعله كسلسلة من الأصفار والواحدات، وهكذا تمثل الـ البِتّات.

> البت \(بالإنجليزية: bit\) يتم في الحواسيب تخزين المعلومات ومعالجتها على شكل بتات \(bits\) وبذلك يكون نظريا البت أصغر وحدة حاملة أو ناقلة لمعلومة أو لمعنى معين. -- ويكيبديا

على سبيل المثال، فكر بطريقة اظهار الرقم 13 على شكل بِتّات. الطريقة تعمل بنفس طريبة كتابة الارقام العشرية، ولكن بدلاً من وجود 10 خانات مختلفة \(0, 1, 2, 3 .. 9\)، يوجد خانتان مختلفتان فقط،، ووزن كل واحدة يزداد بمعامل الرقم 2 من اليمين الى اليسار. وهنا الـ البِتّات التي تشكل الرقم 13، مع اوزان الخانات تحتها:

0 0 0 0 1 1 0 1 128 64 32 16 8 4 2 1

اذاً، ذلك هو التمثيل الثنائي 00001101 للرقم 13.



## Values

تخيل بحر من القطع. محيط منهم. يحتوي الكمبيوتر الحديث النموذجي على أكثر من 30 مليار bit في الذاكرة المتطايرة \(الذاكرة الرئيسية\). الذكريات غير المتطايرة \(مثل الأقراص الصلبة أو الأقراص الصلبة وما شابه\) تكون أكبر وأكبر بعدة مرات.

 لتكون قادرًا على العمل مع مثل هذه الكميات من bits دون أن تضيع , يجب علينا فصلهم إلى أجزاء تمثل أجزاء من المعلومات. في JavaScript البيئة ، هولاء القطع تدعى values. على الرغم من أن جميع القيم مصنوعة من bits ، ولكنهم يلعبون ادوارا مختلفه, كل قيمة لها نوع يحدد دورها,بعض الأحرف عبارة عن text، وبعض values هي function ، وما إلى ذلك.

لإنشاء value، عليك فقط استدعاء اسمها. هذا مناسب , أنت لا يتعين عليك جمع مواد البناء لقيمك ال values أو دفع ثمنها, فقط عليك استدعاء واحد وسوف تحصل عليه, فقط اتصل وهذا كل شيء. قمت بإنشائه. بالطبع ، لا يأتون من لا شيء ,  يجب تخزين valuesفي مكان ما ، وإذا كنت تريد استخدام الكثير منها في وقت واحد ، فقد تنفد الذاكرة. لحسن الحظ تحدث هذه المشكلة فقط عندما تحتاج اليهم جميعا في نفس الوقت \(تنبيه : في نفس الوقت \). بمجرد ان لاتستخدم البعض, سيتم إخراج هذه value من الحلقة وسيتم استخدام bit  المقابلة لها لإنشاء قيم جديدة.

This chapter introduces the atomic\(elements of JavaScript programs\), that is, the simple \(value types\) and the \(operators\) that can act on such \(values\).

##  Numbers

القيم المتعلقة بنوع \(Numbera\)هي بشكل طبيعي قيم عددية. في برنامج JavaScript ، تتم كتابة هذه القيم على النحو التالي:

 `13`

 ``يؤدي استخدام هذه value في البرنامج إلى إنشاء نمط bit المقابل للرقم 13 داخل ذاكرة الكمبيوتر.

 يستخدم JavaScript عددًا ثابتًا من البتات \(64 bit\) لتخزين رقم. باستخدام هذه الـ 64 bit، يمكن إجراء العديد من التركيبات ، وبالطبع يكون عدد الأرقام المختلفة التي يمكن عرضها محدودًا.بالنسبة للأرقام العشرية N ، يمكن عرض رقم 10N \(عشرة أس N\). وبالمثل ، بالنسبة لـ 64 رقمًا ثنائيًا ، يمكن تمثيل 264 رقمًا مختلفًا ، أي حوالي 18 خُمسًا \(18 و 18 إلى صفر أمامها\) ، وهو رقم كبير جدًا.

كانت ذاكرة الكمبيوتر أصغر كثيرًا ، وكان الناس يميلون إلى استخدام المجموعات من 8 أو 16 bit لتمثيل أعدادهم. . كان من السهل تجاوزها عن طريق الخطأ مثل هذه الأعداد الصغيرة - لتنتهي برقم لا يتناسب مع المعطى عدد **bits** . 

اليوم ، حتى أجهزة الكمبيوتر التي تناسب جيبك بها ذاكرة كبيرة ، لذا يمكنك بسهولة استخدام أجزاء 64 بت ، ولا داعي للقلق بشأن overflow إلا إذا كنت تتعامل مع أعداد فلكية وكبيرة جدًا.    ليست كل الأعداد الصحيحة التي تقل عن 18 quintillion تتناسب مع Number javascript ،على أية حال. تخزن هذه bits أيضًا,negative numbers ، لذلك يشير bit الواحد إلى علامة sign of the number تعني رقم . المشكلة الأكبر هي أنه يجب أيضًا تمثيل الأرقام غير الكلية. للقيام بذلك ، يتم اعتبار بعض وحدات البت لتخزين موقع الفاصلة العشرية أو الفاصلة المنقوطة. في الواقع ، أكبر عدد صحيح يمكن تخزينه يقع في الغالب في نطاق \( 9quadrillio \(15 zeros  ، والذي لا يزال عددًا كبيرًا جدًا.

تتم كتابة الأعداد الكسرية أو العشرية باستخدام النقاط.

`9.81`

 للأعداد الكبيرة جدًا أو الصغيرة جدًا, يمكنك أيضًا استخدام الترميز العلمي بواسطة اضافه           \(e \(for exponent متبوعًا بأس الرقم. مثال:

`2.998e8`

الرقم أعلاه يعادل `` 2.998 × 108 = 299,800,000

حسابات على الأعداد الصحيحة \(integer\)  يتم دائمًا حساب أقل من الحد الأقصى المذكور \(9 quadrillion \) بدقة. لسوء الحظ، عادة ما تكون الحسابات على الأرقام العشرية غير دقيقة.  تمامًا مثل رقم Pi ، الذي لا يمكن تمثيله بتسلسل محدود من الأرقام ، عندما يكون لدينا 64 bit فقط لتخزين الأرقام ، العديد من الأرقام, يفقدون بعض دقتها في الحسابات, لا يبدو هذا معقولاً ، ولكن من الناحية العملية ، لا تحدث مشاكل خطيرة إلا في ظل ظروف معينة. الشيء المهم الذي يجب أخذه في الاعتبار هو أنه يجب علينا توخي الحذر بشأن هذا النقص في الدقة والعمل مع الأعداد العشرية تقريبًا ، وليس كقيم دقيقة بنسبة 100٪.

## Arithmetic

 مهمتنا الرئيسية هي إجراء العمليات الحسابية بالأرقام. تأخذ العمليات الجبرية أو الحسابية ، مثل الجمع أو الضرب ، قيمتين رقميتين وتولد رقمًا جديدًا منهما. في JavaScript ، ستبدو مثل هذه الحسابات كما يلي:

`100 + 4 * 11`

تتسمى الرموز + و \* \(operators\) الرمز الأول هو رمز الجمع والرمز الثاني يستخدم للضرب  إذا كان عامل التشغيل بين قيمتين ، فإنه يعمل عليهما ويولد قيمة جديدة.                                 هل تعني العبارة أعلاه إضافة الرقم 4 إلى 100 وضرب النتيجة في 11؟ أم الضرب قبل الجمع؟ كما قد تكون خمنت ، فإن الضرب يحدث في وقت أقرب. ولكن كما في الرياضيات ، يمكنك وضع الجمع بين قوسين لتغيير الترتيب.

 `(100 + 4) * 11`

للطرح هناك عامل\(  - \) وللقسمة هناك عامل\(  /  \).

 عند استخدام عوامل التشغيل بدون أقواس ، فإن الترتيب المستخدم لحسابها وتحديد أولوياتها يعتمد على أسبقية العوامل. الترتيب الذي يتم تطبيقها بواسطة,  أسبقية العوامل,                            المثال يوضح أن الضرب يأتي قبل الجمع , العامل / له نفس الشيء الأسبقية \* , وبالمثل مع + و -. عندما يتم وضع عدة عوامل لها نفس الأسبقية في نفس التعبير ، مثل 1 - 2 + 1 ، سيكون الاستخدام من اليسار إلى اليمين: \(1 - 2\) + 1 نحوه

> لا تقلق بشأن قواعد الأسبقية هذه. استخدم الأقواس إذا كنت تشك في الأولوية.

لا يزال هناك عامل حسابي آخر ، عامل ربما لم تكن قد خمنت وظيفته. يتم استخدام رمز remainder ٪  لحساب الباقي , X %Y يعني حساب ما تبقى من القسم  X- -Y. على سبيل المثال، ينتج عن نتيجة العبارة 314 % 100 يعطينا ناتج 14,   و144 % 12 يعطينا رقم  0.   أسبقية العامل المتبقي هي نفس أسبقية الضرب والقسمة, سترى أيضًا غالبًا أن هذا العامل يشار إليه باسم \(modulo\).

## Special numbers

في JavaScript ، هناك ثلاث قيم محددة يتم احتسابها كأرقام ولكن ليس لها خصائص وسلوك الأرقام العادية. 

الأولين هما  `Infinity` و `-Infinity` 

وهما رمزان لما لا نهاية ، موجب وسالب,  infinity  -1 ستستمر في كونها infinity. لا تعتمد كثيرًا على العمليات الحسابية على أساس قيم اللانهاية. من وجهة نظر رياضية ، فهي ليست مستقرة جدًا وقد تنتج نتيجة هي الرقم الخاص الثالث لدينا: NaN. 

ب NaN تعني Not a Number , يعني "غير رقم". ومع ذلك ، فهي قيمة لنوع بيانات الرقم,  ستحصل على هذه النتيجة عندما تحاول ، على سبيل المثال  الحساب:                                     أو أي عملية حسابية أخرى على أرقام تكون نتيجتها غير واضحة وذات مغزى.

```text
 0 / 0 (zero divided
by zero)  , Infinity - Infinity
```

## Strings

نوع البيانات الأساسي التالي هو String. تُستخدم Stings النصية لعرض النص وتتم كتابتها بطريقة يتم بها إحاطة محتوياتها بعلامات اقتباس \(' '\) أو \( " " \).

```text
`Down on the sea`
"Lie on the ocean"
'Float on the ocean'
```

 يمكنك استخدام علامات الاقتباس المفردة أو علامات الاقتباس الزوجية أو الأحرف backticks               لتحديد السلاسل ، طالما أنك تستخدم نفس الرمز لبدء السلسلة وإنهائها.

يعتبر JavaScript أو يحاول تحويل أي قيمة تقريبًا محاطة بعلامات اقتباس إلى سلسلة. بالطبع ، بعض الشخصيات الخاصة لها شروط مختلفة. إذا أردنا وضع علامة الاقتباس نفسها بين علامات الاقتباس في سلسلة ، سنواجه مشكلة. يمكن أيضًا وضع أحرف سطر جديد \(الأحرف التي تظهر بعد الضغط على مفتاح الإدخال\) في سلسلة بدون "هروب" فقط عندما تكون السلسلة محاطة بحرف backticks \(\`\). اي الزر الي تقريبا هو حرف ال \(ذ\) في لوحه المفاتيح اسمه backticks هذه العلامه  `` **`ّ`** 

 لوضع مثل هذه الأحرف في سلسلة ، يتم استخدام هذه الطريقة: 

كلما تم تضمين حرف داخل سلسلة نصية بين علامتي اقتباس \(/\) تم العثور على Backlash ، فهذا يعني أن الحرف بعده له معنى خاص ويجب تفسيره بشكل مختلف , هذا يعني أن الشخصية التي تليها لها معنى خاص ويجب تفسيرها بشكل مختلف. هذا يسمي الهروب \(escaping\) من الشخصية. الاقتباس الذي يسبقه خط مائل عكسي لن ينتهي الخيط ولكن كن جزءًا منه,                   عندما يظهر حرف **n**  بعد الشرطة المائلة للخلف\ ذلك يعني انه يخبره ان يبدا سطر جديد ,          . وبالمثل ، فإن حرف  **t**  بعد الشرطة \ يعني حرف جدولة .

خذ السلسلة التالية:

`"This is the first line\nAnd this is the second"`

النص الفعلي الوارد هو هذا:

**This is the first line**

 **And this is the second**

ستكون هناك أيضًا أوقات تريد فيها عرض رد الفعل العكسي داخل سلسلة ، وليس كرمز محدد. في هذه الحالة ، يتم استخدام رد فعل عنيف على التوالي, سيؤدي هذا إلى عرض واحد منهم في السلسلة النهائية. على سبيل المثال ، لعرض سلسلة مطابقة للسلسلة التالية:                           “A newline character is written like "\n".” can be expressed:             

`"A newline character is written like \"\n\"."`             

 يجب أيضًا تحويل السلاسل إلى سلسلة من البتات ليتم تخزينها داخل الكمبيوتر. تعتمد طريقة استخدام JavaScript لهذا على معيار Unicode.  يعيّن هذا المعيار الرقمي جميع الأحرف التي قد تحتاجها \(بما في ذلك الأحرف من اليونانية والعربية واليابانية والأرمنية ، إلخ.\)                إذا كان لدينا رقم لكل حرف ، فيمكن وصف السلاسل من خلال سلسلة من هذه الأرقام.

وهذا ما تفعله JavaScript. لكن هناك تعقيد: جافا سكريبت يستخدم التمثيل 16 bit لكل عنصر سلسلة ، والتي يمكن أن تصف ما يصل إلى   2.16   حرف مختلف ,                                       لكن Unicode يحدد المزيد من الأحرف ، وهو الآن ضعف هذا الرقم تقريبًا. لذا ، فإن بعض الأحرف ، مثل العديد من أحرف الرموز التعبيرية ، تشغل "مسافتين" في سلسلة. سنعود إلى هذه النقطة في الفصل الخامس.

لا يمكن إجراء العمليات الحسابية للقسمة أو الضرب أو الطرح على السلاسل ، ولكن يمكن استخدام عامل +. لا يقوم عامل التشغيل هذا بإجراء مجموع حسابي على السلاسل ، ولكن إجراء لصق سلسلتين. يولد رمز الفئة الفرعية "متسلسلة"

```text
"con" + "cat" + "e" + "nate"
```

يمكن تنفيذ قيم السلسلة التشغيلية من خلال الوظائف \(الطرق\) ذات الصلة ، والتي نناقشها في الفصل 4.السلاسل المكتوبة بعلامات اقتباس مفردة أو زوجية تعمل بشكل مشابه جدًا - الاختلاف الوحيد هو علامة الاقتباس ، والتي يجب تجنبها إذا تم استخدامها. الاختلاف الوحيد هو نوع الاقتباس الذي تحتاجه للهروب من داخلها. يمكن للسلاسل المقتبسة عن طريق Backtick ، ​​والتي تسمى عادةً template literals ، أن تفعل أكثر من ذلك بقليل الخدع. بصرف النظر عن القدرة على تمديد الخطوط ، يمكنهم أيضًا تضمين قيم أخرى.

`half of 100 is ${100 / 2}`

عندما يكون هناك شيء في template literals  { } $  اكتبها باستخدام backtick , ،        يتم حساب نتيجة العبارة وتحويلها إلى سلسلة وتوضع في المكان المطلوب. ينتج المثال أعلاه السلسلة "نصف 100 يساوي 50". ينتج عنه.

### Unary operators

ليست كل عوامل التشغيل رموزًا. بعضها مكتوب بأحرف لاتينية عادية , مثال على ذلك هو عامل التشغيل typeof ، والذي يُرجع نوع بيانات الإدخال كسلسلة.

```text
console.log(typeof 4.5)
// → number
console.log(typeof "x")
// → string
```

في أمثلة الكتاب ، نستخدم الأمر console.log لإظهار نتيجة تقييم شيء ما. انظر الفصل التالي لمزيد من المعلومات. 

المشغلون الآخرون الذين رأيناهم يعملون على قيمتين ، لكن typeof يحتاج فقط إلى قيمة واحدة. العوامل التي تتطلب قيمتين هي عوامل \( _binary\)_ من المأمول الحصول عليها ، في حين أن أولئك الذين يتصرفون على أساس القيمة يطلق عليهم مشغلي الوحدات. يمكن استخدام عامل الطرح \(-\) كوحدة وثنائي.

```text
console.log(- (10 - 2))
// → -8
```

### Boolean values

في بعض الأحيان يكون من الضروري تحديد وتمييز حالتين فقط بقيمة واحدة ، 

مثل “yes” و “no” یا “on” و “off”.  لهذا الغرض ، تعتبر JavaScript نوع البيانات 

م\( _Boolean_ \)، التي تحتوي على قيمتين فقط. true او false,  \(وهي مكتوبة بنفس الطريقة\).

## Comparison

فيما يلي طريقة واحدة لإنتاج القيم المنطقية:

```text
console.log(3 > 2)
// → true
console.log(3 < 2)
// → false
```

الرموز&gt; و &lt;هي نفس الرموز التقليدية لكل من "أكبر من" و "أصغر من" ، على التوالي .هم عوامل ثنائية. ينتج عن استخدامها قيمة منطقية تشير إلى ما إذا كانت صحيحة أم لا.

يمكن مقارنة السلاسل بطريقة مماثلة.

```text
console.log("Aardvark" < "Zoroaster")
// → true
```

يتم ترتيب السلاسل أبجديًا تقريبًا ، ولكن ليس بالضبط كما ترى في القاموس. تعتبر الأحرف الكبيرة "أصغر" مقارنة بالأحرف الصغيرة ، ‌"Z" &lt; "a"  والشخصيات غير الأبجدية     \(! ، - ، وما شابه\) يتم ترتيبها ومقارنتها أيضًا. عند مقارنة السلاسل ، يقوم JavaScript بمقارنة أحرف كل سلسلة واحدة تلو الأخرى من اليسار إلى اليمين بناءً على كود Unicode الخاص بهم.

 Other similar operators are `>=` \(greater than or equal to\), `<=` \(less than or equal to\), `==` \(equal to\), and `!=` \(not equal to\).

```text
console.log("Itchy" != "Scratchy")
// → true
console.log("Apple" == "Orange")
// → false
```

       توجد قيمة واحدة فقط في JavaScript لا تساوي نفسها ، وهي NaN \("ليس رقمًا"\).        

`console.log(NaN == NaN) // → false`        

من المفترض أن يشير NaN إلى نتيجة حساب غير منطقي ، وعلى هذا النحو ، فإنه لا يساوي نتيجة أي حسابات أخرى غير منطقية. 

### Logical operators

هناك أيضًا عمليات يمكن إجراؤها على القيم المنطقية. يدعم JavaScript ثلاثة عوامل تشغيل منطقية:   JavaScript supports three logical operators: _and_, _or_, and _not_. These can be used to “reason” about Booleans. 

يمثل عامل التشغيل && منطقي and . إنه عامل ثنائي ، ونتيجته صحيحة فقط إذا كانت كلتا القيمتين المعطاة له true. 

```text
console.log(true && false)
// → false
console.log(true && true)
// → true
```

عامل \|\| الرمز orمنطقي. تكون نتيجة هذا العامل صحيحة عندما تكون إحدى القيمتين المحددتين صحيحة.

```text
console.log(false || true)
// → true
console.log(false || false)
// → false
```

لم يكتب كعلامة تعجب \( ! \) انه \(unary operator\)  عامل أحادي يقلب القيمة المعطاة له ينتج عنه  `true` produces `false`, and `false!` gives `true!`. اذا كانت القيمه صحيحه ارجع خطاء اما اذا كانت القيمه خاطاءه  نفذ  \(true\).

عندما نجمع هذه العوامل مع العمليات الحسابية والعوامل الأخرى, ليس من الواضح دائمًا متى يكون من الضروري استخدام الأقواس. من الناحية العملية ، يمكنك عادة معرفة ذلك من المشغلين الذين رأيناهم حتى الآن \| \| لديه أدنى أسبقية, تم ياتي && , ثم تاتي عوامل المقارنه  \(comparison operators\),   \(`>`, `==`, …\) وهكذا  ثم البقية. تم اختيار هذا الترتيب بحيث ، في التعبيرات النموذجية مثل التعبير التالي ، يلزم وجود أقل عدد ممكن من الأقواس:

```text
1 + 1 == 2 && 10 * 10 > 50
```

آخر عامل منطقي سأتحدث عنه ليس واحدًا بل ثنائي, آخر عامل منطقي سأناقشه ليس أحاديًا ، وليس ثنائيًا ، لكنه ثلاثي ، يعمل على ثلاث قيم هو مكتوب بعلامة استفهام ونقطتين ، على النحو التالي:

```text
console.log(true ? 1 : 2);
// → 1
console.log(false ? 1 : 2);
// → 2
```

يسمى هذا المشغل بالمشغل الشرطي \(يسمى أحيانًا نفس المشغل الثلاثي لأنه المشغل الوحيد الذي لديه هذه الميزة في JavaScript\) تشيرالقيمة الموجودة على يسار علامة الاستفهام "تختار" أي من القيمتين الأخريين سيظهر. عندما تكون صحيحة ، فإنها تختار القيمة الوسطى ، وعندما تكون خطأ ، فإنها تختار القيمة الموجودة على اليمين.

### Empty values

هناك نوعان من القيم المحددة التي تشكل null و undefined , التي تستخدم للدلالة على عدم وجود قيمة ذات مغزى هم أنفسهم قيم ، لكنهم لا يحملون أي معلومات.

الفرق في معنى القيمتين: undefiend و null هو حادث تصميم جافا سكريبت  ولا يهم معظم الوقت. في الحالات التي يتعين عليك فيها بالفعل أن تشغل نفسك بهذه القيم ، أوصي بمعاملتها على أنها قابلة للتبادل في الغالب. إذا كانت هناك مواقف يجب أن تهتم فيها بالفرق بين الاثنين ، أقترح أن تعتبر كلاهما متساويين وأن تستخدم أحدهما بدلاً من الآخر.

### Automatic type conversion

في مقدمة الكتاب ، أوضحت أن JavaScript يبذل جهودًا كبيرة لتفسير أي برنامج تقدمه له ، حتى البرامج التي لا تبدو صحيحة. ويتضح هذا جيدًا في البيانات التالية:  

```text
console.log(8 * null)
// → 0
console.log("5" - 1)
// → 4
console.log("5" + 1)
// → 51
console.log("five" * 2)
// → NaN
console.log(false == 0)
// → true
```

عندما يتم تطبيق عامل على "wrong" نوع القيمة ، سيقوم JavaScript بتحويل هذه القيمة بهدوء إلى النوع الذي تحتاجه باستخدام مجموعة من القواعد التي غالبًا لا تكون ما تريده أو تتوقعه  هذا يسمي " _type coercion_", في "null"   القيمه خاليه وتصبح "0", و "5" في التعبير الثاني يصبح 5 \(من سلسلة إلى رقم\) . ومع ذلك ، في التعبير الثالث ، + يحاول ربط السلسلة قبل الجمع الرقمي ، لذلك يتم تحويل 1 إلى "1" \(من رقم إلى سلسلة\).          

إذا كان لا يمكن تحويل قيمة بشكل صريح إلى رقم مثل \( five or undefiend\)  يتم تحويله إلى رقم إلى رقم ، تحصل على القيمة NaN. تستمر العمليات الحسابية الأخرى على NaN في إنتاج NaN ، لذلك إذا وجدت نفسك تحصل على واحد منها في مكان غير متوقع ، فابحث عن تحويلات من النوع العرضي.

عند مقارنة قيم نوع البيانات مع == ، يمكن بسهولة التنبؤ بالإخراج إذا كانت القيمتان متماثلتين ، فستكون النتيجة صحيحة " true" باستثناء قيمة NaN. ولكن عندما تختلف الأنواع  تستخدم  في JavaScript مجموعة معقدة ومربكة من القواعد لتحديد ما يجب فعله في معظم الحالات ، يحاول فقط تحويل إحدى القيم إلى نوع القيمة الأخرى, ومعا ذلك عندما ياتي null او undefiend      تقع على جانب واحد من المشغل, ينتج صحيحًا فقط إذا كان كلا الجانبين واحدًا  من undefiend او null 

```text
console.log(null == undefined);
// → true
console.log(null == 0);
// → false
```

غالبًا ما يكون هذا السلوك مفيدًا. عندما تريد اختبار ما إذا كانت القيمة لها قيمة حقيقية بدلاً من   `null` or `undefined` يمكنك مقارنه null معا == او =! operator  



ولكن ماذا لو كنت تريد اختبار ما إذا كان هناك شيء يشير إلى القيمة الدقيقة ?false,  ماذا علينا ان نفعل؟ وفقًا لقواعد تحويل السلاسل والأرقام إلى قيم منطقية                                               

```text
 0 == false and "" == false 
```

هي أيضًا صحيحة بسبب التحويل التلقائي للنوع. عندما لا ترغب في حدوث أي نوع من التحويلات ، فهناك عاملان إضافيان  === و ==!  يتحقق العامل الأول من أن القيمة تتوافق تمامًا مع القيمة الأخرى ويتحقق الأخير من أنها لا تتوافق تمامًا. هكذا   false ===   " "  يرجع القيمة الخاطئة كما هو متوقع .

أقترح استخدام عامل المقارنة "comparison operators" المكون من ثلاثة أحرف كإجراء احترازي لمنع تحويل البيانات غير المرغوب فيه الذي يسبب مشكلة. ولكن عندما تكون متأكدًا من تشابه نوع البيانات بين الجانبين ، فلن يكون استخدام عوامل تشغيل أقصر خطأ.

## Short-circuiting of logical operators

العوامل المنطقيه "The logical operators" && و \| \|  يستخدمون طريقة خاصة لتقييم قيم أنواع البيانات المختلفة , أولاً ، يقومون بتحويل القيمة إلى يسار المشغل إلى نوع منطقي لتحديد ما يجب فعله ، اعتمادًا على نوع المشغل ونتيجة تحويل نوع البيانات. إما أن تُرجع القيمة الأصلية إلى اليسار أو القيمة إلى اليمين. 

عامل \| \| ، على سبيل المثال ، تُرجع القيمة إلى يسار التعبير عندما يمكن تحويلها إلى صحيح ، وإلا تُرجع القيمة إلى اليمين, يعمل هذا التحويل بالشكل الذي تتوقعه مع القيم المنطقية ، ويفعل الشيء نفسه مع أنواع البيانات الأخرى.

```text
console.log(null || "user")
// → user
console.log("Agnes" || "user")
// → Agnes
```

مع هذه الميزة يمكنك استخدام عامل التشغيل \| \|  تستخدم كطريقة للنظر في القيمة الافتراضية في التعبيرات. إذا كانت لديك قيمة قد تكون فارغة ، يمكنك وضع  \| \| بعد ذلك بقيمة الاستبدال إذا كان من الممكن تحويل القيمة الأولية إلى خطأ ، فستحصل على البديل بدلاً من ذلك  وفقًا لقواعد تحويل السلاسل والأرقام إلى قيم منطقية  و NaN وسلسلة فارغة \(""\) كاذبة ، بينما تعتبر القيم الأخرى صحيحة. لذلك  `0 || -1` produces `-1`, and `"" || "!?"` yields `"!?"`.

يعمل عامل التشغيل && بنفس الطريقة ولكن بالاتجاه المعاكس. عندما تكون القيمة على يسار التعبير عبارة تتحول إلى خطأ ، سيتم إرجاع نفس القيمة إلى اليسار ، وإلا سيتم تقييم القيمة الموجودة على اليمين وإرجاعها.

ميزة أخرى مهمة لهذين العاملين هو أن تعبيرهما إلى اليمين لا يتم تقييمه إلا عند الحاجة. 





