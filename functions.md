---
description: >-
  يعتقد الناس أن معرفة الكمبيوتر ومهاراته مخصصة للعباقرة ، ولكن الواقع عكس ذلك ،
  فالكثير من الناس فقط يعملون في إنشاءات بعضهم البعض ،"مثل جدار مصنوع من الحجارة
  الصغيرة." ' Donald Knut'
---

# Functions

![](.gitbook/assets/image%20%2820%29.png)



الوظائف هي الخبز والزبدة لبرمجة JavaScript . مفهوم وضع جزء من البرنامج داخل قيمة له استخدامات عديدة. يمكن استخدام هذا المفهوم لبناء تطبيقات أكبر ، وتجنب الازدواجية ، وتسمية الإجراءات الفرعية ، وفصلها بشكل مستقل.

التطبيق الأكثر وضوحًا للوظائف هو تحديد مفردات جديدة. عادة ما يكون إنشاء كلمات جديدة في النثر أسلوبًا سيئًا. لكن في البرمجة ، لا غنى عنه.

به طور معمول، انگلیسی زبانان بزرگسال در دامنه‌ی واژگانشان حدود 20,000 کلمه دارند. هناك عدد قليل من لغات البرمجة التي تحتوي على 20،000 أمر محدد مسبقًا. بالطبع ، يتم أيضًا تحديد هذه الأوامر أو الكلمات المتوفرة بعناية ، مما يؤدي إلى مرونة أقل من اللغات البشرية. لذلك ، نحتاج عادةً إلى تحديد مفاهيم جديدة لتجنب التكرار غير الضروري.

### Defining a function

تعريف الوظيفة هو ارتباط عادي حيث تكون قيمة الربط دالة. على سبيل المثال ، يعرّف هذا الرمز `squre` للإشارة إلى دالة تنتج مربع رقم معين:

```text
const square = function(x) {
  return x * x;
};

console.log(square(12));
// → 144
```

يمكن إنشاء دالة بواسطة تعبير يبدأ بكلمة دالة "function". الوظائف لها مجموعة من المعلمات" _parameters_ "  \(في هذه الحاله فقط , x\)  والجسم الذي يحتوي على العبارات التي سيتم تنفيذها عند استدعاء الوظيفة . يجب أن يكون جسم الوظيفة للوظيفة التي تم إنشاؤها بهذه الطريقة ملفوفًا دائمًا بأقواس. حتى عندما يحتوي على أمر واحد فقط \(كما في المثال السابق\)

يمكن أن تحتوي الوظيفة على معلمات متعددة أو لا تحتوي على معلمات على الإطلاق. في المثال أدناه, ، لا تحتوي وظيفة makeNoise على معلمات بينما تحتوي وظيفة powerعلى معلمتين: 

```text
const makeNoise = function() {
  console.log("Pling!");
};

makeNoise();
// → Pling!

const power = function(base, exponent) {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
};

console.log(power(2, 10));
// → 1024
```

ترجع بعض الدوال قيمًا ، مثل دالات power و squre. وبعض الوظائف مثل makeNoise تنتج آثارًا جانبية فقط ولا ترجع أي قيمة. الأمر المسمى return مسؤول عن إرجاع قيمة من الوظيفة.  . عندما يصل البرنامج إلى هذا الأمر ، فإنه يخرج بسرعة من الوظيفة الحالية ويرسل القيمة "المرتجعة" إلى جزء البرنامج حيث يتم استدعاء الوظيفة. ستؤدي كلمة return بدون تعبير  إلى إرجاع دالة undefined.  الدالات التي لا تحتوي على جملة return على الإطلاق ، مثل makeNoise ، ترجع قيمًا غير محددةundefined.

تتصرف المعامِلات 'Parameters' في الدوال تمامًا مثل المتغيرات العادية ، ولكن يتم تعيين قيمتها الأولية بواسطة منادي الوظيفة ، وليس الرمز المكتوب في جسم الوظيفة.

### Bindings and scopes

لكل متغير نطاق وصول "scope"  ، وهو جزء من البرنامج حيث يمكن الوصول إلى المتغير ومرئيًا. بالنسبة للمتغيرات التي تم تحديدها خارج دالة أو كتلة ، يغطي هذا المجال البرنامج بأكمله - يمكنك الوصول إلى هذه المتغيرات في أي مكان في البرنامج. هذه المتغيرات تسمى المتغيرات global.

لكن المتغيرات التي تم إنشاؤها لمعلمات الوظيفة أو تلك التي تم تحديدها داخل دالة لا يمكن الإشارة إليها إلا ضمن هذه الوظيفة ، ومن ثم يطلق عليها المتغيرات المحلية. في كل مرة يتم استدعاء دالة ، يتم إنشاء مثيلات جديده  لهذه المتغيرات.  يؤدي هذا إلى عزل الوظائف إلى حد ما عن بعضها البعض - تعمل كل استدعاء دالة في مساحتها الخاصة \(البيئة المحلية الخاصة بها\). وعادة ما يمكن فهم طريقة العمل هذه من البرنامج ولا نحتاج إلى معرفة التفاصيل المتعلقة بها في البيئة العالمية. 

الارتباطات المعلنة بـ let و const هي في الواقع محلية للكتلة التي تم الإعلان عنها فيها. لذلك إذا حددت إحداها داخل حلقة ، فلن يتمكن الكود قبل وبعد الحلقة "رؤيتها". في إصدارات ما قبل 2015 من JavaScript ، كانت هناك وظائف فقط يمكنها إنشاء منطقة أو مجال جديد ، لذا فإن المتغيرات القديمة ، المحددة بواسطة var ، شوهدت في الوظيفة التي تم تحديدها من خلالها. إذا لم يكونوا ضمن وظيفة ، فقد كانوا متاحين في جميع أنحاء التطبيق.

```text
let x = 10;
if (true) {
  let y = 20;
  var z = 30;
  console.log(x + y + z);
  // → 60
}
// y is not visible here
console.log(x + z);
// → 40
```

يمكن لكل عالم أن يرى العالم من حوله ، على سبيل المثال في البرنامج أعلاه ، المتغير x مرئي داخل الكتلة. يحدث استثناء هنا عندما يكون هناك العديد من المتغيرات التي تحمل نفس الاسم ، وفي هذه الحالة يمكن لرمز البرنامج رؤية العنصر الأعمق. على سبيل المثال ، في دالة halve للمثال أدناه ، عندما يشير الكود الموجود داخل الدالة إلى المتغير n ، يتم استخدام المتغير n للدالة نفسها ، وليس المتغير العام n.

```text
const halve = function(n) {
  return n / 2;
};

let n = 10;
console.log(halve(100));
// → 50
console.log(n);
// → 10
```

### Nested scope

لا تميز JavaScript فقط بين المتغيرات العامة والمحلية.يمكن إنشاء الكتل والوظائف داخل الكتل والوظائف الأخرى ، مما يؤدي إلى إنشاء درجات متفاوتة من الموقع.

على سبيل المثال ، هذه الوظيفة - التي تُرجع المكونات اللازمة لتحضير حمص \(نوع من الطعام\) - له وظيفة أخرى بداخله:

```text
const hummus = function(factor) {
  const ingredient = function(amount, unit, name) {
    let ingredientAmount = amount * factor;
    if (ingredientAmount > 1) {
      unit += "s";
    }
    console.log(`${ingredientAmount} ${unit} ${name}`);
  };
  ingredient(1, "can", "chickpeas");
  ingredient(0.25, "cup", "tahini");
  ingredient(0.25, "cup", "lemon juice");
  ingredient(1, "clove", "garlic");
  ingredient(2, "tablespoon", "olive oil");
  ingredient(0.5, "teaspoon", "cumin");
};
```

يمكن للرمز الموجود داخل وظيفة  `ingredient` رؤية ملف  `factor`  ملزمة من الوظيفة الخارجية.            لكن المتغيرات المحلية تشبه unit او  ingredientAmount لا يمكن رؤيتها بواسطة الوظيفة الخارجية.

تعتمد مجموعة المتغيرات المرئية داخل الكتلة على موقع الكتلة في نص البرنامج. يمكن لكل مجال محلي أيضًا رؤية المجالات المحلية التي تحيط به ، ويمكن لجميع المجالات رؤية المجال العام. هذه الطريقة للرؤية المتغيرة تسمى النطاق المعجمي\(Lexical Scoping\).

### Functions as values

عادة ما يلعب المتغير المخصص لوظيفة ما دور اسم جزء من البرنامج. يتم تعريف هذه المتغيرات مرة واحدة ولا تتغير. قد يتسبب هذا في الخلط بين اسم الوظيفة والدالة نفسها.

لكن الاثنين مختلفان. يمكن لقيمة الدالة أن تفعل كل الأشياء التي يمكن للقيم الأخرى القيام بها - يمكنك استخدامها في تعبيرات عشوائية ، وليس مجرد تسميتها. يمكن تخزين قيمة الوظيفة في متغير جديد ، وتمريرها كوسيطة إلى دالة ، وما إلى ذلك.أيضًا ، لا يزال المتغير الذي يحتوي على دالة مجرد متغير عادي ، ويمكن تخصيص قيمة جديدة له إذا لم يتم تعريفه على أنه ثابت. فمثلا:

```text
let launchMissiles = function() {
  missileSystem.launch("now");
};
if (safeMode) {
  launchMissiles = function() {/* do nothing */};
}
```

في الفصل الخامس ، سنناقش بعض الأشياء الشيقة التي يمكن القيام بها عن طريق تمرير الدوال كقيم إلى وظائف أخرى.

### Declaration notation

هناك طريقة أقصر لتعريف الوظيفة. إذا تم استخدام الكلمة الأساسية للوظيفة في بداية العبارة ، فسيكون لها معنى مختلف.

```text
function square(x) {
  return x * x;
}
```

تحدد هذه الطريقة وظيفة بإعلان. يعرّف هذا الأمر متغيرًا يسمى مربعًا ويخصصه لوظيفة معينة. يبدو تحديد وظيفة بهذه الطريقة أبسط قليلاً وليس من الضروري استخدام فاصلة بعد تحديد الوظيفة.

في هذه الطريقة لتحديد الوظيفة ، هناك نقطة دقيقة يجب أخذها في الاعتبار.

```text
console.log("The future says:", future());

function future() {
  return "You'll never have flying cars";
}
```

يعمل الكود أعلاه بشكل جيد على الرغم من أن تعريف الوظيفة أقل من السطر الذي يستدعيها. وذلك لأن إعلانات الوظائف في JavaScript لا تعتبر جزءًا من تدفق التحكم العادي من أعلى إلى أسفل للبرنامج. من الناحية المفاهيمية ، يتم نقلهم إلى الجزء العلوي من المجال الخاص بهم ويمكن استخدامها في جميع التعليمات البرمجية في هذا المجال. هذه الميزة مفيدة في بعض الأحيان لأنها تمنحنا حرية تنظيم الكود بحيث يتم تنظيمه بشكل أفضل دون الحاجة إلى القلق بشأن تحديد وظائفنا قبل استدعائها.

### Arrow functions

هناك طريقة ثالثة لتعريف الوظائف ، والتي تبدو مختلفة جدًا عن الطرق السابقة. بدلاً من استخدام الكلمة الأساسية للوظيفة ، يتم استخدام سهم \(&lt;=\) يتكون من رمز يساوي وأكبر. \(يجب عدم الخلط بينه وبين عامل أكبر من أو يساوي ، مكتوبًا كـ &gt; =\) 

```text
const power = (base, exponent) => {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
};
```

يأتي حرف السهم مباشرة بعد قائمة المعلمات ، وبعد ذلك سيأتي جسم الوظيفة. يمكن تفسيره بطريقة "ينتج عن هذا المدخل \(هذه المعلمات\) هذه النتيجة \(جسم الوظيفة\)". 🌠 مهم

عندما يكون هناك معامل واحد فقط ، يمكنك تخطي الأقواس. إذا كان نص الوظيفة يحتوي على تعبير واحد فقط ، وليس كتلة محاطة بأقواس ، فسيتم إرجاع هذا التعبير بواسطة الوظيفة. . لذا فإن كلا الطريقتين لتعريف الدالة التربيعية تفعل الشيء نفسه:

```text
const square1 = (x) => { return x * x; };
const square2 = x => x * x;
```

عندما تفتقر وظيفة السهم\(arrow function\) إلى معلمة ، تتم كتابة قائمة المعلمات الخاصة بها كزوج من الأقواس الفارغة. 

```text
const horn = () => {
  console.log("Toot");
};
```

لا يمكن العثور على سبب قوي للحاجة إلى كلا النوعين من تعريفات الوظائف \(طريقة السهم والروتين\) بصرف النظر عن القضايا الثانوية \(التي تمت مناقشتها في الفصل 6\) ، كلاهما يفعل الشيء نفسه. تمت إضافة طريقة السهم إلى اللغة في إصدار 2015 ؛ في الغالب لأن الوظائف يمكن كتابتها في شكل أقصر وأكثر إيجازًا وتجنب الكتابة فوقها. سنستخدمها كثيرًا في الفصل الخامس.

### The call stack <a id="stack"></a>

يعد تدفق التحكم في البرنامج أكثر تعقيدًا في الوظائف. من المناسب إلقاء نظرة فاحصة على كيفية تدفق التحكم في الوظائف. إليك برنامج بسيط يحتوي على العديد من استدعاءات الوظائف:

```text
function greet(who) {
  console.log("Hello " + who);
}
greet("Harry");
console.log("Bye");
```

سيكون تنفيذ هذا البرنامج بشكل عام على النحو التالي: يؤدي استدعاء وظيفة greet إلى بدء التحكم في البرنامج في جسم تلك الوظيفة \(السطر 2\). يستدعي وظيفة console.log \(وهي وظيفة سابقة الإنشاء في المتصفح\) ، والتي تتولى التحكم وتؤدي وظيفتها وتعيد التحكم إلى السطر 2. ثم ينتقل إلى نهاية دالة greet بحيث يعود إلى حيث كان يطلق عليه في الأصل ، السطر 4. يستدعي السطر التالي console.log مرة أخرى. بعد ذلك ينتهي البرنامج.

يمكننا تمثيل تدفق التحكم هذا رمزياً على النحو التالي:

{% tabs %}
{% tab title="not code" %}
```text
not in function
   in greet
        in console.log
   in greet
not in function
   in console.log
not in function
```
{% endtab %}
{% endtabs %}

نظرًا لأن الوظيفة يجب أن تعود إلى النقطة التي تم استدعاؤها منها بعد التنفيذ ، يجب أن يتذكر الكمبيوتر موقع البرنامج الذي تم استدعاء الوظيفة منه.  في حالة واحدة ، يجب أن تعود console.log إلى وظيفة greet بعد التنفيذ ، وفي الحالة التالية يجب أن تعود إلى نهاية البرنامج.

المكان الذي يخزن فيه الكمبيوتر هذا السياق\(context\) هو stackالاستدعاءات\(call stack\). في كل مرة يتم استدعاء دالة ، يتم تخزين السياق  الحالي كونتست أعلى هذه المجموعه stack. . عندما تعود دالة ، فإنها تزيل السياق العلوي من stack  وتستخدم هذا السياق لمتابعة التنفيذ.

يتطلب تخزين هذا stack مساحة في ذاكرة الكمبيوتر, عندما تنمو stack بشكل كبير جدًا, سوف يفشل الكمبيوتر ويرسل  خطاء برسالة مثل “out of stack space” او “too much recursion”. يوضح الكود التالي هذا من خلال طرح سؤال صعب حقًا على الكمبيوتر يؤدي إلى ذهاب وإياب لانهائي بين وظيفتين. بدلا من ذلك ، سيكون لانهائي ، إذا كان لدى الكمبيوتر stack لانهائي. كما هو ، سوف تنفد المساحة لدينا ، او “blow the stack”. تفجير stack.

```text
function chicken() {
  return egg();
}
function egg() {
  return chicken();
}
console.log(chicken() + " came first.");
// → ??
```

### Optional Arguments

كود المثال التالي صالح ويعمل بدون أي مشاكل:

```text
function square(x) { return x * x; }
console.log(square(4, true, "hedgehog"));
// → 16
```

حددنا squre بمعامل واحد فقط.  ولكن عندما نسميها بثلاثة ، لا تشتكي اللغة. يتجاهل الحجج الإضافية ويحسب squre الأول.

وJavaScript ذكي للغاية بشأن عدد الوسائط المستلمة. إذا قمت بإرسال وسيطات أكثر مما تم تحديده بالفعل ، فسيتم تجاهلها ببساطة. إذا قمت بإرسال عدد أقل من الوسائط ، فإنه يقوم بتعيين قيمة undefined  للوسيطات غير الموقعة.

الجانب السلبي لهذا هو أنك قد ترسل عن غير قصد وعن طريق الخطأ عددًا خاطئًا من الوسائط إلى الوظيفة ولا تلاحظها حتى.

والشيء الجيد هو أنه يمكن استخدامه للسماح باستدعاء دالة باستخدام العديد من الوسائط المختلفة. فمثلا, وظيفه minus تحاول تقليد عامل التشغيل - من خلال التصرف بناءً على واحدة أو اثنتين arguments:

```text
function minus(a, b) {
  if (b === undefined) return -a;
  else return a - b;
}

console.log(minus(10));
// → -10
console.log(minus(10, 5));
// → 5
```

إذا وضعت علامة = بعد كتابة المعلمة واكتب تعبيرًا ، فسيتم استبدال قيمة هذا التعبير إذا لم يتم إرسال الوسيطة.

على سبيل المثال ، هذا الإصدار من الوظيفة power, يتم تعريف الوسيطة الثانية على أنها اختيارية. إذا لم تقدمه أو تمرر القيمة undefiend . القيمة الافتراضية هي 2 والوظيفة مشابهة للدالة squre

```text
function power(base, exponent = 2) {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
}

console.log(power(4));
// → 16
console.log(power(2, 6));
// → 64
```

في الفصل التالي ، سنرى طريقة يمكن من خلالها لجسم وظيفي الحصول على قائمة كاملة من الوسائط التي تم تمريرها.باستخدام هذه الميزة ، يمكننا الحصول على العدد المطلوب من الوسائط في دالة. على سبيل المثال ، تستخدم الدالة console.log هذه الخاصية - فهي ترسل جميع القيم المعطاة لها إلى المخرجات.

```text
console.log("C", "O", 2);
// → C O 2
```

### Closure

إن القدرة على التعامل مع الوظائف كقيم ، جنبًا إلى جنب مع حقيقة أنه يتم إعادة إنشاء الروابط المحلية في كل مرة يتم فيها استدعاء وظيفة ، تثير سؤالًا مثيرًا للاهتمام. ماذا يحدث للارتباطات المحلية عندما لا يكون استدعاء الوظيفة الذي أنشأها نشطًا؟

يظهر الرمز التالي مثالا على ذلك. تحدد وظيفة ، wrapValue ، التي تنشئ ارتباطًا محليًا. ثم تقوم بإرجاع دالة تقوم بالوصول إلى هذا الربط المحلي وإرجاعه.

```text
function wrapValue(n) {
  let local = n;
  return () => local;
}

let wrap1 = wrapValue(1);
let wrap2 = wrapValue(2);
console.log(wrap1());
// → 1
console.log(wrap2());
// → 2
```

هذا مسموح به ويعمل كما كنت تأمل - لا يزال من الممكن الوصول إلى كلا مثيلي الربط. هذا الموقف هو دليل جيد على حقيقة أن الروابط المحلية يتم إنشاؤها من جديد لكل مكالمة والمكالمات المختلفة لا يمكن أن تدوس على الروابط المحلية لبعضها البعض.

هذه الميزة - القدرة على الإشارة إلى مثيل محدد لمتغير محلي في مجال مغلق - تسمى مانع أو كتلة.. الوظيفة التي تشير إلى المتغيرات المحلية للعالم المحيطي تسمى سرير أو كتلة. هذا السلوك يلغي الحاجة إلى النظر في عمر المتغيرات ويمهد الطريق للاستخدام الإبداعي لقيم الدالة.

مع القليل من التعديل ، يمكننا استخدام المثال السابق كطريقة لإنشاء وظائف تقوم بضرب قيمة عشوائية.

```text
function multiplier(factor) {
  return number => number * factor;
}

let twice = multiplier(2);
console.log(twice(5));
// → 10
```

ليست هناك حاجة لمتغير محلي صريح مثل مثال wrapValue لأن معلمة الوظيفة نفسها هي متغير محلي.

يتطلب الفهم والتفكير في برامج مثل البرنامج أعلاه القليل من الممارسة. النموذج العقلي الجيد هو افتراض أن قيم الوظيفة تحمل كود الجسم والبيئة التي تم إنشاؤها فيها. عند الاستدعاء ، يرى جسم الوظيفة البيئة التي يتم فيها إنشاء الوظيفة ، وليس البيئة التي يتم استدعاؤها فيها.

في المثال ، يسمى  `multiplier` وينشئ بيئة يتم فيها تعيين معامل factor إلى 2. . تستدعي قيمة دالة الإرجاع ، المخزنة في twice ،. لذلك عند الاستدعاء ، تضرب الوسيطة'argument' في 2.

### Recursion or ارجاع

يعتبر استدعاء دالة في حد ذاته أمرًا مقبولاً تمامًا ، طالما يتم ذلك بطريقة لا تؤدي إلى تجاوز سعة stack. الوظيفة التي تستدعي نفسها تسمى وظيفة العودة 'recursive'. تسمح المرتجعات بكتابة بعض الوظائف بأسلوب مختلف. فمثلا . اعد كتابه وظيفه power بشكل متكرر

```text
function power(base, exponent) {
  if (exponent == 0) {
    return 1;
  } else {
    return base * power(base, exponent - 1);
  }
}

console.log(power(2, 3));
// → 8
```

تشبه هذه الطريقة تقريبًا الطريقة التي يحدد بها علماء الرياضيات "قوة" الأرقام ، وربما تجعل المفهوم أكثر وضوحًا من طريقة استخدام الحلقة. تستدعي هذه الوظيفة نفسها عدة مرات بقوى أصغر لتحقيق مجموعة من الإيقاعات.

لكن طريقة التنفيذ هذه بها مشكلة: في تطبيقات JavaScript الشائعة ، تكون هذه الطريقة أبطأ بثلاث مرات تقريبًا من طريقة الحلقة. يعد التنقل في حلقة بسيطة أقل تكلفة بكثير من استدعاء دالة بشكل متكرر.

لغز الاختيار بين سهولة قراءة الكود وسرعة التنفيذ الأفضل هو لغز مثير للاهتمام. يمكن اعتباره نوعًا من القضايا المتعلقة بالإنسانية والصديقة للآلة. يمكن بناء جميع البرامج تقريبًا بشكل أسرع ولكن عن طريق تكبيرها وتعقيدها.                     يجب أن يتخذ المبرمج قرارًا بناءً على التوازن بين الاثنين.

في حالة وظيفة power المذكورة سابقًا ، لا تزال طريقة استخدام الحلقة سهلة القراءة والفهم نسبيًا. لا يوجد مبرر كبير لاستبدالها بالطريقة recursive. ومع ذلك ، في بعض الأحيان يواجه البرنامج نوعًا من المفاهيم المعقدة التي تبدو خيارًا جذابًا بغض النظر عن بعض السرعة أو الأداء في مواجهة المزيد من المباشرة.

القلق بشأن سرعة البرنامج يمكن أن يأخذك بعيدًا عن المشكلة الرئيسية. عند البرمجة ، أنت مشغول في حل مشكلة ما ، وعندما يقلقك عامل معقد آخر في نفس الوقت ، فإنه يمنعك من التقدم.

لذلك ، اكتب دائمًا رمزًا يعمل بشكل صحيح ومفهوم أولاً. إذا كنت قلقًا من أنه سيكون بطيئًا جدًا - وهو ما لن يكون كذلك في العادة - نظرًا لأن معظم التعليمات البرمجية لا يتم تنفيذها بعدد كبير بحيث يستغرق وقتًا طويلاً - يمكنك قياسه وتحسينه عند الانتهاء.

لاحظ هذا: بالبدء بالرقم 1 وإضافة الرقم 5 أو الضرب بالرقم 3 باستمرار ، يمكن توليد عدد لا نهائي من الأرقام الجديدة. كيف يمكنك كتابة دالة تأخذ عددًا وتعيد سلسلة من الضربات والمجموعات التي أدت إلى إنتاج هذا الرقم؟

على سبيل المثال ، يمكن الحصول على رقم 13 بضرب 1 في 3 وإضافة 5 مرتين ، بينما لا يمكن إنتاج رقم مثل 15 بهذه الطريقة على الإطلاق.

هنا نستخدم طريقه حل متكررrecursive : 

```text
function findSolution(target) {
  function find(current, history) {
    if (current == target) {
      return history;
    } else if (current > target) {
      return null;
    } else {
      return find(current + 5, `(${history} + 5)`) ||
             find(current * 3, `(${history} * 3)`);
    }
  }
  return find(1, "1");
}

console.log(findSolution(24));
// → (((1 * 3) + 5) * 3)
```

لاحظ أن البرنامج أعلاه لا يجد بالضرورة أقصر تسلسل للعمليات. الغرض من الوظيفة هو العثور على أي تسلسل للعمليات الصحيحة. 

إذا كنت لا تفهم كيفية عمل الوظيفة المذكورة أعلاه ، فلا تقلق. دعونا نفحصها معًا لأنها تمرين رائع للتفكير التعاودي.

تقوم وظيفة find الداخلية بتنفيذ العملية العودية الرئيسية. يتطلب الأمر وسيطين: الرقم الحالي والسلسلة التي تسجل كيف وصلنا إلى هذا الرقم. إذا وجدت حلاً ، فإنها ترجع سلسلة توضح كيفية الوصول إلى الهدف. إذا لم يتم العثور على حل بدءًا من هذا الرقم ، فسيتم إرجاعه فارغًا null.

للقيام بذلك ، تقوم الوظيفة بتنفيذ أحد الإجراءات الثلاثة. إذا كان الرقم الحالي هو الرقم المستهدف, ' history'الحالي هو وسيلة للوصول إلى هذا الهدف. إذا كان الرقم الحالي أكبر من الرقم المستهدف ، فليس من المنطقي القيام بمزيد من الاستكشاف لاكتشاف السجل لأن كل عملية تضيف أو تضاعف الرقم فقط ، لذا فهي ترجع قيمة null. أخيرًا ، إذا كان الرقم الحالي لا يزال أصغر من الرقم المستهدف ، تختبر الوظيفة كلا المسارين المحتملين بدءًا من الرقم الحالي وتقوم بذلك عن طريق استدعاء نفسها مرتين ، مرة للجمع ومرة ​​للضرب. إذا كان الاستدعاء الأول يولد شيئًا بخلاف القيمة الفارغة ، فإنه يعيده.  خلاف ذلك ، يتم إرجاع الاستدعاء الثاني - بغض النظر عما إذا كان يولد سلسلة أو null.

لفهم كيفية عمل الوظيفة بشكل أفضل ، دعنا نلقي نظرة على جميع استدعاءات find التي تحدث للعثور على إجابة مشكلة الرقم 13.

> ```text
> find(1, "1")
>   find(6, "(1 + 5)")
>     find(11, "((1 + 5) + 5)")
>       find(16, "(((1 + 5) + 5) + 5)")
>         too big
>       find(33, "(((1 + 5) + 5) * 3)")
>         too big
>     find(18, "((1 + 5) * 3)")
>       too big
>   find(3, "(1 * 3)")
>     find(8, "((1 * 3) + 5)")
>       find(13, "(((1 * 3) + 5) + 5)")
>         found!
> ```

المسافة البادئة في الكود أعلاه هي إظهار عمق stack استدعاء الوظيفة.  أول مرة يتم استدعاء find ، يستدعي نفسه لاستكشاف حل يبدأ بـ \(1 + 5\).  يستكشف استدعاء الإرجاع هذا جميع الحلول التي تنتج رقمًا أقل من أو يساوي الرقم المستهدف. نظرًا لأن هذا الاستدعاء لا يمكن أن يصل إلى حل ، يتم إرجاع القيمة null كناتج الاستدعاء  الأول.            العامل \| \| يسبب في استكشاف  \(1 \* 3\).  هذا البحث لديه فرصة أفضل - نداء العودة الأول ، من خلال مكالمة العودة ، يصل إلى الرقم المستهدف. يقوم استدعاء الإرجاع الأعمق بإرجاع سلسلة وكل من العوامل \| \| في المكالمات الوسيطة ، يتم تمرير هذه السلسلة جنبًا إلى جنب حتى يتم إرجاع الحل أخيرًا.

### Growing functions

لإضافة وظائف إلى البرنامج ، يمكن تصور وضعين طبيعيين أكثر أو أقل. 

عندما تلاحظ ، كرر نفس الرمز عدة مرات. ربما تفضل عدم القيام بذلك. يعني وجود المزيد من التعليمات البرمجية توفير مساحة أكبر لإخفاء الأخطاء وخلق المزيد من العمل للأشخاص الذين من المفترض أن يفهموا برنامجك من خلال قراءة الكود. لذلك نأخذ الجزء المكرر ونختار اسمًا جيدًا له ونحوله إلى دالة.

الحالة الثانية هي عندما تدرك أنك بحاجة إلى ميزة في البرنامج لم تكتبها بعد ، ويمكن أن يكون لهذه الميزة وظيفتها الخاصة. في هذه الحالة ، تقوم أولاً بإدخال اسم لهذه الوظيفة ثم كتابة جسمها. يمكنك حتى استخدامه في كود آخر قبل تحديد الوظيفة نفسها.

تعد صعوبة العثور على اسم جيد لوظيفة ما علامة جيدة لفهم مدى وضوح المفهوم الذي نريد تحويله إلى وظيفة بالنسبة لنا. دعنا نأخذ مثالا.

نخطط لكتابة برنامج يطبع رقمين: عدد الأبقار والدجاج في مزرعة مع الكلمات  بعدها ، وإظهار كلا الرقمين بطول 3 أرقام \(استخدم 0 للمحاذاة\)

007cows

011chicken

بالنظر إلى المشكلة ، نحتاج إلى دالة ذات وسيطين. عدد الأبقار وعدد الدجاج.

```text
function printFarmInventory(cows, chickens) {
  let cowString = String(cows);
  while (cowString.length < 3) {
    cowString = "0" + cowString;
  }
  console.log(`${cowString} Cows`);
  let chickenString = String(chickens);
  while (chickenString.length < 3) {
    chickenString = "0" + chickenString;
  }
  console.log(`${chickenString} Chickens`);
}
printFarmInventory(7, 11);
```

استخدم length . بعد قيمة السلسلة ، نحصل على طول السلسلة. هكذا while. تستمر في إضافة صفر إلى بداية سلسلة من الأرقام حتى يصل طولها إلى ثلاثة أحرف على الأقل.

انتهت المهمة! ولكن عندما نرسل البرنامج إلى مثالنا كمزارع \(مع الفاتورة\) ، يتصل بنا ويعلن أنه بدأ مؤخرا في تربية الخنازير وهل يمكننا زيادة قدرة البرمجيات لطباعة عدد الخنازير أيضا؟

يمكننا بالتأكيد. ولكن فقط عندما نقوم بنسخ ولصق هذه الأسطر الأربعة مرة أخرى ، ننتظر قليلاً ونعيد النظر. يجب أن يكون هناك طريقة أفضل للقيام بذلك. محاولتنا الأولى هي:

```text
function printZeroPaddedWithLabel(number, label) {
  let numberString = String(number);
  while (numberString.length < 3) {
    numberString = "0" + numberString;
  }
  console.log(`${numberString} ${label}`);
}

function printFarmInventory(cows, chickens, pigs) {
  printZeroPaddedWithLabel(cows, "Cows");
  printZeroPaddedWithLabel(chickens, "Chickens");
  printZeroPaddedWithLabel(pigs, "Pigs");
}

printFarmInventory(7, 11, 3);
```

الطريقة الجديدة تعمل بشكل جيد. لكن الاسم printZeroPaddedWithLabel يبدو محرجًا بعض الشيء. من الواضح أن ثلاثة أشياء مختلفة - \(printing\) ، و\(zero-padding\) و \(adding a lable\) - يتم خلطها في وظيفة واحدة.

بدلاً من إزالة الجزء المكرر من الجملة لبرنامجنا ، دعنا نحاول اختيار مفهوم واحد.

```text
function zeroPad(number, width) {
  let string = String(number);
  while (string.length < width) {
    string = "0" + string;
  }
  return string;
}

function printFarmInventory(cows, chickens, pigs) {
  console.log(`${zeroPad(cows, 3)} Cows`);
  console.log(`${zeroPad(chickens, 3)} Chickens`);
  console.log(`${zeroPad(pigs, 3)} Pigs`);
}

printFarmInventory(7, 16, 3);
```

إن امتلاك وظيفة باسم جيد وواضح مثل zeroPad سيجعل الأمر أسهل على شخص يريد فهم رمز البرنامج. يمكن استخدامه أيضًا في مواقف أكثر من هذا البرنامج فقط. على سبيل المثال ، يمكنك استخدام هذه الوظيفة لطباعة جدول أرقام جيد المحاذاة.

إلى أي مدى ينبغي أن تكون وظيفتنا ذكية وشاملة؟ يمكننا كتابة أي شيء من وظيفة تؤدي عملية بسيطة للغاية تتمثل في إضافة أحرف إلى محاذاة مكونة من ثلاثة أحرف إلى نظام تنسيق رقم عام معقد قادر على تكوين أرقام عشرية. إدارة السلبيات ومحاذاة النقاط والتباعد بأحرف مختلفة والمزيد.

القاعدة الأساسية هنا هي عدم إضافة المزيد من الذكاء إلى الوظيفة ما لم نتأكد تمامًا من أننا سنستخدمها. قد نميل إلى كتابة \(framework\)عامة لكل عمل صغير نحتاجه. يجب مقاومة هذا الإغراء. وإلا فلن يتحرك البرنامج للأمام وفي النهاية ستكتب الكثير من التعليمات البرمجية التي لن تستخدمها أبدًا.

### Functions and side effects, الاثار الجانبيه للوظائف <a id="pure"></a>

بشكل عام ، يمكن تقسيم الوظائف إلى مجموعتين: تلك التي تم استدعاؤها لآثارها الجانبية وتلك التي تم استدعاؤها للقيمة التي ترجعها. \(على الرغم من أنه يمكن أن يكون لها بالتأكيد وظيفة لها تأثير جانبي وقيمة عائدة\). مثلا :

الوظيفة الإضافية الأولى في مثال المزرعة هي الوظيفة:

تم استدعاء printZeroPaddedWithLabel لتأثيره الجانبي: طباعة سطر على الإخراج. في الإصدار الثاني ، تم استدعاء وظيفة zeroPad للقيمة التي تُرجعها. ليس من قبيل المصادفة أن يتم استخدام الوظيفة الثانية في مواقف أكثر من الوظيفة الأولى. يمكن دمج وظائف إرجاع القيمة بسهولة مع طرق جديدة أكثر من الوظائف التي تؤدي مباشرة إلى آثار جانبية معينة.

الوظيفة pure هي شكل خاص للدالة التي تُرجع قيمة ليس لها آثار جانبية خاصة بها فحسب ، ولكنها أيضًا لا تعتمد على الآثار الجانبية للرموز الأخرى - على سبيل المثال ، تستخدم متغيرات عالمية قد تتغير في رموز أخرى. لا تضع. تتمتع الوظيفة  pure بميزة جيدة وهي أنه إذا تم استدعاؤها باستخدام وسيطات ثابتة ومتشابهة ، فإنها تُرجع دائمًا نفس القيمة \(ولا تتصرف بشكل مختلف\). يمكن اعتبار استدعاء دالة بهذه السمة مساويًا لقيمة الإرجاع دون تغيير معنى رمز البرنامج. عندما لا تكون متأكدًا من التشغيل الصحيح لوظيفة pure  ، يمكنك بسهولة اختبارها عن طريق الاتصال بها ، وإذا كان السياق يعمل بشكل صحيح ، فسيعمل بشكل صحيح على جميع الأنظمة الأساسية. ومع ذلك ، تتطلب الوظائف غير النقية المزيد من الشروط والمتطلبات الأساسية للاختبار.

بالطبع ، لا داعي للشعور بالسوء عند كتابة وظائف ليست نقية أو شن حرب لإزالتها من التعليمات البرمجية الخاصة بك. عادة ما يكون للآثار الجانبية تطبيقات خاصة بها. على سبيل المثال ، لا توجد طريقة خالصة لكتابة نسخة من وظيفة console.log ، ومن الواضح أن console.log مفيد للغاية. يتم توضيح بعض المهام بسهولة أكبر وتكون أكثر فاعلية باستخدام الآثار الجانبية. لذلك ، يمكن أن يكون أحد أسباب عدم استخدام الوظائف البحتة مسألة السرعة الحسابية.

### Summary

علمك هذا الفصل كيفية كتابة الوظائفfunctions الخاصة بك. عند استخدام الكلمة الأساسية للوظيفة كتعبير ، يمكن أن تخلق قيمة دالة.  عند استخدامه كأمر ، فإنه يعلن عن متغير ويعين وظيفة كقيمة له. وظيفة السهم Arrow functions هي طريقة أخرى لإنشاء الوظائف.

```text
// Define f to hold a function value
const f = function(a) {
  console.log(a + 2);
};

// Declare g to be a function
function g(a, b) {
  return a * b * 3.5;
}

// A less verbose function value
let h = a => a % 3;
```

النقطة الأساسية في فهم الوظائف هي فهم مفهوم المجالات. كل كتلة من التعليمات البرمجية تنشئ مجالًا جديدًا. المعلمات والمتغيرات التي تم التصريح عنها داخل الكتلة هي وظائف محلية لها ، ولا يمكن الوصول إليها من خارج الكتلة .      تعمل المتغيرات التي تم إنشاؤها باستخدام الكلمة الأساسية var بشكل مختلف - يصل مداها إلى نهاية مجال أقرب وظيفة أو مساحة عامة للبرنامج.

يعد فصل المهام التي يقوم بها برنامجك بوظائف مختلفة مهمة مفيدة. هذا يتجنب الازدواجية غير الضرورية ويساعد في تنظيم البرنامج عن طريق تصنيفه إلى أقسام متخصصة.

### Exercises

#### Minimum

في الفصل السابق ، تعرفت على دالة Math.min القياسية ، والتي تُرجع أصغر عدد من وسيطات الإدخال. يمكننا برمجة هذا بأنفسنا. اكتب دالة تسمى min تأخذ وسيطتين وتعيد أصغرهما.

```text
// Your code here.

console.log(min(0, 10));
// → 0
console.log(min(0, -10));
// → -10
```

> إذا كنت تواجه مشكلة في وضع الأقواس والأقواس في المكان المناسب للحصول على تعريف دالة صالح ، فابدأ بنسخ أحد الأمثلة في هذا الفصل وتعديله. قد تحتوي الوظيفة على عبارات إرجاع متعددة.



### Recursion

لقد رأينا بالفعل أنه يمكن استخدام عامل التشغيل٪ \(المتبقي\) لتحديد ما إذا كان الرقم زوجيًا أم فرديًا ، حيث تم اختبار قابلية القسمة على 2 باستخدام٪ 2. إليك طريقة أخرى لمعرفة ما إذا كان العدد الصحيح الموجب زوجيًا أم فرديًا:

* Zero is even.
* One is odd.
* For any other number _N_, its evenness is the same as _N_ - 2.

حدد وظيفة isEven الإرجاع وفقًا للوصف أعلاه. يجب أن تتلقى الدالة معلمة موجبة لعدد صحيح وتعيد بعض القيم المنطقية.

اختبر الدالة بقيمتي 50 و 75. تحقق مما يحدث إذا أعطيته -1. لماذا ا؟ هل يمكنك إيجاد طريقة لحل المشكلة؟

```text
// Your code here.

console.log(isEven(50));
// → true
console.log(isEven(75));
// → false
console.log(isEven(-1));
// → ??
```

> من المحتمل أن تكون وظيفتك قريبة من شيء مشابه لوظيفة البحث داخل مثال إرجاع findSolution ، والذي يحتوي على مجموعة if / else if / else التي اختبرت إحدى الحالات الثلاث. آخر ، والذي يرتبط بالحالة الثالثة ، ينفذ عملية رد الاتصال. يجب أن يحتوي كل دليل على عبارة إرجاع أو يوفر بطريقة ما بعض القيمة للمخرجات.

> عندما يتم إعطاء رقم سالب ، تستدعي الوظيفة نفسها مرارًا وتكرارًا برقم سالب أكثر ، لذا فهي تبتعد أكثر فأكثر عن إرجاع النتيجة. في نهاية المطاف نفدت مساحة المكدس وتعطل.

### Bean counting

يمكنك استخدام "سلسلة" \[N\] للحصول على الحرف أو الحرف N من سلسلة. القيمة التي تم إرجاعها عبارة عن سلسلة تتكون من حرف واحد فقط. \(على سبيل المثال السلسلة "ب"\). الحرف الأول في موضع الصفر. لذا فإن الحرف الأخير موجود في السلسلة الطول - 1 الموضع. بمعنى آخر ، تتكون السلسلة المكونة من حرفين من حرفين وتكون أحرفها في الموضعين 0 و 1.

اكتب دالة تسمى countBs تقبل سلسلة باعتبارها الوسيطة الوحيدة لها وتقوم بإرجاع رقم يشير إلى وجود عدة أحرف كبيرة "B" في السلسلة.

بعد ذلك ، اكتب دالة تسمى countChar تعمل بشكل مشابه لـ countBs ولكنها تحصل أيضًا على وسيطة ثانية تحدد الحرف المراد حسابه \(بدلاً من B فقط\). أعد كتابة وظيفة countBs للحصول على هذه الميزة الجديدة.

```text
// Your code here.

console.log(countBs("BBC"));
// → 2
console.log(countChar("kakkerlak", "k"));
// → 4
```

> تحتاج وظيفتك إلى حلقة للتعامل مع كل حرف من أحرف السلسلة. يمكن لهذه الحلقة التمرير من صفر إلى واحد أقل من طول السلسلة \(&lt;string.length\). إذا كان الحرف في الموضع الحالي مساويًا للحرف الذي تبحث عنه الوظيفة ، فإنه يضيف وحدة واحدة إلى متغير العداد. يمكن إرجاع العداد بعد نهاية الحلقة.
>
> حواستان باشد که همه‌ی متغیرهایی که در تابع استفاده می‌شود به صورت _محلی_ در همان تابع به وسیله‌ی `let` یا `const` تعریف شوند.

