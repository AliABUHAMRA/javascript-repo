---
description: >-
  يعتقد الناس أن معرفة الكمبيوتر ومهاراته مخصصة للعباقرة ، ولكن الواقع عكس ذلك ،
  فالكثير من الناس فقط يعملون في إنشاءات بعضهم البعض ،"مثل جدار مصنوع من الحجارة
  الصغيرة." ' Donald Knut'
---

# Functions

![](.gitbook/assets/image%20%283%29.png)



الوظائف هي الخبز والزبدة لبرمجة JavaScript . مفهوم وضع جزء من البرنامج داخل قيمة له استخدامات عديدة. يمكن استخدام هذا المفهوم لبناء تطبيقات أكبر ، وتجنب الازدواجية ، وتسمية الإجراءات الفرعية ، وفصلها بشكل مستقل.

التطبيق الأكثر وضوحًا للوظائف هو تحديد مفردات جديدة. عادة ما يكون إنشاء كلمات جديدة في النثر أسلوبًا سيئًا. لكن في البرمجة ، لا غنى عنه.

به طور معمول، انگلیسی زبانان بزرگسال در دامنه‌ی واژگانشان حدود 20,000 کلمه دارند. هناك عدد قليل من لغات البرمجة التي تحتوي على 20،000 أمر محدد مسبقًا. بالطبع ، يتم أيضًا تحديد هذه الأوامر أو الكلمات المتوفرة بعناية ، مما يؤدي إلى مرونة أقل من اللغات البشرية. لذلك ، نحتاج عادةً إلى تحديد مفاهيم جديدة لتجنب التكرار غير الضروري.

### Defining a function

تعريف الوظيفة هو ارتباط عادي حيث تكون قيمة الربط دالة. على سبيل المثال ، يعرّف هذا الرمز `squre` للإشارة إلى دالة تنتج مربع رقم معين:

```text
const square = function(x) {
  return x * x;
};

console.log(square(12));
// → 144
```

يمكن إنشاء دالة بواسطة تعبير يبدأ بكلمة دالة "function". الوظائف لها مجموعة من المعلمات" _parameters_ "  \(في هذه الحاله فقط , x\)  والجسم الذي يحتوي على العبارات التي سيتم تنفيذها عند استدعاء الوظيفة . يجب أن يكون جسم الوظيفة للوظيفة التي تم إنشاؤها بهذه الطريقة ملفوفًا دائمًا بأقواس. حتى عندما يحتوي على أمر واحد فقط \(كما في المثال السابق\)

يمكن أن تحتوي الوظيفة على معلمات متعددة أو لا تحتوي على معلمات على الإطلاق. في المثال أدناه, ، لا تحتوي وظيفة makeNoise على معلمات بينما تحتوي وظيفة powerعلى معلمتين: 

```text
const makeNoise = function() {
  console.log("Pling!");
};

makeNoise();
// → Pling!

const power = function(base, exponent) {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
};

console.log(power(2, 10));
// → 1024
```

ترجع بعض الدوال قيمًا ، مثل دالات power و squre. وبعض الوظائف مثل makeNoise تنتج آثارًا جانبية فقط ولا ترجع أي قيمة. الأمر المسمى return مسؤول عن إرجاع قيمة من الوظيفة.  . عندما يصل البرنامج إلى هذا الأمر ، فإنه يخرج بسرعة من الوظيفة الحالية ويرسل القيمة "المرتجعة" إلى جزء البرنامج حيث يتم استدعاء الوظيفة. ستؤدي كلمة return بدون تعبير  إلى إرجاع دالة undefined.  الدالات التي لا تحتوي على جملة return على الإطلاق ، مثل makeNoise ، ترجع قيمًا غير محددةundefined.

تتصرف المعامِلات 'Parameters' في الدوال تمامًا مثل المتغيرات العادية ، ولكن يتم تعيين قيمتها الأولية بواسطة منادي الوظيفة ، وليس الرمز المكتوب في جسم الوظيفة.

### Bindings and scopes

لكل متغير نطاق وصول "scope"  ، وهو جزء من البرنامج حيث يمكن الوصول إلى المتغير ومرئيًا. بالنسبة للمتغيرات التي تم تحديدها خارج دالة أو كتلة ، يغطي هذا المجال البرنامج بأكمله - يمكنك الوصول إلى هذه المتغيرات في أي مكان في البرنامج. هذه المتغيرات تسمى المتغيرات global.

لكن المتغيرات التي تم إنشاؤها لمعلمات الوظيفة أو تلك التي تم تحديدها داخل دالة لا يمكن الإشارة إليها إلا ضمن هذه الوظيفة ، ومن ثم يطلق عليها المتغيرات المحلية. في كل مرة يتم استدعاء دالة ، يتم إنشاء مثيلات جديده  لهذه المتغيرات.  يؤدي هذا إلى عزل الوظائف إلى حد ما عن بعضها البعض - تعمل كل استدعاء دالة في مساحتها الخاصة \(البيئة المحلية الخاصة بها\). وعادة ما يمكن فهم طريقة العمل هذه من البرنامج ولا نحتاج إلى معرفة التفاصيل المتعلقة بها في البيئة العالمية. 

الارتباطات المعلنة بـ let و const هي في الواقع محلية للكتلة التي تم الإعلان عنها فيها. لذلك إذا حددت إحداها داخل حلقة ، فلن يتمكن الكود قبل وبعد الحلقة "رؤيتها". في إصدارات ما قبل 2015 من JavaScript ، كانت هناك وظائف فقط يمكنها إنشاء منطقة أو مجال جديد ، لذا فإن المتغيرات القديمة ، المحددة بواسطة var ، شوهدت في الوظيفة التي تم تحديدها من خلالها. إذا لم يكونوا ضمن وظيفة ، فقد كانوا متاحين في جميع أنحاء التطبيق.

```text
let x = 10;
if (true) {
  let y = 20;
  var z = 30;
  console.log(x + y + z);
  // → 60
}
// y is not visible here
console.log(x + z);
// → 40
```

يمكن لكل عالم أن يرى العالم من حوله ، على سبيل المثال في البرنامج أعلاه ، المتغير x مرئي داخل الكتلة. يحدث استثناء هنا عندما يكون هناك العديد من المتغيرات التي تحمل نفس الاسم ، وفي هذه الحالة يمكن لرمز البرنامج رؤية العنصر الأعمق. على سبيل المثال ، في دالة halve للمثال أدناه ، عندما يشير الكود الموجود داخل الدالة إلى المتغير n ، يتم استخدام المتغير n للدالة نفسها ، وليس المتغير العام n.

```text
const halve = function(n) {
  return n / 2;
};

let n = 10;
console.log(halve(100));
// → 50
console.log(n);
// → 10
```

### Nested scope

لا تميز JavaScript فقط بين المتغيرات العامة والمحلية.يمكن إنشاء الكتل والوظائف داخل الكتل والوظائف الأخرى ، مما يؤدي إلى إنشاء درجات متفاوتة من الموقع.

على سبيل المثال ، هذه الوظيفة - التي تُرجع المكونات اللازمة لتحضير حمص \(نوع من الطعام\) - له وظيفة أخرى بداخله:

```text
const hummus = function(factor) {
  const ingredient = function(amount, unit, name) {
    let ingredientAmount = amount * factor;
    if (ingredientAmount > 1) {
      unit += "s";
    }
    console.log(`${ingredientAmount} ${unit} ${name}`);
  };
  ingredient(1, "can", "chickpeas");
  ingredient(0.25, "cup", "tahini");
  ingredient(0.25, "cup", "lemon juice");
  ingredient(1, "clove", "garlic");
  ingredient(2, "tablespoon", "olive oil");
  ingredient(0.5, "teaspoon", "cumin");
};
```

يمكن للرمز الموجود داخل وظيفة  `ingredient` رؤية ملف  `factor`  ملزمة من الوظيفة الخارجية.            لكن المتغيرات المحلية تشبه unit او  ingredientAmount لا يمكن رؤيتها بواسطة الوظيفة الخارجية.

تعتمد مجموعة المتغيرات المرئية داخل الكتلة على موقع الكتلة في نص البرنامج. يمكن لكل مجال محلي أيضًا رؤية المجالات المحلية التي تحيط به ، ويمكن لجميع المجالات رؤية المجال العام. هذه الطريقة للرؤية المتغيرة تسمى النطاق المعجمي\(Lexical Scoping\).

### Functions as values

عادة ما يلعب المتغير المخصص لوظيفة ما دور اسم جزء من البرنامج. يتم تعريف هذه المتغيرات مرة واحدة ولا تتغير. قد يتسبب هذا في الخلط بين اسم الوظيفة والدالة نفسها.

لكن الاثنين مختلفان. يمكن لقيمة الدالة أن تفعل كل الأشياء التي يمكن للقيم الأخرى القيام بها - يمكنك استخدامها في تعبيرات عشوائية ، وليس مجرد تسميتها. يمكن تخزين قيمة الوظيفة في متغير جديد ، وتمريرها كوسيطة إلى دالة ، وما إلى ذلك.أيضًا ، لا يزال المتغير الذي يحتوي على دالة مجرد متغير عادي ، ويمكن تخصيص قيمة جديدة له إذا لم يتم تعريفه على أنه ثابت. فمثلا:

```text
let launchMissiles = function() {
  missileSystem.launch("now");
};
if (safeMode) {
  launchMissiles = function() {/* do nothing */};
}
```

في الفصل الخامس ، سنناقش بعض الأشياء الشيقة التي يمكن القيام بها عن طريق تمرير الدوال كقيم إلى وظائف أخرى.

### Declaration notation

هناك طريقة أقصر لتعريف الوظيفة. إذا تم استخدام الكلمة الأساسية للوظيفة في بداية العبارة ، فسيكون لها معنى مختلف.

```text
function square(x) {
  return x * x;
}
```

تحدد هذه الطريقة وظيفة بإعلان. يعرّف هذا الأمر متغيرًا يسمى مربعًا ويخصصه لوظيفة معينة. يبدو تحديد وظيفة بهذه الطريقة أبسط قليلاً وليس من الضروري استخدام فاصلة بعد تحديد الوظيفة.

في هذه الطريقة لتحديد الوظيفة ، هناك نقطة دقيقة يجب أخذها في الاعتبار.

```text
console.log("The future says:", future());

function future() {
  return "You'll never have flying cars";
}
```

يعمل الكود أعلاه بشكل جيد على الرغم من أن تعريف الوظيفة أقل من السطر الذي يستدعيها. وذلك لأن إعلانات الوظائف في JavaScript لا تعتبر جزءًا من تدفق التحكم العادي من أعلى إلى أسفل للبرنامج. من الناحية المفاهيمية ، يتم نقلهم إلى الجزء العلوي من المجال الخاص بهم ويمكن استخدامها في جميع التعليمات البرمجية في هذا المجال. هذه الميزة مفيدة في بعض الأحيان لأنها تمنحنا حرية تنظيم الكود بحيث يتم تنظيمه بشكل أفضل دون الحاجة إلى القلق بشأن تحديد وظائفنا قبل استدعائها.

### Arrow functions

هناك طريقة ثالثة لتعريف الوظائف ، والتي تبدو مختلفة جدًا عن الطرق السابقة. بدلاً من استخدام الكلمة الأساسية للوظيفة ، يتم استخدام سهم \(&lt;=\) يتكون من رمز يساوي وأكبر. \(يجب عدم الخلط بينه وبين عامل أكبر من أو يساوي ، مكتوبًا كـ &gt; =\) 

```text
const power = (base, exponent) => {
  let result = 1;
  for (let count = 0; count < exponent; count++) {
    result *= base;
  }
  return result;
};
```

يأتي حرف السهم مباشرة بعد قائمة المعلمات ، وبعد ذلك سيأتي جسم الوظيفة. يمكن تفسيره بطريقة "ينتج عن هذا المدخل \(هذه المعلمات\) هذه النتيجة \(جسم الوظيفة\)". 🌠 مهم

عندما يكون هناك معامل واحد فقط ، يمكنك تخطي الأقواس. إذا كان نص الوظيفة يحتوي على تعبير واحد فقط ، وليس كتلة محاطة بأقواس ، فسيتم إرجاع هذا التعبير بواسطة الوظيفة. . لذا فإن كلا الطريقتين لتعريف الدالة التربيعية تفعل الشيء نفسه:

```text
const square1 = (x) => { return x * x; };
const square2 = x => x * x;
```

عندما تفتقر وظيفة السهم\(arrow function\) إلى معلمة ، تتم كتابة قائمة المعلمات الخاصة بها كزوج من الأقواس الفارغة. 

```text
const horn = () => {
  console.log("Toot");
};
```

لا يمكن العثور على سبب قوي للحاجة إلى كلا النوعين من تعريفات الوظائف \(طريقة السهم والروتين\) بصرف النظر عن القضايا الثانوية \(التي تمت مناقشتها في الفصل 6\) ، كلاهما يفعل الشيء نفسه. تمت إضافة طريقة السهم إلى اللغة في إصدار 2015 ؛ في الغالب لأن الوظائف يمكن كتابتها في شكل أقصر وأكثر إيجازًا وتجنب الكتابة فوقها. سنستخدمها كثيرًا في الفصل الخامس.

### The call stack <a id="stack"></a>

يعد تدفق التحكم في البرنامج أكثر تعقيدًا في الوظائف. من المناسب إلقاء نظرة فاحصة على كيفية تدفق التحكم في الوظائف. إليك برنامج بسيط يحتوي على العديد من استدعاءات الوظائف:

```text
function greet(who) {
  console.log("Hello " + who);
}
greet("Harry");
console.log("Bye");
```



















