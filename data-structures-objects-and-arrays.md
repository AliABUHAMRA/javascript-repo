# Data Structures: Objects and Arrays

الأرقام، القيم المنطقية, والسلاسل النصية هي بمثابة الطوب التي تبنى به هيكلة البيانات Data structure, لكن بطبيعة الحال لا يمكنك بناء منزل كامل من آجرة أو طوبة واحدة، فالكائنات تسمح لنا بتحميع القيم بما فيها كائنات أخرى مع بعض مما يسمح لنا ببناء هياكل أكثر تعقيدا.

البرامج التي قمنا بصناعتها إلى حد الساعة تعرضت للعرقلة بشدة بسبب حقيقة عملها و اعتمادها على أنواع البيانات البسيطة فقط، هذا الفصل سيضيف مفاهيم أساسية حول هياكل البيانات إلى أدواتك، بعد انتهاءك من هذا الفصل ستكون قادرا على صناعة بعض البرامج المفيدة.

يعمل الفصل على تقديم أمثلة برمجية أكثر أو أقل واقعية، وتقديم المفاهيم التي تنطبق على المشكلة المطروحة الأمثلة البرمجية ستكون في وظائف و متغيرات والتي تم التطرق اليها من قبل.

## الويريسكويرل <a id="&#x627;&#x644;&#x648;&#x64A;&#x631;&#x64A;&#x633;&#x643;&#x648;&#x64A;&#x631;&#x644;"></a>

من حين إلى آخر و عادة من التاسعة إلى العاشرة مساء يجد جاك نفسه قد تحول إلى قارض صغير مع ذيل كثيف.

من ناحية أخرى فجاك مسرور لعدم ابتلائه بالليكانثروب الكلاسيكية، فالتحول إلى سنجاب أقل تسببا بالمشاكل من التحول إلى ذئب.فبدل شعوره بالقلق حيال أكل جيرانه \(هذا سيكون غريبا\) هو يقلق من أكل قط الجيران له، فبعد مناسبتين من استيقاظه على غصن رقيق و غير مستقر على شجرة البلوط عاريا و مشوش الفكر قرر غلق الأبواب و النوافذ أثناء الليل ووضع بضع الجوز على الأرض لإبقاء نفسه مشغولا

![&#x627;&#x644;&#x648;&#x64A;&#x631;&#x64A;&#x633;&#x643;&#x648;&#x64A;&#x631;&#x644;](http://eloquentjavascript.net/img/weresquirrel.png)

هذا كفيل بتجنب مشاكل القط و البلوط، ولكن جاك مازال يعاني من حالته، ظهور هذا التغير الشاذ جعله يفكر في أن هذه الحادثة قد تكون ناجمة عن شيء ما لفترة كان يعتقد أن هذا التغير كان يحدث فقط في الأيام التي يلامس فيها الأشجار فقرر التوقف عن ملامستهم أو حتى الإقتراب منهم ولكن المشكلة ظلت تلاحقه.\]\(10613180113 ثم تحول الأمر إلى نهج أكثر علمي فقرر جاك تسجيل سجل يومي لجميع مايفعله في ذلك اليوم و ماإذا كان سيتحول أو لا ، مع هذه البيانات كان يأمل جاك في تضييق الظروف التي تسبب التحول باستمرار والتي من شأنها أن تسبب هذا التحول.

## تعيين البيانات <a id="&#x62A;&#x639;&#x64A;&#x64A;&#x646;-&#x627;&#x644;&#x628;&#x64A;&#x627;&#x646;&#x627;&#x62A;"></a>

للعمل مع قطعة بيانات رقمية، علينا أولا ايجاد طريقة لتمثيلها على ذاكرة الجهاز، فلنفرض مثلا أننا نريد تمثيل مجموعة من الأعداد : 2, 3, 5, 7, و 11.

يمكننا أن نستخدم السلاسل النصية ، فبعد كل شيء السلاسل النصية يمكنها أخذ أي طول، و هذا ما يمكننا من وضع الكثير من البيانات داخلها، فنضعها على هذا الشكل "2 3 5 7 11" كما هو مبين في المثال. ولكن هذا غريب نوعا ما ، لأنه سيكون عليك استخراج الأرقام بطريقة ما وتحويلها مرة أخرى إلى أرقام حتى يتسنى لك الوصول إليها.

لحسن الحظ، فجافاسكربت تتوفر على نوع بيانات مخصص لتخزين سلاسل من القيم، يدعى هذا النوع بالمصفوفة ويكتب على شكل قائمة من القيم بين معقوفتين مفصولة بفواصل.

```text
var listOfNumbers = [2, 3, 5, 7, 11];
console.log(listOfNumbers[1]);
// → 3
console.log(listOfNumbers[1 - 1]);
// → 2
```

  
ملاحظة لا علاقة لها بترجمة الكتاب : صديقي من يقوم بترجمة هذا الجزء لقد قمت بأخد الجزء على عاتقي لترجمته و هذا ما اتفقنا عليه في المجتمع لهذا اذا اردت في متابعة الجزء معي أرجو أن تقوم بالتحدث معي لكي نقوم بالتنسيق فيما بيننا و لاتضيع جهودنا سدى لأنني قمت بترجمة هذه المقدمة ثم وجدت أنك قد ترجمتها مسبقا . انا اسمي omar sh

الترميز الذي يمكن من خلاله الوصول إلى داخل المصفوفة يمكن أن يكون باستخدام الأقواس المربعة \[\]، زوج من الأقواس المربعة مباشرة بعد الصيغة \(اسم المصفوفة\) مع صيغة أخرى داخل هذه الأقواس وهي رقم العنصر علماً أن البحث عن العنصر يبدأ من اليسار لليمين حتى يجد العنصر الذي تبحث عنه من خلال الرقم الذي تضعه الأقواس.

  
العنصر الأول من المصفوفة هو الصفر و ليس واحد، وبالتالي سيكون العنصر الأول من المصفوفة يمكن قراءته هكذا listOfNumbers\[0\] ، اذا لم تكن تملك خلفية برمجية هذا لن يكون مقنعاً بالنسبة لك لكن الصفر سيبقى قاعدة أساسية في علم البرمجة و ستتعود عليه مع مرور الوقت.  


**الخصائص :**

رأينا مسبقاً بعض الشبهات في بعص الصيغ البرمجية مثل mystring.length لكي تحصل على طول السلسة \) و \(Math.max\) لتحصل على القيمة الأعظمية في الأمثلة الماضية. و قد كانت هذه الصيغ لكي تقوم بالدخول إلى خاصية تابعة لقيمة معينة. في الحالة الأولى مثلاً كانت من أجل الدخول إلى خاصية ال \(length\) في قيمة السلسة myString. و الحالة الثانية ستقوم بالدخول إلى خاصية اسمها max في الكائن المسمى Math و الذي يحتوي على العديد من الدوال الرياضية.

تقريباً كل قيم الجافا سكربت تملك خصائص. إلا الاستثناء null و undefined فإذا حاولت الولوج إلى خصائص إحدى هذه القيم ستحصل على خطأ برمجي، حيث أن null و undefined تعني لا شيء

```text
null.length;
// → TypeError: Cannot read property 'length' of null
```

أكثر طريقتين شائعتين للولوج إلى الخصائص في الجافا سكربت تكون من خلال النقط أو من خلال الأقواس المربعة حيث يمكنك أن تكتب \[value\[x و يمكنك أن تكتب value.x و بهذا يمكنك الولوج إلى خاصية العنصر value، مع العلم أن ما بعد النقطة يجب أن يكون اسم متغير مُعرَف سابقاً و موجود.

اذاً إذا كنت تعرف أن الخاصية المهتم بإستدعائها هيlength تقول value.length و اذا أردت أن تنسخ اسم الخاصية بحسب القيمة الموجودة في المتغير i تقول \[value\[i. و لأن أسماء الخواص ممكن أن تكون أي سلسلة \(string\) اذا أردت الوصول إلى خاصية اسمها "2" او خاصية اسمها “john Doe” لابد أن تستخدم الأقواس المربعة \[value\[2 و \["value\[“john Doe لإنك حتماً لن تستطيع استخدام طريقة النقطة مع الأرقام أو مع السلاسل التي يرافقها فراغات \(spaces\) كما أن "2" و "“john Doe ليست أسماء متغيرات صحيحة\(أي أنها غير موجودة افترضياً في لغة حافا سكربت\) لهذا لا يمكن الولوج إليهما من خلال ترميز النقطة .

العناصر في المصفوفة تخزن في خواص، حيث أن أسماء هذه الخواص هم أرقام و عادة نحتاج إلى الحصول عليهم من خلال متغير، علينا أن نستخدم القوسين المربعين للولوج إليهم. أما بالعودة إلى خاصية length \(خاصية لمعرفة طول السلاسل و المصفوفات\) التي تخبرنا كم عنصر موجود في المصفوفة ، و بما أن length هي اسم متغير صحيح موجود في الجافا سكربت و بما أننا نعلمها مسبقاً بالتالي يمكننا الولوج إلى هذه الخاصية من خلال array.length ، طبعا يمكننا الولوج إليها من خلال الأقواس \["array\[“length لكن لا نستخدم هذه الطريقة لأنها طويلة على عكس الطريقة الأولى.  


**Methods**:

كلا السلاسل و المصفوفات تحتوي على خاصية معرفة الطول \(length\), باالاضافه الى عدد من الخصائص التي تحتوي على قيم دالة..

```text
var doh = "Doh";
console.log(typeof doh.toUpperCase);
// → function
console.log(doh.toUpperCase());
// → DOH
```

كل سلسلة  تملك خاصية toUpperCase, عند استدعائه ، سيعيد نسخة من السلسلة التي تم فيها تحويل جميع الأحرف إلى أحرف كبيرة.. هناك أيضاً خاصية toLowerCase يمكنك أن تحزر بنفسك ماذا تفعل. المثير للاهتمام، أن خاصية toUpperCase لا تأخذ أيِ قيم لكنها تستطيع الوصول إلى السلسة "Doh" ، هذه الخاصية سنقوم بشرحها بشكل تفصيلي  [الفصل السادس](https://alihhmmre-a.gitbook.io/alijavascript/6#obj_methods) , الخواص التي تحتوي على دوال نطلق عليها \(methods\) حيث أن toUpperCase هي method للسلاسل. هذا المثال يوضح بعض ال methods التي تحتويها كائن المصفوفة :

```text
let sequence = [1, 2, 3];
sequence.push(4);
sequence.push(5);
console.log(sequence);
// → [1, 2, 3, 4, 5]
console.log(sequence.pop());
// → 5
console.log(sequence);
// → [1, 2, 3, 4]
```

طريقه  ال push تقوم بإضافة قيمة إلى نهاية المصفوفة. ال pop تقوم بالعكس تماماً حيث تقوم بحذف آخر عنصر في المصفوفة و يعيدها.  

لطالما استخدمت أسماء هاتين الطريقتين في الأعمال المتعلقة بال stack . ال stack  ، في البرمجة ، هو هيكل بيانات يسمح لك بدفع القيم فيه وإخراجها مرة أخرى بالترتيب المعاكس بحيث تتم إزالة الشيء الذي تمت إضافته مؤخرًا أولاً. هذه شائعة في البرمجة - قد تتذكر stack استدعاء الوظيفة من  [الفصل السابق](https://alihhmmre-a.gitbook.io/alijavascript/functions#stack) ، وهو مثال على نفس الفكرة.

### Objects

دعنا نعود إلى مثال الرجل السنجاب squirrel. يمكن تمثيل مجموعة من التقارير اليومية كمصفوفة. لكن التقارير ليست مجرد سلاسل أو أرقام - يجب أن يخزن كل تقرير قائمة بالأنشطة ذات قيمة منطقية تشير إلى ما إذا كان جاك قد أصبح سنجابًا ام لا. من الناحية المثالية ، نود تجميع هذه المعلومات معًا وإنشاء قيمة وتخزين تلك القيم المجمعة في مصفوفه من التقارير.

قيم object لها مجموعة من الخصائص المطلوبة. إحدى طرق إنشاء كائن هي استخدام الأقواس كتعبير.

```text
var day1 = {
  squirrel: false,
  events: ["work", "touched tree", "pizza", "running",
           "television"]
};
console.log(day1.squirrel);
// → false
console.log(day1.wolf);
// → undefined
day1.wolf = false;
console.log(day1.wolf);
// → false
```

داخل هذه الأقواس، نستطيع إعطاء مجموعة من الخصائص وبين كل خاصية وخاصية هناك فاصلة، وكل خاصية مكتوبة  كا اسم وملحوقة بنقطتين ثم الصيغة التي تعطي لهذه الخاصية القيمة الخاصة بها. طبعاً لا حاجة للفراغات والأسطر الزائدة إنما هي موجودة في المثال السابق فقط لتجعل عملية القراءة أسهل وأسرع. الخصائص التي أسمائها ليست متغيرات وأرقام صحيحة يجب أن تكون موضوعة ضمن علامتي تنصيص.

```text
var descriptions = {
  work: "Went to work",
  "touched tree": "Touched a tree"
};
```

هذا يعني أن الأقواس المعكوفة  {}  لها اثنين معاني  في لغة الجافا سكربت، الأول إن كانت في البداية فهي تعني أنها ستأخذ مجموعة من الجمل البرمجية و في أي موضع آخر لها فإنها تعني أنها ستصف كائن \(object\). لحسن الحظ هذه الأقواس لا تُستخدَم عادة لنبدأ بها كتابتنا لغة جافا سكربت في البرامج الاعتيادية، لهذا لن تجد الكثير من الغموض أو الصعوبة في استخدام هذه الأقواس. قراءة خاصية ليست موجودة ستنتج قيمة \(undefined\)، والتي تحدث عندما نحاول قراءة الخاصية wolf في المثال السابق. من الممكن أن تعين قيمة لخاصية ما باستخدام اشارة =، سيكون هذا كفيلاً بتغيير قيمة الخاصية في الكائن اذا كانت الخاصية موجوداً مسبقاً أو إنشاء خاصية جديدة في الكائن اذا كانت الخاصية ليست موجودة.  
بالعودة إلى موديل الأرجل المترابطة الخاصة بالمتغيرات، ارتباط الخصائص هو نفسه. حيث أنهم يربطون القيم، وقد تحمل الخصائص المتغيرات الأخرى نفس القيم، يمكن أن تفكر بالكائنات كأخطبوط مع عدد من الأرجل، كل من هذه الأرجل لها اسم منقوش عليها.

  
عامل الـ delete يقوم بقطع رجل من أرجل الأخطبوط. حيث أنه عامل أحادي حينما يتم تطبيقه على إحدى الخصائص في الكائن، سيقوم بحذف الخاصية المطلوبة من الكائن. هذا ليس شائعاً، لكنه ممكن. ملاحظة: ستتعرف قريباً على معنى العنصر الأحادي و العنصر الثنائي.

```text
var anObject = {left: 1, right: 2};
console.log(anObject.left);
// → 1
delete anObject.left;
console.log(anObject.left);
// → undefined
console.log("left" in anObject);
// → false
console.log("right" in anObject);
// → true
```

العامل الثنائي in، حينما يتم تطبيقه على سلسلة وكائن سيقوم بإرجاع قيمة بوليانية \(0 أو 1\) التي تحدد فيما إذا كان الكائن يحتوي على تلك الخاصية أو لا. الفرق بين تعيين الخاصية إلى undefined وحذفها هو أنه في الحالة سيحتوي الكائن على تلك الخاصية، لكن إن بحثت في تلك الخاصية ستجدها فارغة أي لا تحوي أيِ قيم، أما الحالة الثانية فإن الخاصية لم تعد موجودة أصلاً في الكائن وبالتالي فإن العامل in سيقوم بإرجاع 0 أو false بالعودة إلى العامل الأحادي والعامل الثنائي ما الفرق بينهما: الفرق بسيط جداً حيث أن العامل الأول لا يأخذ إلا معامل واحد قد تجدها قبل أو بعد الصيغة مثل .  
Delete x نلاحظ أن delete لا تأخذ إلا معامل واحد فقط. يمكنك أن تعرف بنفسك ما معنى العامل الثنائي. المصفوفات هي نوع من الكائنات التي تخزن سلسلة من الأشياء، فإذا كتبت في بيئة الجافا سكربت هذا الجملة typeof\[1,2\] ستلاحظ أن البرنامج سيرجع لك object وبالتالي فإن الجافا سكربت تعتبر المصفوفة نوع من أنواع الكائنات. يمكنك أن ترى الصورة في الأسفل كيف أن أرجل الأخطبوط مرتبة في صف واحد و مرقمة  
!\)\]arr\]uu.jpg\)

```text
var journal = [
  {events: ["work", "touched tree", "pizza",
            "running", "television"],
   squirrel: false},
  {events: ["work", "ice cream", "cauliflower",
            "lasagna", "touched tree", "brushed teeth"],
   squirrel: false},
  {events: ["weekend", "cycling", "break",
            "peanuts", "beer"],
   squirrel: true},
  /* and so on... */
];
```

### Mutability

سوف نصل إلى البرمجة الحقيقية قريبا. قبل ذلك ، هناك جزء آخر من النظرية يحتاج إلى فهم.

لقد لاحظنا حتى الآن أنه يمكن تغيير كمية الأشياء. كانت أنواع القيم التي ناقشناها في الفصول السابقة ، مثل الأرقام والسلاسل والقيم المنطقية ، جميعها غير قابلة للتغيير. من المستحيل تغيير بعض أنواع البيانات هذه. يمكنك دمجها لإنشاء قيم جديدة ، ولكن إذا حصلت على قيمة سلاسل معينة ، فستظل القيمة كما هي دائمًا. لا يمكن تغيير النص الموجود بالداخل. إذا كان لديك سلسلة تحتوي على القيمة "cat" ، فلا يمكن لرمز البرنامج تغيير حرف منه إلى "rat" مثلاً. 

يمكن تغيير محتوى قيمة نوع الكائن من خلال خصائصه. هذا يتسبب في أن يكون للكائن محتوى مختلف في أوقات مختلفة.

عندما يكون لدينا رقمان ، على سبيل المثال 120 و 120 ، يمكننا اعتبار كلاهما نفس الرقم تمامًا ، بغض النظر عما إذا كانا مرتبطين بنفس البتات المادية أم لا. لكن في الكائنات ، هناك فرق بين وجود مرجعين لنفس الكائن وبين وجود كائنين مختلفين لهما خصائص متشابهة. لاحظ الرموز التالية:

```text
let object1 = {value: 10};
let object2 = object1;
let object3 = {value: 10};

console.log(object1 == object2);
// → true
console.log(object1 == object3);
// → false

object1.value = 15;
console.log(object2.value);
// → 15
console.log(object3.value);
// → 10
```

يشير المتغيران object1 و object2 إلى نفس الكائن ، لذا فإن تغيير object1 يغير أيضًا قيمة object2. يقال أن الاثنين لهما نفس الهوية. يشير متغير object3 إلى كائن آخر له خصائص مشابهة لـ object1 ولكنه يقع في مساحة مختلفة.

يمكن أيضًا أن تكون المتغيرات ثابتة أو غير ثابتة ، لكن هذا لا علاقة له بسلوك قيمها. على الرغم من أن قيمة الرقم غير قابلة للتغيير ، إلا أنه يمكنك استخدام متغير محدد بواسطة let لتغيير الرقم الذي يشير إليه المتغير. وبالمثل ، على الرغم من أنه لا يمكن تغيير الثابت المحدد بواسطة const لكائن وسيشير دائمًا إلى نفس الكائن ، يمكن تغيير محتوى هذا الكائن.

```text
const score = {visitors: 0, home: 0};
// This is okay
score.visitors = 1;
// This isn't allowed
score = {visitors: 1, home: 1};
```

عامل التشغيل ==  JavaScript ، عند استخدامها لمقارنة الكائنات ، فإنها ترجع true فقط إذا كان كلا الكائنين بنفس القيمة تمامًا. عند المقارنة بين كائنات مختلفة ، حتى عندما يكون محتواها واحدًا ، ينتج عن ذلك false. في JavaScript ، لا يوجد عامل مقارنة متعمق يمكنه فحص ومقارنة محتويات الكائنات. لكن يمكنك كتابتها بنفسك \(سيكون هذا أحد التدريبات في نهاية هذا الفصل\).

### The lycanthrope’s log

حسنا ، بدأ جاك  برنامج مترجم جافا سكريبت الخاص به وقام بتوفير البيئة التي يحتاجها لكتابة تقرير يومي..

```text
let journal = [];

function addEntry(events, squirrel) {
  journal.push({events, squirrel});
}
```

لاحظ أن الكائن المضاف إلى المجلة يبدو غير عادي بعض الشيء.  بدلاً من كتابة الخاصية   `events: events` ، تتم كتابة اسم الخاصية فقط.هذا الأمر القصير مكافئ للطريقة المعتادة - إذا كان في طريقة تعريف كائن ما بالأقواس ، يتم كتابة اسم الخاصية دون تحديد قيمتها ، يتم أخذ قيمتها من متغير يحمل نفس الاسم.

لذلك كل ليلة في الساعة العاشرة - أو أحيانًا في صباح اليوم التالي ، بعد النزول من الرف العلوي لمكتبته - يسجل جاك ذلك اليوم.

```text
addEntry(["work", "touched tree", "pizza", "running",
          "television"], false);
addEntry(["work", "ice cream", "cauliflower", "lasagna",
          "touched tree", "brushed teeth"], false);
addEntry(["weekend", "cycling", "break", "peanuts",
          "beer"], true);
```

عندما تتوفر معلومات كافية ، ينوي حساب العلاقة بين تحوله إلى سنجاب وما حدث في ذلك اليوم ، ويأمل في الحصول على رؤى مفيدة من هذه الارتباطات. 

الارتباط هو مقياس لتحديد درجة الاعتماد بين المتغيرات الإحصائية. المتغير الإحصائي لا يشبه المتغيرات في لغات البرمجة. في الإحصاء ، عادة ما يكون لديك مجموعة من المقاييس ، ويتم قياس كل متغير بكل المقاييس.  عادة ما يتم إنتاج الارتباط بين المتغيرات في شكل معامل بين 1 - إلى 1 . معامل الارتباط صفر يعني أن متغيرين لا علاقة لهما ببعضهما البعض ، ومعامل الارتباط لأحدهما يعني ارتباطًا كاملاً بين متغيرين - إذا كنت تعرف أحدهما ، يمكنك الحصول على الآخر. واحد سالب \(1-\) يعني أيضًا العلاقة الكاملة بين متغيرين ولكن بشكل عكسي - عندما يكون أحدهما صحيحًا والآخر خطأ.

لحساب مقياس الارتباط بين متغيرين منطقيين ، يمكننا استخدام معامل فاي \(phi  \(_ϕ_ب , هذا المعامل هو صيغة يكون مدخلها عبارة عن جدول تكراري لعدد المرات التي لوحظت فيها توليفات مختلفة من متغيرين. ناتج الصيغة هو رقم بين 1- و 1 يشير إلى درجة الارتباط.

يمكننا النظر في حدث تناول البيتزا ووضعها في جدول التردد على النحو التالي ، حيث يمثل كل رقم عدد المرات التي حدثت فيها المجموعة التي نريدها:



![Eating pizza versus turning into a squirrel](http://eloquentjs.ir/img/pizza-squirrel.svg)

إذا سمينا ذلك الجدول n يمكننا الحساب  _ϕ_ تحسب بالصيغة التالية:



<table>
  <thead>
    <tr>
      <th style="text-align:left"><em>&#x3D5;</em> =</th>
      <th style="text-align:left">
        <p><em>n</em>11<em>n</em>00 &#x2212; <em>n</em>10<em>n</em>01&#x221A;</p>
        <p> <em>n</em>1&#x2022;<em>n</em>0&#x2022;<em>n</em>&#x2022;1<em>n</em>&#x2022;0</p>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

\(إذا كنت تغلق الكتاب لتذهب إلى الذكريات المروعة لكتاب الرياضيات المدرسي في المدرسة الثانوية ، انتظر! لن أزعجك بالصيغ الغريبة في هذا الكتاب - في الوقت الحالي ، هناك صيغة واحدة كافية. لهذا السبب ، كل ما علينا فعله هو تحويله إلى JavaScript.\)

يشير الرمز n01 إلى عدد القياسات التي تفيد بأن المتغير الأول \(السنجاب\) خاطئ أو 0 والقياس الثاني \(البيتزا\) صحيح \(1\). في هذا المثال ، n01 يساوي 9.

قيمة n1 • تساوي مجموع جميع القياسات التي يقدر المتغير الأول أنها صحيحة ، والتي في هذا المثال هي 5. وبالمثل ، يشير n • 0 إلى مجموع القياسات التي يكون المتغير الثاني فيها خاطئًا.

بالنسبة لجدول البيتزا ، يتم خصم الجزء العلوي من الكسر أو الوجه 1 × 76−4 × 9 = 40 ومقام الكسر يساوي الجذر الثاني 5 × 85 × 10 × 80 أو √340000 ... وهو 0000 ≈ 0.069 وهو رقم كبير جدًا إنها صغيرة. يبدو أن تناول البيتزا ليس له أي تأثير على تحويل جاك إلى سنجاب.

### Computing correlation

في JavaScript يمكننا تمثيل جدول اثنين في اثنين مع مصفوفة من أربعة عناصر \[76 ، 9 ، 4 ، 1\]. بالطبع ، يمكن القيام بذلك بطرق أخرى أيضًا. استخدم مصفوفة تتكون من صفيفين من خليتين \(\[\[76 ، 9\] ، \[4 ، 1\]\]\) أو كائنًا بخصائص مثل "11" و "01", ولكن من الأسهل استخدام مصفوفة مسطحة وتجعل التعبيرات التي نكتبها للوصول إلى خلايا الصفيف أقصر. تعتبر خلايا المصفوفة بتتين ثنائيتين حيث يمثل الرقم الأيسر \(الرقم الأكثر قيمة\) متغير القياس ويمثل الرقم الأيمن \(الأقل قيمة\) متغير الحدث. على سبيل المثال ، يشير الرقم الثنائي 10 إلى حالة أصبح فيها جاك سنجابًا ولكن الحدث المطلوب \(على سبيل المثال ، تناول البيتزا\) لم يحدث. لقد حدث هذا أربع مرات ، ولأن الرقم الثنائي 10 في النظام العشري يساوي 2 ، سنخزن هذا الرقم في الخلية 2 من المصفوفة.

الدالة التالية تحسب القيمة ϕ من المصفوفة أعلاه:

```text
function phi(table) {
  return (table[3] * table[0] - table[2] * table[1]) /
    Math.sqrt((table[2] + table[3]) *
              (table[0] + table[1]) *
              (table[1] + table[3]) *
              (table[0] + table[2]));
}

console.log(phi([76, 9, 4, 1]));
// → 0.068599434
```

الكود أعلاه هو في الواقع ترجمة مباشرة لصيغة الحساب  _ϕ_ إلى جافا سكريبت. تحسب الدالة Math.sqrt الجذر الثاني للرقم الذي يوفره الكائن الرياضي في بيئة JavaScript القياسية. للحصول على حقول مثل n1 • نحتاج إلى إضافة حقلين من الجدول معًا لأن مجموع الصفوف أو الأعمدة لا يتم تخزينه مباشرةً في بنية البيانات الخاصة بنا.

استمر جاك في التسجيل يوميًا لمدة ثلاثة أشهر. يمكن الحصول على مجموعة البيانات التي تم الحصول عليها في قسم الكود في هذا الفصل. يتم تخزين هذه البيانات في المتغير JOURNAL الذي يمكن تنزيل ملفه.

لاستخراج جدول اثنين في اثنين لحدث معين من المجلة اليومية ، نحتاج إلى التمرير عبر جميع السجلات وحساب عدد المرات التي وقع فيها هذا الحدث فيما يتعلق بالسنجاب.

```text
function tableFor(event, journal) {
  let table = [0, 0, 0, 0];
  for (let i = 0; i < journal.length; i++) {
    let entry = journal[i], index = 0;
    if (entry.events.includes(event)) index += 1;
    if (entry.squirrel) index += 2;
    table[index] += 1;
  }
  return table;
}

console.log(tableFor("pizza", JOURNAL));
// → [76, 9, 4, 1]
```

المصفوفات لها عملية تسمى include والتي تتحقق من قيمة معينة في المصفوفة. تستخدم الوظيفة المذكورة أعلاه هذه الطريقة للتحقق من اسم الحدث في قائمة الأحداث ليوم معين.

يحدد جسم حلقة tableFor مكان كل مدخل من إدخالات المكتب اليومية في الجدول. ويتم ذلك عن طريق فحص وجود الحدث المطلوب في الإدخال وما إذا كان الحدث يقع في نفس الوقت مع السنجاب.  ثم تضيف الحلقة وحدة إلى الخلية المطلوبة في الجدول.

لدينا الآن الأدوات التي نحتاجها لحساب الارتباطات. الخطوة الوحيدة المتبقية هي العثور على معامل الارتباط لجميع الأحداث المسجلة ومعرفة الحدث الذي كان فعالاً.

### Array loops <a id="for_of_loop"></a>

كانت هناك حلقة في tableFor تشبه الكود التالي: 

```text
for (let i = 0; i < JOURNAL.length; i++) {
  let entry = JOURNAL[i];
  // Do something with entry
}
```

هذا الشكل من الحلقة شائع في JavaScript الكلاسيكي - حيث نذهب إلى خلية مصفوفة في كل مرة ، باستخدام عدادات تناسب طول المصفوفة حتى نتمكن من الوصول إلى كل عنصر.

هناك طريقة أسهل في JavaScript الحديثة لمثل هذه الحلقات.

```text
1
for (let entry of JOURNAL) {
2
  console.log(`${entry.events.length} events.`);
3
}
```

عندما تتم كتابة حلقة for بطريقة تُكتب الكلمة الرئيسية بعد تعريف متغير ، فإنها تمسح القيمة التي تأتي بعد. الكلمة الأساسية مكتوبة ، مع تمرير القيمة التي تليها. تستخدم هذه الحلقة ليس فقط للمصفوفات ولكن أيضًا للسلاسل وبعض هياكل البيانات الأخرى. سوف نتعلم كيف يعمل في الفصل 6.

### The final analysis <a id="analysis"></a>

نحتاج إلى حساب معامل الارتباط لجميع الأحداث في مجموعة البيانات. للقيام بذلك ، يجب أن نجد أولاً جميع أنواع الأحداث.

```text
function journalEvents(journal) {
  let events = [];
  for (let entry of journal) {
    for (let event of entry.events) {
      if (!events.includes(event)) {
        events.push(event);
      }
    }
  }
  return events;
}

console.log(journalEvents(JOURNAL));
// → ["carrot", "exercise", "weekend", "bread", …]
```

تجمع هذه الوظيفة كل الأحداث عن طريق تمرير كل حدث وإضافة الأحداث\(events\) التي لم تكن موجودة من قبل في مصفوفة الأحداث.

باستخدامه يمكننا أن نرى جميع الارتباطات.

```text
for (let event of journalEvents(JOURNAL)) {
  console.log(event + ":", phi(tableFor(event, JOURNAL)));
}
// → carrot:   0.0140970969
// → exercise: 0.0685994341
// → weekend:  0.1371988681
// → bread:   -0.0757554019
// → pudding: -0.0648203724
// and so on...
```

يبدو أن معظم معاملات الارتباط قريبة من الصفر. يبدو أن تناول الجزر أو الخبز أو الحلوى لا علاقة له بأن يصبح جاك سنجابًا. يبدو أن هذا التحويل يحدث غالبًا في عطلات نهاية الأسبوع. دعونا نحسن النتائج قليلاً لإظهار النتائج التي يكون معامل الارتباط فيها أكبر من 0.1 أو أقل من -0.1.

```text
for (let event of journalEvents(JOURNAL)) {
  let correlation = phi(tableFor(event, JOURNAL));
  if (correlation > 0.1 || correlation < -0.1) {
    console.log(event + ":", correlation);
  }
}
// → weekend:        0.1371988681
// → brushed teeth: -0.3805211953
// → candy:          0.1296407447
// → work:          -0.1371988681
// → spaghetti:      0.2425356250
// → reading:        0.1106828054
// → peanuts:        0.5902679812
```

آي! هناك عاملان لهما علاقة أقوى بشكل واضح من العوامل الأخرى. أكل الفول السوداني له تأثير إيجابي قوي على فرصة تحوله إلى سنجاب ، في حين أن تنظيف أسنانه له تأثير سلبي كبير.

إنه ممتع. لنجرب شيئًا ما.

```text
for (let entry of JOURNAL) {
  if (entry.events.includes("peanuts") &&
     !entry.events.includes("brushed teeth")) {
    entry.events.push("peanut teeth");
  }
}
console.log(phi(tableFor("peanut teeth", JOURNAL)));
// → 1
```

هذه نتيجة قوية. تحدث هذه الظاهرة على وجه التحديد عندما يأكل جاك الفول السوداني ويفشل في تنظيف أسنانه. لو لم يكن هذا القدر من اللعاب بشأن صحة الأسنان ، لما كان قد لاحظ قط معاناته.

بمعرفة ذلك ، توقف جاك عن تناول الفول السوداني تمامًا ووجد أن تحولاته لا تعود.

لبضع سنوات ، سارت الأمور على ما يرام بالنسبة لجاك. لكن في وقت ما فقد وظيفته. نظرًا لأن جاك يعيش في بلد حيث عدم وجود وظيفة يعني عدم وجود خدمات صحية ، فهو مجبر على العمل في سيرك حيث يكون دور الرجل السنجاب الرائع. يحشو فمه بزبدة الفول السوداني قبل كل عرض.

في أحد الأيام ، سئم جاك من هذه الحياة البائسة ، عندما لم يعد قادرًا على العودة إلى شكله البشري ، قفز فوق أحد شقوق خيمة السيرك واختفى في الغابة. لم يتم رؤيته  مرة أخرى.

### Further arrayology

قبل أن أختتم هذا الفصل ، أود أن أقدم لكم بعض المفاهيم الأخرى المتعلقة بالأشياء. سوف نتعرف أولاً على بعض الأساليب العامة والمفيدة للمصفوفات.

لقد راينا push و pop , التي تضيف وتزيل العناصر في نهاية المصفوفة, في وقت سابق من هذا الفصل,  تسمى الطرق المقابلة لإضافة وإزالة الأشياء في بداية المصفوفة unshift و shift .

```text
let todoList = [];
function remember(task) {
  todoList.push(task);
}
function getTask() {
  return todoList.shift();
}
function rememberUrgently(task) {
  todoList.unshift(task);
}
```

مهمة البرنامج أعلاه هي إدارة قائمة انتظار من المهام. يمكنك إضافة مهام إلى نهاية قائمة الانتظار \("remember\("groceriesعندما تكون مستعدًا لفعل شيء ما ، وعندما تكون مستعدًا لفعل شيء ما اتصل ب \(gettask\) للحصول على \(remove\), أنت تستدعي مهمة من مقدمة قائمة الانتظار. تُستخدم وظيفة rememberUrgently أيضًا لإضافة مهمة ولكنها تضيفها إلى مقدمة قائمة الانتظار ، وليس إلى نهاية قائمة الانتظار.

للبحث عن قيمة معينة ، توفر المصفوفات طريقة تسمى indexOf. تقوم هذه الطريقة بنقل المصفوفة من البداية إلى النهاية وإرجاع الفهرس الذي تم العثور فيه على القيمة المطلوبة - أو 1- إذا لم يتم العثور عليها. للبحث من النهاية بدلاً من البداية ، هناك طريقة مشابهة تسمى lastIndexOf.

```text
console.log([1, 2, 3, 2, 1].indexOf(2));
// → 1
console.log([1, 2, 3, 2, 1].lastIndexOf(2));
// → 3
```

يقبل كل من indexOf و lastIndexOf وسيطة اختيارية أخرى تُستخدم لتحديد نقطة البداية للبحث.



طريقة المصفوفة الأساسية الأخرى هي slice ، والتي تأخذ فهارس البداية والنهاية وتعيد مصفوفة تحتوي على العناصر بينهما فقط. مؤشر البداية شامل ، ومؤشر النهاية غير شامل.

```text
console.log([0, 1, 2, 3, 4].slice(2, 4));
// → [2, 3]
console.log([0, 1, 2, 3, 4].slice(2));
// → [2, 3, 4]
```

عندما لا يتم إعطاء مؤشر النهاية slice , ترجع جميع العناصر بعد الفهرس الأولي, لا يمكنك أيضًا تحديد الفهرس الأول الذي يتسبب في نسخ المصفوفة بأكملها.

يمكن استخدام طريقة concat للصق المصفوفات معًا لإنشاء مصفوفة جديدة ، على غرار ما يفعله عامل + للسلاسل.

المثال التالي يظهر كلاهما,  `concat` و `slice` في العمل. يأخذ مصفوفة وفهرسًا ، ويعيد مصفوفة جديدة تكون نسخة من المصفوفة الأصلية مع إزالة العنصر الموجود في الفهرس المحدد.

```text
function remove(array, index) {
  return array.slice(0, index)
    .concat(array.slice(index + 1));
}
console.log(remove(["a", "b", "c", "d", "e"], 2));
// → ["a", "b", "d", "e"]
```

إذا قمت بتمرير وسيطة غير مصفوفة إلى التابع concat ، تُعتبر هذه القيمة مصفوفة مكونة من عنصر واحد وستتم إضافتها إلى نهاية المصفوفة الجديدة.

### Strings and their properties

يمكننا استدعاء خصائص مثل length و toUpperCase من قيم السلسلة. ولكن إذا حاولت إضافة خاصية جديدة إليهم ، فلن تنجح.

```text
let kim = "Kim";
kim.age = 88;
console.log(kim.age);
// → undefined
```

لا تعتبر قيم نوع السلسلة والرقم والمنطقية كائنات. صحيح أنك إذا حاولت تعريف خاصية جديدة عليها ، فلن ينتج عن مترجم JavaScript خطأ ، لكنه لن يقوم بإنشاء وحفظ هذه الخصائص أيضًا. كما ذكرنا سابقًا ، لا يمكن تغيير هذه القيم.

لكن هذه الأنواع من البيانات لها خصائص محددة مسبقًا. كل قيمة سلسلة تحتوي على عدة طرق.  `slice` و `indexOf`  من أكثر الطرق فائدةً هي السلاسل النصية ، والتي تشبه العمليات التي لها نفس الأسماء في المصفوفات.

```text
console.log("coconuts".slice(4, 7));
// → nut
console.log("coconut".indexOf("u"));
// → 5
```

 اختلاف واحد هو أن سلسلة indexof , القدرة على البحث عن سلسلة تحتوي على أكثر من حرف أثناء عملية المصفوفة, بينما طريقة المصفوفة المقابلة تبحث فقط عن عنصر واحد.

```text
console.log("one two three".indexOf("ee"));
// → 11
```

طريقة trimتزيل المسافات الفارغة \(بما في ذلك المسافات الفارغة ، وحروف السطر الجديد ، وأحرف الجدولة ، والأحرف المماثلة\) من بداية السلسلة ونهايتها.

```text
console.log("  okay \n ".trim());
// → okay
```

وظيفة zeroPad التي كتبنا عنها في الفصل السابق موجودة أيضًا كطريقة. اسم هذه الطريقة هو padStart ويأخذ الطول المطلوب وحرف المحاذاة كوسيطة.

```text
console.log(String(6).padStart(3, "0"));
// → 006
```

يمكنك تقسيم سلسلة عند كل تكرار لسلسلة أخرى باستخدام split والانضمام إليه مرة أخرى مع  join 

```text
let sentence = "Secretarybirds specialize in stomping";
let words = sentence.split(" ");
console.log(words);
// → ["Secretarybirds", "specialize", "in", "stomping"]
console.log(words.join(". "));
// → Secretarybirds. specialize. in. stomping
```

يمكن تكرار سلسلة باستخدام طريقة repeat ، وفي هذه الحالة يتم إنشاء سلاسل جديدة تحتوي على نسخ متعددة من السلسلة الأصلية الملتصقة معًا.

```text
console.log("LA".repeat(3));
// → LALALA
```

في السابق ، تم تعريفنا بخاصية length لنوع السلسلة النصية. الحصول على الأحرف في سلسلة يشبه الحصول على عناصر المصفوفة \(مع الأخذ في الاعتبار نقطة واحدة سنغطيها في الفصل الخامس\).

```text
let string = "abc";
console.log(string.length);
// → 3
console.log(string[1]);
// → b
```

### Rest parameters <a id="rest_parameters"></a>

قد يكون من المفيد لدالة قبول أي عدد من الوسائط. فمثلا. تحسب Math.max الحد الأقصى لجميع المعطيات المعطاة.

لكتابة مثل هذه الوظيفة ، تضع ثلاث نقاط قبل المعلمة الأخيرة للوظيفة ، مثل هذا:

```text
function max(...numbers) {
  let result = -Infinity;
  for (let number of numbers) {
    if (number > result) result = number;
  }
  return result;
}
console.log(max(4, 1, 9, -2));
// → 9
```

عندما يتم استدعاء دالة بهذا التعريف ، يشير المعامل "Other" إلى مصفوفة تحتوي على جميع الوسائط الأخرى. إذا كانت هناك معلمات أخرى قبل ذلك ، فلن تكون قيمتها في تلك المصفوفة. إذا تم تعريف المعلمة الأولى بهذه الطريقة ، مثل طريقة max ، فستحتوي على جميع المتغيرات.

باستخدام هذا الرمز ثلاثي النقاط ، يمكنك استدعاء دالة بمصفوفة من المتغيرات.

```text
let numbers = [5, 1, 7];
console.log(max(...numbers));
// → 7
```

يؤدي 'spreads'هذه إلى انتشار المصفوفة في استدعاء الوظيفة ، بحيث يتم اعتبار عناصرها كوسائط منفصلة. بحيث تعتبر عناصرها حجج منفصلة. يمكن أيضًا تمرير مصفوفة مماثلة على وسيطات أخرى ، مثل  `max(9, ...numbers, 2)`.

وبالمثل ، تسمح لك أقواس المصفوفة باستخدام عامل متعدد الحدود لتشغيل مصفوفات أخرى في مصفوفة جديدة:

```text
let words = ["never", "fully"];
console.log(["will", ...words, "understand"]);
// → ["will", "never", "fully", "understand"]
```

### The Math object

كما رأينا ، تحتوي الرياضيات 'Math' على عدد من الوظائف الوظيفية المتعلقة بالأرقام. مثل Math.max \(الحد الأقصى\) ، Math.min \(الحد الأدنى\) ، Math.sqrt \(الجذر الثاني للعدد\).

يتم استخدام الكائن Math كحاوية لتجميع مجموعة من الوظائف ذات الصلة. يوجد كائن Mathواحد فقط, وتكاد تكون غير مفيدة كقيمة. بدلاً من ذلك ، فإنه يوفر مساحة اسم بحيث لا يلزم أن تكون كل هذه الوظائف والقيم روابط عالمية.

يؤوجود الكثير من المتغيرات العالمية يلوث بطريقة ما مساحة الاسم. كلما زاد عدد الأحرف المشغولة ، زاد احتمال استبدال قيمة المتغيرات بدون قصد وبشكل عشوائي. على سبيل المثال ، ليس من غير المألوف أن ترغب في تعريف شيء يسمى max في أحد برامجك. ولكن نظرًا لأنه يتم تخزين وظيفة max المحددة مسبقًا في JavaScript بشكل آمن داخل كائن Math ، فلا داعي للقلق بشأن تغييرها عن طريق الخطأ.

تمنعك العديد من لغات البرمجة من تحديد متغير تم تعريفه بالفعل ، أو على الأقل تحذيرك منه. يقوم JavaScript بهذا مع المتغيرات المحددة بواسطة let أو const ، لكن الغريب أنه لا يتحرك للمتغيرات المحددة بواسطة var والوظائف المحددة بواسطة الوظيفة ومتغيرات اللغة القياسية.

دعنا نعود إلى الكائن Math. إذا كنت بحاجة إلى حسابات مثلثية ، فيمكن أن تساعدك Math.يحتوي على       \(cosine\)`cos`, و  \(sine\)`sin`,  و  \(tangent\)`tan`,  مع وظائفهم العكسية ،   `acos`, `asin`, و`atan`, على التوالي. الرقم \(π \(pi . أو على الأقل أقرب تقريب يناسب رقم جافا سكريبت - متاح كـ Math.PI . هناك تقليد قديم في البرمجة يكتب أسماء ثابتة بأحرف كبيرة.

```text
function randomPointOnCircle(radius) {
  let angle = Math.random() * 2 * Math.PI;
  return {x: radius * Math.cos(angle),
          y: radius * Math.sin(angle)};
}
console.log(randomPointOnCircle(2));
// → {x: 0.3667, y: 1.966}
```

إذا لم تكن معتادًا علىsines و cosines التمام ، فلا تقلق. عندما نصل إلى استخدامها ، سأشرحها في الفصل 14.

في المثال السابق ، تم استخدام Math.random. تنشئ هذه الوظيفة رقمًا عشوائيًا بين صفر \(بما في ذلك الصفر نفسه\) وواحد \(بخلاف نفسه\) مع كل مكالمة.

```text
console.log(Math.random());
// → 0.36993729369714856
console.log(Math.random());
// → 0.727367032552138
console.log(Math.random());
// → 0.40180766698904335
```

على الرغم من أن أجهزة الكمبيوتر هي آلات محددة - فهي تتفاعل دائمًا بنفس الطريقة مع نفس المدخلات - يمكن أن يُطلب منها إنشاء أرقام تبدو عشوائية.  للقيام بذلك ، يأخذ الكمبيوتر في الاعتبار بعض القيم المخفية ، وكلما طلبت رقمًا عشوائيًا ، يقوم بإجراء حسابات معقدة على تلك القيم المخفية لإنشاء قيمة جديدة. احفظ القيمة الجديدة وأعد الرقم المأخوذ منها كرد. وبهذه الطريقة ، تكون قادرة على توليد أرقام جديدة يصعب توقعها بحيث تبدو عشوائية.

إذا كنا بحاجة إلى رقم عشوائي كامل \(عدد صحيح\) بدلاً من الأرقام العشرية ، فيمكننا استخدام طريقة Math.floor \(التي تقرب رقم الإدخال إلى أقرب عدد صحيح أصغر\) لنتيجة Math.random.

```text
console.log(Math.floor(Math.random() * 10));
// → 2
```

يتيح لنا ضرب رقم عشوائي في 10 إنتاج عدد أكبر يساوي 0 وأقل من 10. نظرًا لأن Math.floor تقريب الرقم إلى أسفل ، فإن هذا التعبير ينتج رقمًا عشوائيًا بين 0 و 9.

هناك أيضًا دوال أخرى مثل Math.ceil للتقريب لأعلى \(السقف\) ، Math.round لتوليد أقرب عدد صحيح ، و Math.abs للحصول على القيمة المطلقة لرقم \(الحجم المطلق للرقم ، بغض النظر عن علامته ، ينفي الأرقام السالبة ولا علاقة له بالأرقام الموجبة\).

### Destructuring:  اعاده بناء

دعنا نعود إلى وظيفة حساب phi:

```text
function phi(table) {
  return (table[3] * table[0] - table[2] * table[1]) /
    Math.sqrt((table[2] + table[3]) *
              (table[0] + table[1]) *
              (table[1] + table[3]) *
              (table[0] + table[2]));
}
```

أحد أسباب صعوبة قراءة هذه الوظيفة هو أن لدينا متغيرًا يشير إلى المصفوفة الخاصة بنا ، بينما سيكون من الأفضل وجود متغيرات للإشارة إلى عناصر المصفوفة. على سبيل المثال :

let n00 = table\[0\]

لحسن الحظ يوجد لدينا اختصار لهذا في javascript.

```text
function phi([n00, n01, n10, n11]) {
  return (n11 * n00 - n10 * n01) /
    Math.sqrt((n10 + n11) * (n00 + n01) *
              (n01 + n11) * (n00 + n10));
}
```

يعمل هذا أيضًا مع الارتباطات التي تم إنشاؤها باستخدام let أو var أو const. إذا كنت تعلم أن القيمة التي تربطها هي مصفوفة ، يمكنك استخدام الأقواس المربعة "للنظر داخل" القيمة ، وربط محتوياتها.

تعمل خدعة مماثلة مع الكائنات ، باستخدام الأقواس بدلاً من الأقواس المربعة.

```text
let {name} = {name: "Faraji", age: 23};
console.log(name);
// → Faraji
```

لاحظ أنه إذا حاولت تحليل قيمة nullأو undefined ، فستحصل على خطأ ، تمامًا مثل محاولة الإشارة مباشرةً إلى خاصية من هاتين القيمتين.

### JSON

نظرًا لحقيقة أن الخصائص لها حق الوصول إلى القيم المقابلة لها فقط ، وليس في الواقع الاحتفاظ بها, يتم تخزين المصفوفات والكائنات على شكل سلسلة من وحدات bit في ذاكرة الكمبيوتر التي تخزن عناوين المحتوى المرتبط بها \(مواقع الذاكرة\). وهكذا تتكون المصفوفة التي تحتوي على مصفوفات أخرى من منطقة ذاكرة واحدة على الأقل للمصفوفة الداخلية ، ومنطقة أخرى للصفيف الخارجي ، والتي تحتوي \(من بين أشياء أخرى\) على رقم ثنائي يشير إلى موضع المصفوفة الداخلية.

إذا كنت بحاجة إلى حفظ البيانات لاستخدامها في المستقبل في ملف ، أو إرسالها إلى كمبيوتر آخر على الشبكة ، فأنت بحاجة إلى تحويل عناوين الذاكرة هذه بطريقة ما إلى أوصاف يمكن حفظها أو إرسالها. يمكنك إرسال كل ذاكرة الكمبيوتر مع عنوان القيمة المرغوبة ، على ما يبدو ، لكنها لا تبدو طريقة جيدة جدًا.

ما يمكننا القيام به في هذه الحالة هو إجراء تسلسل للبيانات \( serialize\). بمعنى أننا نحوله إلى نص مسطح. يُطلق على أحد التنسيقات الأكثر شيوعًا لتسلسل البيانات اسم JSON \(يُنطق JSON\).والتي تعني ترميز كائن JavaScript ب\(javascript object notation\) تُستخدم هذه الطريقة على نطاق واسع كطريقة لتخزين البيانات وإرسالها / استقبالها على الويب ، حتى في لغات البرمجة الأخرى غير JavaScript.

يشبه JSON إلى حد ما مصفوفات وكائنات كتابة جافا سكريبت مع بعض القيود. يجب أن تكون أسماء الخصائص محاطة بعلامات اقتباس ، ولا يُسمح إلا بتعبيرات البيانات البسيطة - لا يُسمح بالمتغيرات أو استدعاءات الوظائف أو أي شيء يتضمن حسابًا عمليًا. Comments أيضًا غير مسموح بها في JSON.

قد يبدو إدخال التقرير اليومي مثل الكود التالي إذا تمت كتابته بتنسيق JSON:

```text
{
  "squirrel": false,
  "events": ["work", "touched tree", "pizza", "running"]
}
```

توفر لنا JavaScript طريقتين ، JSON.stringify و JSON.parse ، حتى نتمكن من تحويل البيانات أو استخراجها من JSON. تأخذ الوظيفة الأولى قيمة JavaScript وتحولها إلى سلسلة بتنسيق JSON. تأخذ الوظيفة الثانية سلسلة بتنسيق JSON وتحولها إلى القيمة المضمنة في السلسلة.

```text
let string = JSON.stringify({squirrel: false,
                             events: ["weekend"]});
console.log(string);
// → {"squirrel":false,"events":["weekend"]}
console.log(JSON.parse(string).events);
// → ["weekend"]
```

### Summary

توفر الكائنات والمصفوفات \(المصفوفات أيضًا شكلًا خاصًا من الكائنات\) طرقًا يمكننا من خلالها تجميع قيم متعددة والحصول عليها كقيمة. من الناحية المفاهيمية ، يمكننا هذا من وضع أشياء متعددة في سلة ونقلها معنا ، بدلاً من حمل أشياء متعددة باليد.

معظم القيم في JavaScript هي مجموعة من الخصائص ، باستثناء القيم null و undefined. يمكن الوصول إلى الخصائص  

 `value.prop` or `value["prop"]`.

في الكائنات ، يتم تسمية الخصائص وعادة ما تحتوي على مجموعة ثابتة منها. من ناحية أخرى ، تحتوي المصفوفات على عدد متنوع من القيم ، عادةً من نفس الجنس ، وتستخدم الأرقام \(بدءًا من الصفر\) كاسم لخصائصها.

بالطبع ، هناك بعض الخصائص في المصفوفات التي تم تسميتها ؛ مثل length والبعض الآخر. الأساليب هي وظائف موجودة في الخصائص وتعمل \(عادة\) على قيمة الممتلكات.

يمكنك التنقل بين عناصر المصفوفة بنوع معين من حلقة for. لـ \(let element of array\)

### Exercises

#### The sum of a range

أشارت مقدمة هذا الكتاب إلى ما يلي كطريقة لطيفة لحساب مجموع مجموعة من الأرقام:



```text
console.log(sum(range(1, 10)));
```

اكتب دالة تسمى النطاق تتلقى وسيطتين ، start وend، وتعيد مصفوفة تحتوي على جميع الأرقام التي تبدأ من  start وتنتهي برقم end.

ثم اكتب دالة تسمى مجموع اي'sum' تأخذ مصفوفة من الأرقام وتعيد مجموع هذه الأرقام. قم بتشغيل البرنامج في المثال وتحقق مما إذا كان يعيد 55 كإجابة؟

كمهمة تحفيزية ، قم بتغيير دالة range الخاصة بك لقبول وسيطة اختيارية ثالثة. تحدد هذه الوسيطة خطوة إنشاء المصفوفة. إذا لم يتم تحديد خطوة ، فإن عناصر المصفوفة ، مثل الحالة الافتراضية ، تزيد بمقدار وحدة واحدة. يجب أن ينتج عن استدعاء دالة في شكل نطاق \(1 ، 10 ، 2\) الناتج \[1 ، 3 ، 5 ، 7 ، 9\]. تأكد من أن الوظيفة ستعمل بخطوة سالبة ، لذا يجب أن ينتج النطاق \(5 ، 2 ، -1\) \[5 ، 4 ، 3 ، 2\].

```text
// Your code here.

console.log(range(1, 10));
// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
console.log(range(5, 2, -1));
// → [5, 4, 3, 2]
console.log(sum(range(1, 10)));
// → 55
```

#### Reversing an array عكس المصفوفة

المصفوفات لها عملية تسمى عكس والتي تعكس ترتيب عناصر المصفوفة. في هذا التمرين ، اكتب وظيفتين: reverseArray و reverseArrayInPlace. الوظيفة الأولى ،                                                        يأخذ reverseArray المصفوفة كمدخلات وينشئ مصفوفة جديدة لها نفس العناصر ولكن بترتيب عكسي      تعمل الوظيفة الثانية ، reverseArrayInPlace بشكل مشابه للطريقة العكسية  `reverse` ؛ الفرق هو أنه يغير نفس المصفوفة التي يتلقاها كوسيطة ويعكس ترتيب عناصرها. لا يمكنك استخدام الطريقة العكسية القياسية في هذا التمرين.

ضع في اعتبارك الآثار الجانبية والوظائف البحتة التي تمت مناقشتها في الفصل السابق ، ما وظيفة ما سبق ، برأيك ، سيتم استخدامها في المزيد من المواقف؟ أيهما يعمل بشكل أسرع؟

```text
// Your code here.

console.log(reverseArray(["A", "B", "C"]));
// → ["C", "B", "A"];
let arrayValue = [1, 2, 3, 4, 5];
reverseArrayInPlace(arrayValue);
console.log(arrayValue);
// → [5, 4, 3, 2, 1]
```

### A list

يمكن استخدام الكائنات كقيم بدون إطار عمل محدد لبناء أي نوع من بنية البيانات. أحد الأنواع الشائعة لهيكل البيانات هو القوائم \(يجب عدم الخلط بين القوائم والمصفوفات\). القائمة هي مجموعة متداخلة من الكائنات تحتوي فيها على الكائن الأول المشار إليه في الثاني ، والثاني إلى الثالث ، وهكذا.

```text
let list = {
  value: 1,
  rest: {
    value: 2,
    rest: {
      value: 3,
      rest: null
    }
  }
};
```

ستبدو الأشياء في السلسلة كما يلي:

![](.gitbook/assets/image%20%2822%29.png)

من الأشياء الجيدة في القوائم أنها تشترك في جزء من هيكلها.                                                                   if I create two new values `{value: 0, rest: list}` and `{value: -1, rest: list}` \(with `list` referring to the binding defined earlier\),     كلاهما قائمتان مستقلتان ، لكنهما يشتركان في البنية التي تشكل العناصر الثلاثة الأخيرة. القائمة الأصلية لا تزال قائمة صالحة من ثلاثة عناصر.

اكتب دالة تسمى arrayToList تُنشئ بنية قائمة مشابهة لتلك المعروضة وتتخذ القيمة \[1 ، 2 ، 3\] كوسيطة. اكتب أيضًا دالة تسمى listToArray لتوليد مصفوفة من القائمة المحددة. ثم قم بتعريف الوظيفة الإضافية prepend ، والتي تأخذ عنصرًا بقائمة وتولد قائمة جديدة مع العنصر المضاف في البداية ، والدالة n ، التي تأخذ قائمة ورقمًا ، والعنصر في الموضع المطلوب. عوائد تقع من القائمة \(يشير الصفر إلى العنصر الأول\) أو إذا كان العنصر غير موجود ، يتم إرجاع القيمة غير المعرفة.

إذا لم تحل هذه المشكلة بالطريقة العودية ، فاكتب الآن النسخة العودية للدالة n.

```text
// Your code here.

console.log(arrayToList([10, 20]));
// → {value: 10, rest: {value: 20, rest: null}}
console.log(listToArray(arrayToList([10, 20, 30])));
// → [10, 20, 30]
console.log(prepend(10, prepend(20, null)));
// → {value: 10, rest: {value: 20, rest: null}}
console.log(nth(arrayToList([10, 20, 30]), 1));
// → 20
```

#### Deep comparison مقارنة عميقة <a id="exercise_deep_compare"></a>

عامل التشغيل == يقارن الكائنات بناءً على التجانس. لكن في بعض الأحيان قد ترغب في مقارنة قيم خصائصها الفعلية. 

اكتب دالة تسمى deepEqual تأخذ قيمتين وتعيد القيمة true‌ عندما تكون كلتا القيمتين متماثلتين أو لها نفس الخصائص إذا كانتا كائنات. بحيث تكون قيم خصائصها متساوية أيضًا عند مقارنتها باستدعاء تعاودي لوظيفة deepEqual.

يمكن استخدام عامل التشغيل typeof لمعرفة ما إذا كان يجب مقارنة القيم مباشرةً \(استخدم عامل التشغيل === لذلك\) أو ما إذا كان ينبغي علينا مقارنة خصائصها. إذا كان هذا العامل ينتج "كائنًا" لكلا القيمتين ، فيجب إجراء عملية مقارنة متعمقة. يجب أن تفكر أيضًا في استثناء سخيف: نظرًا لصدفة قديمة ، ينتج typeof null أيضًا "object".

ستساعدك وظيفة Object.keys عندما تحتاج إلى الوصول إلى الخصائص لمقارنة خصائص الكائنات.

```text
// Your code here.

let obj = {here: {is: "an"}, object: 2};
console.log(deepEqual(obj, obj));
// → true
console.log(deepEqual(obj, {here: 1, object: 2}));
// → false
console.log(deepEqual(obj, {here: {is: "an"}, object: 2}));
// → true
```





