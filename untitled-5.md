# Project: A Robot

> \[...\] السؤال عما إذا كانت الآلات تستطيع التفكير أم لا \[...\] يشبه السؤال عما إذا كانت الغواصات تستطيع السباحة

> Edsger Dijkstra, The Threats to Computing Science

![](.gitbook/assets/image%20%2815%29.png)

في فصول "المشروع" ، لن أقدم مؤقتًا أي شيء جديد ، وبدلاً من ذلك سنعمل معًا لبناء برنامج. النظرية ضرورية للبرمجة ، لكن قراءة وفهم البرامج الحقيقية لا تقل أهمية.

مشروعنا هذا الموسم هو بناء آلة مؤتمتة. برنامج صغير يؤدي مهمة في عالم افتراضي. آلة البيع لدينا عبارة عن روبوت للمراسلة يقوم بتوصيل وتسليم الطرود البريدية إلى وجهاتهم.

### Meadowfield قرية ميدوفيلد

قرية ميدوفيلد ليست كبيرة جدا. لديها 11 مكانًا مع 14 مسارًا بينهما. يمكن وصفه بهذه المجموعة من الطرق:

```text
const roads = [
  "Alice's House-Bob's House",   "Alice's House-Cabin",
  "Alice's House-Post Office",   "Bob's House-Town Hall",
  "Daria's House-Ernie's House", "Daria's House-Town Hall",
  "Ernie's House-Grete's House", "Grete's House-Farm",
  "Grete's House-Shop",          "Marketplace-Farm",
  "Marketplace-Post Office",     "Marketplace-Shop",
  "Marketplace-Town Hall",       "Shop-Town Hall"
];
```

![](.gitbook/assets/image%20%288%29.png)

تشكل شبكة الطرق في هذه القرية رسمًا بيانيًا.  الرسم البياني عبارة عن مجموعة من النقاط \(أماكن في القرية\) مع خطوط بينهما\(طرق\). سيكون هذا الرسم البياني هو العالم الذي يتحرك فيه روبوتنا.

العمل مع مجموعة من السلاسل ليس بالأمر السهل. نريد أن نعرف إلى أين يمكننا الذهاب من أي مكان.

```text
function buildGraph(edges) {
  let graph = Object.create(null);
  function addEdge(from, to) {
    if (graph[from] == null) {
      graph[from] = [to];
    } else {
      graph[from].push(to);
    }
  }
  for (let [from, to] of edges.map(r => r.split("-"))) {
    addEdge(from, to);
    addEdge(to, from);
  }
  return graph;
}

const roadGraph = buildGraph(roads);
```

ستعمل وظيفة buildGraph ، بأخذ مجموعة من المسارات ، على إنشاء كائن خريطة\(map\) يخزن مجموعة من العقد المتصلة به لكل عقدة. stores an array of connected nodes. سيخزن مجموعة من العقد المتصلة به.

تستخدم طريقة split لتحويل سلاسل المسار, والتي تكون في شكل "Start-End", إلى مصفوفات مكونة من عنصرين تحتوي على البداية'start' والنهاية'end' كسلاسل منفصلة.

### The task مهمة

يقوم الروبوت الخاص بنا بدوريات في القرية ويلتقط الطرود المنتشرة في أماكن مختلفة ، ويجب نقل كل منها إلى مكان مختلف ، وتسليمها إلى وجهاتها.

يجب أن تقرر هذه الآلة الأوتوماتيكية إلى أين ستذهب بعد ذلك. عندما يتم تسليم جميع الطرود ، تنتهي المهمة.

لمحاكاة هذه العملية ، نحتاج إلى تعريف عالم افتراضي يصفها. يحدد هذا النموذج موقع الروبوت والحزم. عندما يقرر الروبوت التحرك ، نحتاج إلى تحديث النموذج ليعكس الوضع الجديد.

إذا نظرت إلى مشكلة التفكير في البرمجة الكائنية ، فقد تكون خطوتك الأولى هي تحديد كائنات منفصلة لعناصر مختلفة من الكون: فئة للروبوت ، وفئة للحزمة ، وربما واحدة للأماكن. يمكن أن تحتوي هذه الفئات أيضًا على خصائص تحافظ على حالتها الحالية. مثل عدد الحزم في مكان واحد ، والتي يمكن أن تتغير مع تحديث العالم.

هذا خطأ.

على الأقل ، عادة ما يكون خطأ. فقط لأن شيئًا ما يشبه كائنًا لا يعني أنه يجب اعتباره كائنًا في برنامجك. هذا ، من خلال التفكير في فئات منفصلة لكل مفهوم في البرنامج ، يأخذك إلى النقطة التي تواجه فيها مجموعة من الكائنات المترابطة ، ولكل منها حالتها الداخلية المتغيرة. عادة ما يكون من الصعب فهم مثل هذه البرامج ، ونتيجة لذلك ، تواجه مشاكل بسهولة.

بدلاً من ذلك ، دعونا نلخص وضع القرية بأصغر مجموعة من القيم التي يمكن وصفها ؛ الوضع الحالي للروبوت ومجموعة الحزم التي لم يتم تسليمها بعد. كل من هذه الحزم لها موقع حالي وعنوان وجهة.

وأثناء وجودنا في ذلك ، فلنقم بذلك حتى لا نغير هذه الحالة عندما يتحرك الروبوت ، بل نحسب حالة جديدة للوضع بعد الانتقال.

```text
class VillageState {
  constructor(place, parcels) {
    this.place = place;
    this.parcels = parcels;
  }

  move(destination) {
    if (!roadGraph[this.place].includes(destination)) {
      return this;
    } else {
      let parcels = this.parcels.map(p => {
        if (p.place != this.place) return p;
        return {place: destination, address: p.address};
      }).filter(p => p.place != p.address);
      return new VillageState(destination, parcels);
    }
  }
}
```

طريقة move هي المكان الذي يتم فيه العمل. يتحقق هذا الأسلوب أولاً من وجود مسار بين الموقع الحالي والوجهة ، وإذا لم يكن هناك مسار ، فإنه يعود إلى الحالة السابقة ، لأن الحركة المطلوبة غير صالحة.

ثم يقوم بإنشاء موقف جديد يتم فيه اعتبار الوجهة الموقع الجديد للروبوت. من الضروري أيضًا إنشاء مجموعة جديدة من الحزم - الحزم التي يحملها الروبوت \(الموجودة في الموقع الحالي للروبوت\) ويجب نقلها إلى موقع جديد. والطرود الموجهة إلى موقع جديد ليتم تسليمها - والتي يجب إزالتها من حزمة الطرود التي لم يتم تسليمها. يؤدي استدعاء الخريطة 'map' إلى تحريك الروبوت واستدعاء عامل التصفية 'filter' لتسليم الحزم.

لا تتغير كائنات الحزمة عند نقلها ، ولكن يتم إعادة إنشائها. تعطينا طريقة move حالة جديدة للقرية وتترك الحالة السابقة سليمة.

```text
let first = new VillageState(
  "Post Office",
  [{place: "Post Office", address: "Alice's House"}]
);
let next = first.move("Alice's House");

console.log(next.place);
// → Alice's House
console.log(next.parcels);
// → []
console.log(first.place);
// → Post Office
```

تتسبب طريقة move في تسليم الحزمة ، ويمكن رؤية هذا الإجراء في الحالة التالية. لكن الموقف الأولي لا يزال يشير إلى أن الروبوت موجود في مكتب البريد ولم يتم تسليم الحزمة.

### Persistent data البيانات المستمرة

يتم استدعاء هياكل البيانات التي لا تتغير   _immutable_ or _persistent ._ تعمل هذه الهياكل إلى حد كبير مثل السلاسل والأرقام ، مما يعني أنها ستظل دائمًا كما هي وستظل كما هي ، بدلاً من أن يكون لها محتوى مختلف في أوقات مختلفة.

في JavaScript ، يمكن تغيير أي شيء تقريبًا. لذلك ستكون هناك عقبات أمام العمل بالقيم التي من المفترض أن تستمر. هناك وظيفة تسمى Object.freeze والتي ، عند تطبيقها على كائن ، تجعل من المستحيل تغيير خصائص هذا الكائن. إذا كنت تريد اتخاذ الاحتياطات ، يمكنك استخدام هذه الطريقة لمنع الكائن الخاص بك من التغيير. يؤدي الحفاظ على كائن ثابت إلى قيام الكمبيوتر بمزيد من العمل ، وعدم التفكير في تحديث الكائنات من المرجح أن يضلل الناس. لذلك ، عادةً ما أفضل إخبار الآخرين أنه لا ينبغي العبث بشيء ما وآمل أن يحذو الآخرون حذرهم.

```text
let object = Object.freeze({value: 5});
object.value = 10;
console.log(object.value);
// → 5
```

لماذا أصر على عدم تغيير الأشياء ، رغم أن اللغة تسمح بذلك بوضوح؟

لأنه يساعدني على فهم الخطط. يعود هذا إلى إدارة تعقيد البرنامج, عندما تكون الكائنات في نظامي كائنات ثابتة ، يمكنني أن أفترض أنها تعمل في مساحة منفصلة - فالذهاب إلى منزل Alice  من حالة أولية معينة ينتج دائمًا نفس الحالة الجديدة. مع تغير الأشياء بمرور الوقت ، فإن هذا يضيف بعدًا آخر من التعقيد لمثل هذه الاستنتاجات.

بالنسبة لنظام صغير مثل النظام الذي نبنيه هذا الموسم ، يمكننا التعامل مع هذا التعقيد الإضافي. لكن أهم تحديد لنوع الأنظمة التي يمكننا بناءها هو مدى قدرتنا على فهم تلك الأنظمة. سيسمح لك أي شيء يسهل فهم الكود الخاص بك ببناء نظام أكثر طموحًا.

لسوء الحظ ، في حين أنه من الأسهل فهم نظام مبني باستخدام هياكل بيانات Mana ، إلا أنه قد يكون أكثر صعوبة في التصميم ، خاصةً عندما لا تساعد لغة البرمجة نفسها. ومع ذلك ، سنبحث عن فرص لاستخدام هياكل بيانات Mana في هذا الكتاب ، بالإضافة إلى الهياكل القابلة للتغيير.

### Simulation محاكاة

ينظر الروبوت الموصل إلى العالم من حوله ويقرر الطريق الذي يسلكه. بناءً على ذلك ، يمكننا القول أن الروبوت هو وظيفة تأخذ كائنًا من نوع VillageState وتعيد اسم مكان قريب.

لأن الروبوتات يمكنها البرمجة والتنفيذ ، يجب أن تكون قادرة على حفظ الأشياء. ثم نرسل لهم ذاكرتهم ونسمح لهم باستعادة ذاكرة جديدة. إذن ، ما يعيده الروبوت هو كائن له شيئين: الاتجاه الذي سيتحرك فيه وكمية الذاكرة المستخدمة في المكالمة التالية.

```text
function runRobot(state, robot, memory) {
  for (let turn = 0;; turn++) {
    if (state.parcels.length == 0) {
      console.log(`Done in ${turn} turns`);
      break;
    }
    let action = robot(state, memory);
    state = state.move(action.direction);
    memory = action.memory;
    console.log(`Moved to ${action.direction}`);
  }
}
```

تعرف على ما يجب أن يفعله الروبوت لحل موقف معين. لإزالة الحزم ، يجب عليك الذهاب إلى جميع المواقع التي تحتوي على الحزمة ، ولتوصيلها ، يجب عليك الذهاب إلى جميع المواقع التي يتم توجيه الحزمة إليها ، بالطبع ، بعد استلام الحزمة.

ما هي أغبى استراتيجية لحل هذه المشكلة؟ يمكن للروبوت أن يتحرك في اتجاه واحد في كل مرة. هذا يعني أنه من المحتمل أن تصل في النهاية إلى جميع الحزم وتصل في النهاية إلى المواقع التي يجب أن توصلها إليها.

هذا مثال على هذا الرمز:

```text
function randomPick(array) {
  let choice = Math.floor(Math.random() * array.length);
  return array[choice];
}

function randomRobot(state) {
  return {direction: randomPick(roadGraph[state.place])};
}
```

لاحظ أن طريقة Math.random \(\) تنشئ رقمًا بين صفر وواحد ، والذي يكون دائمًا أقل من واحد. يؤدي ضرب هذا الرقم في مصفوفة ثم تطبيق Math.floor عليه إلى الحصول عشوائيًا على أحد فهارس المصفوفة. 

لأن هذا الروبوت لا يحتاج إلى تذكر أي شيء ، لا يتم النظر في الحجة الثانية\(تذكر أنه في JavaScript ، يمكن استدعاء دالة بمزيد من الوسائط بدون أخطاء.\) ولا يضع خاصية memory في كائن الإخراج.

لاستخدام هذا الروبوت ، نحتاج أولاً إلى إيجاد طريقة لإنشاء وضع جديد ببضع حزم. تعتبر الطريقة الثابتة \(المعرفة هنا عن طريق إضافة خاصية مباشرة إلى المنشئ\) مكانًا جيدًا لهذه الميزة.

```text
VillageState.random = function(parcelCount = 5) {
  let parcels = [];
  for (let i = 0; i < parcelCount; i++) {
    let address = randomPick(Object.keys(roadGraph));
    let place;
    do {
      place = randomPick(Object.keys(roadGraph));
    } while (place == address);
    parcels.push({place, address});
  }
  return new VillageState("Post Office", parcels);
};
```

لا نحتاج إلى النظر في الحزم التي تكون عناوين مصدرها ووجهتها متطابقة. لهذا السبب ، تستمر حلقة do في اتخاذ المواقع طالما أن الأصل والوجهة متساويان.

```text
runRobot(VillageState.random(), randomRobot);
// → Moved to Marketplace
// → Moved to Town Hall
// → …
// → Done in 63 turns
```

لتوصيل الحزم ، يتعين على الروبوت القيام بالعديد من الحركات لأنه لم يتم التخطيط له بشكل جيد مسبقًا. سنحل هذه المشكلة قريبا.

للحصول على عرض أفضل للمحاكاة ، يمكنك استخدام وظيفة runRobotAnimation المتوفرة في مساحة البرمجة في هذا الفصل   [this chapter’s programming environment](https://eloquentjavascript.net/code/#7). يؤدي هذا إلى تشغيل المحاكاة ، ولكن بدلاً من إخراج النص ، يُظهر لك الروبوت يتحرك حول خريطة القرية.

```text
runRobotAnimation(VillageState.random(), randomRobot);
```

كيفية تنفيذ وظيفة runRobotAnimation مغلقة حاليًا ، ولكن بعد قراءة الفصول التالية  [later chapters](https://eloquentjavascript.net/14_dom.html) من الكتاب ، والتي تتناول JavaScript في متصفحات الويب ، يمكنك تخمين كيفية عملها.

### The mail truck’s route طريق شاحنة البريد

نحتاج لأن نكون قادرين على القيام بعمل أفضل من بناء روبوت عشوائي. يمكن أن يكون التحسين البسيط مستوحى من نظام التسليم البريدي في العالم الحقيقي. إذا وجدنا مسارًا يمر عبر جميع المنازل في القرية ، يمكن للروبوت عبور هذا المسار مرتين. سيضمن هذا أنها تفي بمهمتها. إليك مسار بهذه المواصفات \(بدءًا من مكتب البريد\):

```text
const mailRoute = [
  "Alice's House", "Cabin", "Alice's House", "Bob's House",
  "Town Hall", "Daria's House", "Ernie's House",
  "Grete's House", "Shop", "Grete's House", "Farm",
  "Marketplace", "Post Office"
];
```

لتنفيذ الروبوت الذي يتبع المسار ، سنحتاج إلى الاستفادة من ذاكرة الروبوت. يحافظ الروبوت على بقية مساره في ذاكرته ويسقط العنصر الأول في كل منعطف.

```text
function routeRobot(state, memory) {
  if (memory.length == 0) {
    memory = mailRoute;
  }
  return {direction: memory[0], memory: memory.slice(1)};
}
```

يعمل هذا الروبوت أسرع بكثير من الروبوت السابق. سيستغرق الأمر 26 حركة كحد أقصى \(ضعف مسار 13 خطوة\) ، ولكن عادةً ما يستغرق أقل.

```text
runRobotAnimation(VillageState.random(), routeRobot, []);
```

### Pathfinding التوجيه

مع ذلك ، لن أتصل بشكل أعمى باتباع سلوك ذكي للطريق الثابت. يمكن أن يعمل الروبوت بشكل أكثر كفاءة إذا قام بتعديل سلوكه للعمل الفعلي الذي يجب القيام به.

للقيام بذلك ، يجب أن تكون قادر على التحرك عمدًا نحو طرد معين أو نحو الموقع حيث يجب تسليم الطرد. يتطلب القيام بذلك نوعًا من التوجيه ، حتى عندما يكون بعيدًا عن الهدف بخطوتين أو أكثر.

يعد العثور على مسار في الرسم البياني مسألة بحث عادي. يمكننا القول أن الحل المعطى \(المسار\) هو حل صحيح ؛ لكن لا يمكننا الحصول على الحل مباشرة بالطريقة التي نحسب بها 2 + 2. بدلاً من ذلك ، يجب أن نستمر في إيجاد الحلول المحتملة حتى نحققها بالشكل الصحيح.

عدد المسارات الممكنة في الرسم البياني لانهائي. لكن عندما نبحث عن مسار من النقطة a إلىb . نحن ننتبه فقط إلى المسارات التي تبدأ من النقطة a . كما أننا لا نهتم بالطرق التي تعبر مرتين في مكان واحد - فهي بالتأكيد لا يمكن أن تكون أفضل طريق. لذلك ، يتم تقليل عدد المسارات التي يجب أن يأخذها جهاز التوجيه في الاعتبار.

في الواقع ، نحن مهتمون أكثر بإيجاد أقصر طريق. لذلك علينا التأكد من فحص المسارات الأقصر قبل المسارات الأطول. قد يكون الحل الجيد هو "توسيع" المسارات من نقطة البداية ، والتحقق من أي أماكن يمكن الوصول إليها لم نقم بزيارتها قبل أن يصل الطريق إلى وجهته. بهذه الطريقة ، سنكتشف فقط المسارات التي تبدو ذات صلة محتملة ، وبالتالي نجد أقصر طريق للهدف \(أو أحد أقصر المسارات إذا كان هناك أكثر من مسار\).

```text
function findRoute(graph, from, to) {
  let work = [{at: from, route: []}];
  for (let i = 0; i < work.length; i++) {
    let {at, route} = work[i];
    for (let place of graph[at]) {
      if (place == to) return route.concat(place);
      if (!work.some(w => w.at == place)) {
        work.push({at: place, route: route.concat(place)});
      }
    }
  }
}
```

يجب التحقق من المواقع بالترتيب الصحيح - يجب التحقق من الأماكن التي وصل إليها الروبوت في وقت سابق. لا يمكننا فحص مكان بمجرد وصولنا إليه ، لأنه يجب علينا فورًا فحص الأماكن التي تأتي من تلك النقطة ، وما إلى ذلك ؛ بينما قد تكون هناك طرق أقصر لم يتم استكشافها على الإطلاق.

لذلك ، تحتفظ الوظيفة بقائمة مهام. هذه القائمة عبارة عن مجموعة من الأماكن التي يجب استكشافها في الخطوة التالية ، جنبًا إلى جنب مع المسار الذي يأخذنا إلى هناك. تحتوي قائمة المهام هذه مبدئيًا على موضع بداية واحد ومسار فارغ واحد.

ثم يأخذ البحث العنصر التالي في القائمة ويفحصه ، مما يعني أن جميع المسارات التي تمر عبر هذا الموقع يتم رؤيتها. إذا كان أحدهم هو الهدف ، يمكن إرجاع مسار كامل. خلاف ذلك ، سيتم إضافة عنصر جديد إلى القائمة إذا لم ننظر إليه من قبل. خلاف ذلك ، سيتم إضافة عنصر جديد إلى القائمة إذا لم ننظر إلى هذا الموقع من قبل. إذا رأينا ذلك من قبل ، لأننا نفحص أولاً المسارات الأقصر ، أو نجد طريقًا أطول إلى ذلك المكان ، أو مسارًا مساويًا تمامًا للمسار في القائمة ؛ لذلك لا نحتاج إلى فحصه.

```text
function goalOrientedRobot({place, parcels}, route) {
  if (route.length == 0) {
    let parcel = parcels[0];
    if (parcel.place != place) {
      route = findRoute(roadGraph, place, parcel.place);
    } else {
      route = findRoute(roadGraph, place, parcel.address);
    }
  }
  return {direction: route[0], memory: route.slice(1)};
}
```

يستخدم هذا الروبوت مقدار ذاكرته كقائمة اتجاهات للتحرك ، تمامًا مثل الروبوت. عندما تكون هذه القائمة فارغة ، يجب أن يكتشف الروبوت الخطوة التالية. للقيام بذلك ، ينتقل إلى الحزمة الأولى التي لم يتم تسليمها في المجموعة ، وإذا لم تتم إزالة هذه الحزمة بعد ، فقم بتخطيط مسار إليها. إذا تم تسليمها بالفعل ، فلا يزال يتعين تسليمها ، لذلك يقوم الروبوت بإنشاء مسار إلى عنوان التسليم.

دعونا نرى كيف يعمل.

```text
runRobotAnimation(VillageState.random(),
                  goalOrientedRobot, []);
```

يسلم هذا الروبوت عادة 5 حزم في 16 حركة. إنه يعمل بشكل أفضل قليلاً من routeRobot ولكنه بالتأكيد لم يتم تحسينه بعد.

### Exercises  تمارين

#### Measuring a robot قياس الروبوت  

من الصعب جدًا مقارنة الروبوتات بشكل صحيح بناءً على حل عدد محدود من المشكلات. ربما يواجه الروبوت عن طريق الخطأ مشاكل سهلة أو مشاكل تعمل بشكل أفضل لحلها. لكن الروبوتات الأخرى ليس لديها هذه الشروط.











