# Modules النماذج

> اكتب رمزًا يسهل حذفه وليس من السهل توسيعه
>
> Tef, Programming is Terrible

![](.gitbook/assets/image.png)

البرنامج المثالي له هيكل واضح تمامًا. من السهل شرح الطريقة التي يعمل بها ، ويلعب كل جزء دورًا محددًا جيدًا.

عادةً ما ينمو البرنامج الحقيقي عضوياً. يتم إضافة ميزات جديدة إلى التطبيق حسب الحاجة. الهيكلة - والحفاظ على الهيكل - عمل اضافي . إنه عمل لن يؤتي ثماره إلا في المستقبل ، إنه شيء سترى فوائده فقط في المستقبل ، عندما يكون شخص ما على وشك العمل في البرنامج مرة أخرى. لذلك قد تميل إلى تجاهلها وترك أجزاء من البرنامج تعترض طريقك.

في الممارسة العملية ، هذا الإهمال يخلق مشكلتين. أولاً ، من الصعب فهم نظام بدون بنية. إذا كانت جميع أجزاء البرنامج على اتصال بأجزاء أخرى ، فمن الصعب فحص جزء من البرنامج بشكل منفصل. يجب أن يكون لديك فهم عام وشامل للبرنامج. ثانيًا ، إذا كنت ترغب في استخدام أي من ميزات هذه البرامج في مكان آخر ، فقد يكون من الأسهل كتابة هذه الميزة بشكل منفصل عن البرنامج من البداية.

غالبًا ما تستخدم عبارة "كرة كبيرة من الطين" لمثل هذا الحجم الكبير. ، برامج غير منظمة. كل شيء يلتصق ببعضه البعض ، وعندما تحاول انتقاء قطعة ، يتفكك كل شيء وتتسخ يديك.

### Modules

استخدام الوحدات هو محاولة لتجنب مثل هذه المشاكل. الوحدة النمطية هي جزء من البرنامج يحدد الأجزاء الأخرى من البرنامج التي تعتمد عليها \(تبعياتها\) والإمكانيات التي توفرها لاستخدام الوحدات النمطية الأخرى \(واجهتها\).

علاقات الوحدة تشبه إلى حد بعيد علاقات الكائن ، كما تعلمنا في الفصل [Chapter 6](https://eloquentjavascript.net/06_object.html#interface). إنهم يجعلون جزءًا من الوحدة متاحًا للعالم الخارجي ويحافظون على خصوصية البقية. من خلال تقييد الطرق التي تتفاعل بها الوحدات مع بعضها البعض ، يصبح النظام أشبه بـ LEGO ، حيث تتفاعل القطع من خلال موصلات محددة جيدًا ، وأقل مثل الطين ، حيث يختلط كل شيء مع كل شيء.

تسمى الاتصالات بين الوحدات النمطية التبعيات. عندما تحتاج وحدة نمطية إلى جزء من وحدة أخرى ، يُقال إنها تعتمد على تلك الوحدة. بمجرد تحديد هذه التبعية صراحةً في الوحدة نفسها ، يمكن استخدامها لتحديد الوحدات النمطية الأخرى المطلوبة لتشغيل وحدة نمطية معينة وتحميل تلك التبعيات تلقائيًا.

لفصل الوحدات بهذه الطريقة ، من الضروري أن يكون لكل منها نطاقه الخاص.

مجرد وضع كود JavaScript في ملفات منفصلة لا يسمح بذلك. لا تزال الملفات تشترك في نفس مساحة الاسم العمومية. قد يتداخلون عن قصد أو عن قصد مع متغيرات بعضهم البعض ، وستظل بنية التبعية غير شفافة. يمكننا أن نفعل ما هو أفضل ، وهو ما سنراه لاحقًا.

قد يكون تصميم هيكل الوحدة الصحيح لتطبيق ما أمرًا صعبًا. في المرحلة التي ما زلت تستكشف فيها المشكلة ، وتجربة أشياء مختلفة ، قد لا تكون مهتمًا بالتفكير كثيرًا في الهيكلة ، لأنها قد تكون مشتتة للغاية. بمجرد أن تحقق نتيجة قوية وموثوقة ، فقد حان الوقت لاتخاذ إجراء لتنظيم البرنامج.

### Packages

إحدى مزايا بناء برنامج من أجزاء منفصلة ، والقدرة على تشغيل تلك القطع بمفردها ، هو أنك قد تكون قادرًا على تطبيق نفس القطعة في برامج مختلفة. لكن كيف تقوم بإعداده؟ افترض أنني أريد استخدام دالة parseINI التي كتبناها في الفصل [Chapter 9](https://eloquentjavascript.net/09_regexp.html#ini)  في برنامج آخر. إذا كان من الواضح ما تحتويه هذه الوظيفة \(وهو غير موجود هنا\) ، فيمكنني ببساطة نسخ الرمز المطلوب إلى مشروعي الجديد واستخدامه. ولكن في هذه الحالة ، إذا وجدت مشكلة في هذا الرمز ، فمن المحتمل أن أقوم بإصلاحها فقط في البرنامج الذي أعمل عليه وأنسى إصلاحه في برنامج آخر أيضًا.

بمجرد نسخ الرمز ، ستجد أنك تهدر وقتك وطاقتك في نقل النسخ بين التطبيقات وتحديثها.



هذا هو المكان  _packages_  الذي تأتي فيه الحزم. الحزمة عبارة عن جزء من التعليمات البرمجية التي يمكن توزيعها \(نسخها وتثبيتها\). يمكن أن تحتوي الحزمة على وحدة نمطية واحدة أو أكثر وتحتوي أيضًا على معلومات حول الحزم الأخرى التي تعتمد عليها. تأتي الحزمة أيضًا مصحوبة بوثائق تصف كيفية عملها ، لذلك سيتمكن أولئك الذين لم يكتبوا الحزمة من استخدامها.

عند العثور على مشكلة في حزمة أو إضافة ميزة جديدة ، يتم تحديث الحزمة. الآن يمكن للبرامج التي تعتمد عليها \(والتي قد تكون أيضًا حزمًا\) الترقية إلى الإصدار الجديد.

العمل بهذه الطريقة يتطلب بنية تحتية. نحتاج إلى مكان لتخزين الحزم والبحث عنها ، وطريقة مباشرة لتثبيتها وتحديثها. في عالم JavaScript ، يتم توفير هذه البنية التحتية بواسطة NPM على \([https://npmjs.org](https://npmjs.org)\).

يتكون NPM من جزأين: خدمة عبر الإنترنت حيث يمكن للأشخاص تنزيل الحزم وتحميلها ، وتطبيق \(يأتي مع Node.js\) يساعدك على إدارتها.

في وقت كتابة هذا التقرير ، كان هناك أكثر من نصف مليون حزمة مختلفة متاحة على NPM. يجب أن أذكر أن العديد من هذه الحزم غير مجدية ، ولكن تقريبًا أي حزمة مفيدة متاحة بشكل عام يمكن العثور عليها هناك. على سبيل المثال ، يوجد محلل ملفات ini ، مشابه لما أنشأناه في الفصل  [Chapter 9](https://eloquentjavascript.net/09_regexp.html) ، في حزمة تسمى ini.

سيقدم لك الفصل  [Chapter 20](https://eloquentjavascript.net/20_node.html)  كيفية تثبيت الحزم محليًا باستخدام برنامج سطر الأوامر npm.

وجود حزم عالية الجودة وقابلة للتنزيل لا تقدر بثمن. هذا يعني أنه يمكننا في كثير من الأحيان تجنب إعادة اختراع برنامج كتبه 100 شخص من قبل والحصول على تنفيذ قوي ومُختبر جيدًا بضغطة زر قليلة.

البرمجيات رخيصة النسخ ، لذا بمجرد أن يكتبها شخص ما ، فإن توزيعها على أشخاص آخرين يعد عملية فعالة. ولكن كأول شخص يكتبها ، يتطلب الأمر مزيدًا من العمل للرد على الأشخاص الذين يجدون مشاكل في الكود أو يطلبون ميزة جديدة.

بشكل افتراضي ، أنت تمتلك حقوق النشر للرمز الذي تكتبه ، ولا يجوز لأشخاص آخرين استخدامه إلا بإذن منك. ولكن نظرًا لأن بعض الأشخاص لطيفون تمامًا ولأن نشر برامج جيدة يمكن أن يساعد في جعلك مشهورًا قليلاً بين المبرمجين ، يتم نشر العديد من الحزم بموجب ترخيص يسمح صراحة للآخرين باستخدامه.

يتم ترخيص معظم الكود على NPM بهذه الطريقة. تتطلب بعض التراخيص أن تقوم أيضًا بنشر التعليمات البرمجية التي تقوم بإنشائها أعلى الحزمة بموجب نفس الترخيص. يستخدم مجتمع JavaScript في الغالب النوع الأخير من الترخيص. عند استخدام حزم الأشخاص الآخرين ، تأكد من أنك على دراية بترخيصهم.

### Improvised modules توفير وحدات

حتى عام 2015 ، لم يكن للغة JavaScript نظام وحدات مدمج. ومع ذلك ، كان الناس يبنون أنظمة كبيرة في JavaScript لأكثر من عقد ، وكانوا بحاجة إلى وحدات.

لذلك قاموا بتصميم أنظمة الوحدات الخاصة بهم فوق اللغة. يمكنك استخدام وظائف JavaScript لإنشاء نطاقات وكائنات محلية لتمثيل واجهات الوحدة interfaces النمطية.

المثال التالي عبارة عن وحدة نمطية للاختيار بين أسماء الأيام وعددها                           \(as returned by `Date`’s `getDay` method\)                                            تتكون واجهته من  `weekDay.name` و `weekDay.number`               يتم تكوينه وإخفاء أسماء المتغيرات المحلية في مجال الوظيفة التي يتم استدعاؤها على الفور.

```text
const weekDay = function() {
  const names = ["Sunday", "Monday", "Tuesday", "Wednesday",
                 "Thursday", "Friday", "Saturday"];
  return {
    name(number) { return names[number]; },
    number(name) { return names.indexOf(name); }
  };
}();

console.log(weekDay.name(weekDay.number("Sunday")));
// → Sunday
```

يوفر هذا النمط من الوحدات العزلة ، إلى حد ما ، لكنه لا يعلن عن التبعيات. بدلاً من ذلك ، فإنه يضع واجهته في النطاق العالمي ويتوقع أن تقوم تبعياته ، إن وجدت ، بالشيء نفسه. لفترة طويلة كان هذا هو النهج الرئيسي المستخدم في برمجة الويب ، لكنه في الغالب عفا عليه الزمن الآن.

إذا أردنا جعل علاقات التبعية جزءًا من الكود ، فسيتعين علينا التحكم في تبعيات التحميل. القيام بذلك يتطلب القدرة على تنفيذ الجمل كرمز. يمكن لـ JavaScript القيام بذلك

### Evaluating data as code <a id="eval"></a>

هناك عدة طرق لأخذ البيانات \(سلسلة من التعليمات البرمجية\) وتشغيلها كجزء من البرنامج الحالي.

إن أوضح طريقة هي استخدام المعامل Eval ، الذي ينفذ سلسلة في نطاقها الحالي. عادة ما تكون هذه فكرة سيئة لأنها تكسر بعض الخصائص التي تمتلكها النطاقات عادةً ، مثل سهولة التنبؤ بالربط الذي يشير إليه اسم معين.

```text
const x = 1;
function evalAndReturnX(code) {
  eval(code);
  return x;
}

console.log(evalAndReturnX("var x = 2"));
// → 2
console.log(x);
// → 1
```

من الطرق الأقل خطورة لتفسير البيانات كرمز استخدام مُنشئ الدالة. تتلقى هذه الوظيفة وسيطتين: سلسلة تحتوي على قائمة مفصولة بفواصل بأسماء الوسيطات وسلسلة تحتوي على جسم الوظيفة. تقوم هذه الوظيفة بترميز الرمز إلى قيمة الوظيفة بحيث يكون لها مجالها الخاص ولن تتداخل مع المجالات الأخرى. 

```text
let plusOne = Function("n", "return n + 1;");
console.log(plusOne(4));
// → 5
```

هذا هو بالضبط ما نحتاجه لنظام الوحدات. يمكننا التفاف رمز الوحدة في دالة واستخدام نطاق هذه الوظيفة كنطاق وحدة.

### CommonJS

الطريقة الأكثر شيوعًا لإضافة وحدات إلى JavaScript هي:                                وحدات CommonJS. يستخدمه Node.js وهو النظام الذي تستخدمه معظم حزم NPM.

المفهوم الرئيسي في وحدات CommonJS هو وظيفة تسمى qurequire. عند استخدام هذه الوظيفة مع اسم وحدة التبعية ، تضمن هذه الوظيفة تحميل الوحدة النمطية وإرجاع واجهتها.

نظرًا لأن أداة التحميل تُدرج الوحدة النمطية في وظيفة ، فإن الوحدات النمطية تستولي تلقائيًا على أراضيها المحلية. كل ما عليهم فعله هو استدعاء وظيفة  `require` للوصول إلى تبعياتهم ووضع واجهتهم في الكائن المخصص  `exports` .

توفر هذه الوحدة ، على سبيل المثال ، وظيفة تنسيق التاريخ \(date-formatting\).      يستخدم حزمتين من NPM - ترتيبي لتحويل الأرقام إلى سلاسل مثل "1st" و "2nd" ، وحزمة date-names للحصول على الحروف الإنجليزية في أيام الأسبوع والشهور. تصدر هذه الوحدة النمطية دالة تسمى fomatDate تتلقى كائن Date وسلسلة كقالب template string.

قد تحتوي سلسلة القالب على أكواد توجه التنسيق ، مثل YYYY للعام بأكمله و Do لليوم الترتيبي من الشهر. يمكنك إعطائها سلسلة مثل "MMMM Do YYYY" للحصول على إخراج مثل "22 نوفمبر 2017".

```text
const ordinal = require("ordinal");
const {days, months} = require("date-names");

exports.formatDate = function(date, format) {
  return format.replace(/YYYY|M(MMM)?|Do?|dddd/g, tag => {
    if (tag == "YYYY") return date.getFullYear();
    if (tag == "M") return date.getMonth();
    if (tag == "MMMM") return months[date.getMonth()];
    if (tag == "D") return date.getDate();
    if (tag == "Do") return ordinal(date.getDate());
    if (tag == "dddd") return days[date.getDay()];
  });
};
```

واجهه  `ordinal`  هي وظيفه واحده , بينما تصدر أسماء التاريخ عنصرًا يحتوي على أشياء متعددة - الأيام والشهور عبارة عن مصفوفات أسماء.                                          يعد التدمير ملائمًا جدًا عند إنشاء روابط للواجهات المستوردة.

تضيف الوحدة وظيفة الواجهة الخاصة بها إلى exports حتى تتمكن الوحدات التي تعتمد عليها من الوصول إليها. يمكننا استخدام الوحدة مثل هذا:

```text
const {formatDate} = require("./format-date");

console.log(formatDate(new Date(2017, 9, 13),
                       "dddd the Do"));
// → Friday the 13th
```

يمكننا تحديد require في أبسط أشكاله مثل هذا:

```text
require.cache = Object.create(null);

function require(name) {
  if (!(name in require.cache)) {
    let code = readFile(name);
    let module = {exports: {}};
    require.cache[name] = module;
    let wrapper = Function("require, exports, module", code);
    wrapper(require, module.exports, module);
  }
  return require.cache[name].exports;
}
```

في هذا الكود ، readFile هي وظيفة وهمية تقرأ ملفًا وترجع محتوياته كسلسلة. لا يوفر JavaScript القياسي مثل هذه الوظائف ، ولكن بيئات JavaScript المختلفة ، مثل المتصفح و Node.js ، توفر طرقًا خاصة بها للوصول إلى الملفات. المثال فقط يتظاهر بأن readFile موجود.

لتجنب تحميل نفس الوحدة عدة مرات,require  تتطلب الاحتفاظ بمخزن \(ذاكرة تخزين مؤقت cash\) للوحدات التي تم تحميلها بالفعل. عند استدعائه ، يتحقق أولاً مما إذا كان قد تم تحميل الوحدة المطلوبة ، وإذا لم يكن الأمر كذلك ، يقوم بتحميلها. تتضمن هذه العملية قراءة رمز الوحدة النمطية وإدخالها في وظيفة واستدعائها.

واجهه ordinal راينا من قبل انها ليست كائنا بل  وظيفه.  عيب واحد لوحدات CommonJS هو أنه على الرغم من نظام الوحدة, يمكنك استبدال ذلك بأي قيمة عن طريق الكتابة module.exports. يتم ذلك من خلال العديد من الوحدات النمطية لتصدير قيمة واحدة بدلاً من كائن واجهة.

من خلال تحديد require ، وexports، و `module`  النمطية كمعلمات لوظيفة الغلاف المُنشأة \(وتمرير القيم المناسبة عند تسميته\) , يضمن المُحمل توفر هذه المتغيرات في مجال الوحدة النمطية.

تختلف الطريقة التي يتم بها ترجمة السلسلة المطلوبة إلى اسم ملف فعلي أو عنوان ويب في أنظمة مختلفة. عندما يبدأ بـ "/." أو "/.." ، يتم تفسيره عمومًا على أنه متعلق باسم ملف الوحدة الحالية. لذلك ، "format-date/." هو ملف يسمى format-date.js موجود في نفس المجلد.

عندما يكون الاسم غير نسبي ، يبحث Node.js عن حزمة تحمل الاسم نفسه. في رمز المثال في هذا الفصل ، سنفسر هذه الأسماء على أنها تشير إلى حزم NPM. سنخوض في مزيد من التفاصيل حول كيفية تثبيت واستخدام وحدات NPM في الفصل  [Chapter 20](https://eloquentjavascript.net/20_node.html).

الآن ، بدلاً من كتابة محلل ملفات INI الخاص بنا ، يمكننا استخدام واحد من NPM.

```text
const {parse} = require("ini");

console.log(parse("x = 10\ny = 20"));
// → {x: "10", y: "20"}
```

### ECMAScript modules

تعمل وحدات CommonJS بشكل جيد ، وقد أتاح دمجها مع NPM لمجتمع مطوري JavaScript مشاركة التعليمات البرمجية على نطاق واسع.

لكن من الضروري لمسهم قليلاً. يمثل مظهره النصي مشكلة بعض الشيء - على سبيل المثال ، الأشياء التي يضيفها إلى exports غير متوفرة محليًا. ونظرًا لأن requireعبارة عن استدعاء لوظيفة عادية تقبل أي نوع من الوسيطة ، وليس فقط قيم السلسلة ، فقد يكون من الصعب تحديد تبعيات الوحدة النمطية دون تنفيذ التعليمات البرمجية الخاصة بها.

هذا هو السبب في أن معيار JavaScript من عام 2015 يقدم نظام الوحدات الخاص به والمختلف. وعادة ما يطلق عليه وحدات ES ، حيث يرمز ES إلى ECMAScript.         تظل المفاهيم الرئيسية للتبعيات والواجهات كما هي ، لكن التفاصيل تختلف.  لسبب واحد ، تم الآن دمج التدوين في اللغة. بدلاً من استدعاء دالة للوصول إلى تبعية ، يمكنك استخدام كلمة رئيسية خاصة للاستيراد "import ".

```text
import ordinal from "ordinal";
import {days, months} from "date-names";

export function formatDate(date, format) { /* ... */ }
```

وبالمثل ، يتم استخدام الكلمة الأساسية للتصدير لتصدير الأشياء. يمكن استخدامه  أمام تعريف دالة أو فئة أو ربط \(let ، أو const ، أو var\).

واجهة الوحدة النمطية ES ليست قيمة مفردة ولكنها مجموعة من المتغيرات المسماة. تقوم الوحدة المذكورة أعلاه بتعيين formatDate لوظيفة ما. عندما تقوم بالاستيراد من وحدة نمطية أخرى ، فأنت تدخل المتغير ، وليس قيمته ، مما يعني أن ناتج وحدة واحدة قد يغير قيمة متغير واحد في وقت واحد ، والوحدات "" التي أدخلته سوف يرون واحدة جديدة له.

عندما يكون هناك متغير يسمى الافتراضي  `default`  ، فإنه يعتبر قيمة الإخراج الرئيسية للوحدة النمطية. إذا قمت باستيراد وحدة مثل ordinalt في المثال, بدون اقواس حول اسم الربط. ستحصل على ارتباط افتراضي default. لا يزال بإمكان هذه الوحدات تصدير ارتباطات أخرى بأسماء مختلفة بجانب ملفات   export.`default`

لإنشاء تصدير افتراضي,  تكتب التصدير الافتراضي قبل التعبير او اعلان وظيفه او اعلان فئه  

```text
export default ["Winter", "Spring", "Summer", "Autumn"];
```

من الممكن إعادة تسمية الروابط المستوردة باستخدام الكلمة as

```text
import {days as dayNames} from "date-names";

console.log(dayNames.length);
// → 7
```

الفرق المهم الآخر هو أن استيراد الوحدة النمطية ES يتم قبل بدء تشغيل البرنامج النصي للوحدة. أي أن تعريف الاستيراد 'import' لا يظهر داخل الوظيفة أو الكتل ، ويجب وضع أسماء التبعيات ضمن علامات اقتباس ، وليس تعبيرات عشوائية.

في وقت كتابة هذا التقرير ، كان مجتمع JavaScript في طور تبني نمط الوحدة هذا. لكنها كانت عملية بطيئة. استغرق الأمر بضع سنوات ، بعد تحديد التنسيق ، للمتصفحات و Node.js لبدء دعمه. وعلى الرغم من أنهم يدعمونها في الغالب الآن ، إلا أن هذا الدعم لا يزال يعاني من مشكلات ، ولا يزال النقاش حول كيفية توزيع هذه الوحدات من خلال الآلية الوقائية الوطنية مستمرًا

تتم كتابة العديد من المشاريع باستخدام وحدات ES ثم يتم تحويلها تلقائيًا إلى تنسيق آخر عند نشرها. نحن في فترة انتقالية حيث يتم استخدام نظامين مختلفين للوحدات جنبًا إلى جنب ، ومن المفيد أن تكون قادرًا على قراءة وكتابة التعليمات البرمجية في أي منهما.

### Building and bundling   البناء والتجميع

في الواقع ، لا تتم كتابة العديد من مشروعات جافا سكريبت بلغة جافا سكريبت من الناحية الفنية. هناك امتدادات مستخدمة على نطاق واسع ، مثل لهجة JavaScript التي كانت حساسة لأنواع البيانات وتم ذكرها في الفصل  [Chapter 8](https://eloquentjavascript.net/08_error.html#typing). التي تستخدم على نطاق واسع. غالبًا ما يبدأ الأشخاص أيضًا في استخدام الامتدادات المخططة للغة قبل وقت طويل من إضافتهم إلى الأنظمة الأساسية التي تقوم بتشغيل JavaScript بالفعل.

لجعل ذلك ممكنًا ، يقومون بتجميع التعليمات البرمجية الخاصة بهم ، وترجمتها من لهجة JavaScript المختارة إلى JavaScript عادي - أو حتى إلى إصدار سابق من JavaScript - بحيث يمكن للمتصفحات القديمة تشغيلها.

يؤدي تضمين برنامج معياري يتكون من 200 ملف مختلف في صفحة ويب إلى حدوث مشكلاته الخاصة. إذا كان جلب ملف واحد عبر الشبكة يستغرق 50 مللي ثانية ، فإن تحميل البرنامج بأكمله يستغرق 10 ثوانٍ ، أو ربما نصف ذلك إذا كان بإمكانك تحميل عدة ملفات في وقت واحد. هذا الكثير من الوقت الضائع. نظرًا لأن جلب ملف كبير واحد يميل إلى أن يكون أسرع من جلب الكثير من الملفات الصغيرة ، فقد بدأ مبرمجو الويب في استخدام الأدوات التي تقوم بتدوير برامجهم \(التي قاموا بتقسيمها بشق الأنفس إلى وحدات\) مرة أخرى في ملف كبير واحد قبل نشرها على الويب. تسمى هذه الأدوات المجمعات

ويمكننا الذهاب أبعد من ذلك. بصرف النظر عن عدد الملفات ، يحدد حجم الملفات أيضًا مدى سرعة نقلها عبر الشبكة. وهكذا ، اخترع مجتمع JavaScript المصغرات. هذه أدوات تأخذ برنامج JavaScript وتجعله أصغر عن طريق إزالة التعليقات والمسافات البيضاء تلقائيًا وإعادة تسمية الروابط واستبدال أجزاء من التعليمات البرمجية برمز مكافئ يشغل مساحة أقل.

لذلك ليس من غير المألوف أن تكون الشفرة التي تجدها في حزمة NPM أو التي يتم تشغيلها على صفحة ويب قد مرت بمراحل متعددة من التحول - تم تحويلها من JavaScript حديث إلى JavaScript تاريخي ، من تنسيق الوحدة النمطية ES إلى CommonJS ، مجمعة ومُصغرة . لن ندخل في تفاصيل هذه الأدوات في هذا الكتاب لأنها تميل إلى أن تكون مملة وتتغير بسرعة. فقط كن على دراية بأن كود JavaScript الذي تقوم بتشغيله غالبًا لا يكون الرمز كما هو مكتوب.

### Module design  تصميم الوحدة

تعد هيكلة البرامج أحد الجوانب الدقيقة في البرمجة. يمكن تصميم أي وظيفة غير بديهية بطرق مختلفة.

يعد التصميم الجيد للبرنامج شخصيًا - فهناك مفاضلات متضمنة ومسائل تتعلق بالذوق. أفضل طريقة لمعرفة قيمة التصميم الجيد التنظيم هي قراءة الكثير من البرامج أو العمل عليها وملاحظة ما يصلح وما لا يصلح. لا تفترض أن الفوضى المؤلمة "كما هي". يمكنك تحسين بنية كل شيء تقريبًا عن طريق التفكير فيه.

أحد جوانب تصميم الوحدة هو سهولة الاستخدام. إذا كنت تصمم شيئًا ما يقصد استخدامه من قبل عدة أشخاص - أو حتى بنفسك ، في غضون ثلاثة أشهر عندما لا تتذكر تفاصيل ما فعلته - فمن المفيد أن تكون واجهتك بسيطة ويمكن التنبؤ بها.

قد يعني أنك تتبع العقود الحالية. ومن الأمثلة الجيدة على ذلك حزمة ini. تحاكي هذه الوحد كائن Json من خلال توفير  `parse`  و  `stringify` **لكتابه ملف INI .**            ومثل JSON ، فإنه يقوم بعملية التحويل بين الجمل والكائنات البسيطة. لذا فإن الواجهة هنا صغيرة ومألوفة ، وبعد استخدامها لأول مرة ربما تتذكر كيفية استخدامها. 

حتى إذا لم تكن هناك وظيفة قياسية أو حزمة مستخدمة على نطاق واسع لتقليدها ، يمكنك الحفاظ على الوحدات النمطية الخاصة بك قابلة للتنبؤ باستخدام هياكل بيانات بسيطة والقيام بشيء واحد مركّز. توفر العديد من وحدات تحليل ملف INI على NPM وظيفة تقرأ هذا الملف مباشرةً من القرص الثابت وتوزعه ، على سبيل المثال. هذا يجعل من المستحيل استخدام مثل هذه الوحدات في المتصفح ، حيث ليس لدينا وصول مباشر إلى نظام الملفات ، ويضيف تعقيدًا كان من الممكن معالجته بشكل أفضل من خلال إنشاء وحدة مع بعض وظائف قراءة الملفات.

يشير هذا إلى جانب آخر مفيد في تصميم الوحدة - السهولة التي يمكن بها تكوين شيء ما باستخدام تعليمات برمجية أخرى. الوحدات المركزة التي تحسب القيم قابلة للتطبيق في نطاق أوسع من البرامج من الوحدات الأكبر التي تؤدي إجراءات معقدة ذات آثار جانبية. يعد قارئ ملفات INI الذي يصر على قراءة الملف من القرص عديم الفائدة في سيناريو حيث يأتي محتوى الملف من مصدر آخر.

  يمكن عمل شيء ما باستخدام دالة ، استخدم دالة. توفر العديد من قارئات ملفات INI على NPM نمط واجهة يتطلب منك أولاً إنشاء كائن ، ثم تحميل الملف في الكائن الخاص بك ، وأخيراً استخدام طرق متخصصة للحصول على النتائج. هذا النوع من الأشياء شائع في التقليد الموجه للكائنات ، وهو فظيع. بدلاً من إجراء مكالمة واحدة والمضي قدمًا ، يجب عليك أداء طقوس تحريك الكائن الخاص بك عبر حالات مختلفة. ونظرًا لأن البيانات يتم تغليفها الآن في نوع كائن متخصص ، يجب أن تعرف جميع التعليمات البرمجية التي تتفاعل معها حول هذا النوع ، مما يؤدي إلى إنشاء ترابطات غير ضرورية.

غالبًا لا يمكن تجنب تحديد هياكل البيانات الجديدة - يتم توفير عدد قليل فقط من الهياكل الأساسية بواسطة معيار اللغة ، ويجب أن تكون العديد من أنواع البيانات أكثر تعقيدًا من المصفوفة أو الخريطة. ولكن عندما تكفي المصفوفة ، استخدم مصفوفة.

مثال على بنية بيانات أكثر تعقيدًا هو الرسم البياني من الفصل 7. لا توجد طريقة واحدة واضحة لتمثيل رسم بياني في JavaScript. في هذا الفصل ، استخدمنا كائنًا تحتوي خصائصه على مصفوفات من السلاسل - يمكن الوصول إلى العقد الأخرى من تلك العقدة.

هناك العديد من حزم pathfinding المختلفة على NPM ، لكن لا يستخدم أي منها تنسيق الرسم البياني هذا. عادةً ما تسمح لحواف الرسم البياني أن يكون لها وزن ، وهي التكلفة أو المسافة المرتبطة بها. هذا غير ممكن في تمثيلنا.

على سبيل المثال ، هناك حزمة تسمى dijkstrajs. يُطلق على نهج معروف جيدًا في مجال تحديد المسارات ، يشبه إلى حد كبير وظيفة findRoute الخاصة بنا ، خوارزمية Dijkstra ، على اسم Edsger Dijkstra ، الذي كتبها لأول مرة. غالبًا ما تُضاف اللاحقة js إلى أسماء الحزم للإشارة إلى حقيقة أنها مكتوبة بلغة JavaScript. تستخدم حزمة dijkstrajs هذه تنسيقًا بيانيًا مشابهًا لتنسيقنا ، ولكن بدلاً من المصفوفات ، فإنها تستخدم كائنات قيم خصائصها أرقام — أوزان الحواف.

لذا إذا أردنا استخدام هذه الحزمة ، فسيتعين علينا التأكد من تخزين الرسم البياني الخاص بنا بالتنسيق الذي يتوقعه. تتمتع جميع الحواف بنفس الوزن نظرًا لأن نموذجنا المبسط يتعامل مع كل طريق على أنه بنفس التكلفة \(دورة واحدة\).

```text
const {find_path} = require("dijkstrajs");

let graph = {};
for (let node of Object.keys(roadGraph)) {
  let edges = graph[node] = {};
  for (let dest of roadGraph[node]) {
    edges[dest] = 1;
  }
}

console.log(find_path(graph, "Post Office", "Cabin"));
// → ["Post Office", "Alice's House", "Cabin"]
```

هذا عائق أمام الدمج - عندما تستخدم الحزم المختلفة هياكل مختلفة لوصف الشيء نفسه ، سيكون من الصعب دمجها. لذلك ، إذا كنت ترغب في دمج قابلية التوسع في تصميمك ، ففكر في هياكل البيانات التي يستخدمها المبرمجون الآخرون ، واستخدم طريقتهم كلما أمكن ذلك.

summary









