# Asynchronous Programming

> من يستطيع الانتظار بهدوء حتى يستقر الطين؟ من يمكنه البقاء حتى لحظة العمل؟



> Laozi, Tao Te Ching

![](.gitbook/assets/image%20%282%29.png)

الجزء المركزي من الكمبيوتر ، الجزء الذي يتخذ خطوات لتشغيل برنامجنا ، يسمى المعالج. البرامج التي رأيناها حتى الآن هي من النوع الذي يبقي المعالج مشغولاً حتى ينتهي. ترتبط سرعة تنفيذ شيء مثل الحلقة التي تتعامل مع الأرقام إلى حد كبير بسرعة المعالج.  

لكن العديد من البرامج تتفاعل مع أشياء خارج المعالج. على سبيل المثال ، قد يتواصلون عبر شبكة كمبيوتر أو يطلبون بيانات من القرص الصلب - وهو أبطأ بكثير من الحصول عليها من الذاكرة.

عندما يحدث هذا ، يعد تعطيل المعالج أمرًا سيئًا - فقد تكون هناك أشياء أخرى يمكن القيام بها في هذه الأثناء. تتم إدارة هذا إلى حد ما عن طريق نظام التشغيل ، والذي يستخدم المعالج بين برامج متعددة قيد التشغيل. ولكن عندما نريد أن يتمكن برنامج واحد من التشغيل والتقدم أثناء انتظار طلب الشبكة ، فإن نظام التشغيل لا يساعد.

### Asynchronicity عدم التزامن 

في نموذج البرمجة المتزامن ، تحدث الأشياء واحدة تلو الأخرى. عندما تستدعي دالة تؤدي إجراءً طويل المدى ، فإنها تعود فقط عند انتهاء الإجراء ويمكنها إرجاع النتيجة. هذا يوقف برنامجك للوقت الذي يستغرقه الإجراء.

يمكن مقارنة البرمجة المتزامنة وغير المتزامنة بمثال صغير: برنامج يتلقى المعلومات من مصدرين على الشبكة ثم يجمع النتائج.

في بيئة متزامنة ، حيث يعود الطلب فقط عند الانتهاء ، فإن أسهل طريقة للقيام بذلك هي إرسال الطلبات واحدة تلو الأخرى. هذا له عيب في أن الطلب الثاني سيبدأ فقط عند انتهاء الطلب الأول. إجمالي الوقت المستغرق سيكون على الأقل مجموع أوقات الرد.

في بيئة متزامنة ، حيث لا تعود وظيفة الطلب إلا بعد أن تنتهي من عملها ، فإن أسهل طريقة لتنفيذ هذه المهمة هي جعل الطلبات واحدة تلو الأخرى.هذا له عيب في أن الطلب الثاني سيبدأ فقط عند انتهاء الطلب الأول. إجمالي الوقت المستغرق سيكون على الأقل مجموع أوقات الرد.

الحل لهذه المشكلة ، في نظام متزامن ، هو استخدام خيوط تحكم إضافية.  _thread_ هو برنامج آخر قيد التشغيل يمكن تشغيله بواسطة نظام التشغيل بين البرامج الأخرى - نظرًا لأن معظم أجهزة الكمبيوتر الحديثة بها معالجات متعددة ، يمكن تشغيل thread متعددة على معالج واحد في كل مرة. يمكن لسلسلة رسائل أخرى أن تبدأ الطلب الثاني ، ثم تنتظر كلتا السلسلتين نتيجة طلبهما ، وبعد ذلك يقومان بالمزامنة مرة أخرى ودمج النتائج.

في الرسم البياني أدناه ، تشير الخطوط المتقطعة إلى الوقت الذي يستغرقه البرنامج للتشغيل بشكل طبيعي ، وتشير الخطوط المتقطعة إلى الوقت الذي تستغرقه الشبكة للاستجابة. في النموذج المتزامن ، يعتبر الوقت الذي تستغرقه الشبكة جزءًا من الجدول الزمني لمؤشر الترابط المحدد. في النموذج غير المتزامن ، يؤدي بدء عملية متعلقة بالشبكة إلى إنشاء تقسيم في المخطط الزمني من الناحية المفاهيمية. يستمر البرنامج الذي بدأ هذا الانقسام في العمل ، وتعمل هذه العملية بالتوازي وتُعلم البرنامج عند انتهائه. 

![](.gitbook/assets/image%20%2812%29.png)

هناك طريقة أخرى لوصف الاختلاف وهي أن انتظار انتهاء الإجراءات متضمن في النموذج المتزامن ، بينما يكون صريحًا ، تحت سيطرتنا ، في النموذج غير المتزامن.

عدم التزامن يقطع كلا الاتجاهين. إنه يجعل التعبير عن البرامج التي لا تتناسب مع نموذج الخط المستقيم للتحكم أسهل ، ولكنه يمكن أيضًا أن يجعل برامج التعبير التي تتبع خطًا مستقيمًا أكثر صعوبة. في هذا الفصل ، سوف ننظر في طرق حل هذا التباين.

تقوم كل من منصات برمجة JavaScript الرئيسية - المتصفحات و Node.js - بتشغيل عمليات قد تستغرق وقتًا طويلاً غير متزامنة ولا تستخدم سلاسل العمليات. . نظرًا لأن البرمجة على \(threads\) عمل شاق \(في هذا النوع من البرمجة ، يصبح فهم وظيفة البرنامج أكثر صعوبة بسبب القيام بالعديد من الأشياء في وقت واحد\) ، فإن الطريقة غير المتزامنة بشكل عام شيء جيد.

### Crow tech

يدرك معظم الناس حقيقة أن الغربان طيور ذكية جدًا. يمكنهم استخدام الأدوات والتخطيط المسبق وتذكر الأشياء وحتى توصيل هذه الأشياء فيما بينهم.

ما لا يدركه معظم الناس هو أن الغربان لديها العديد من القدرات التي تخفيها عنا. لقد أخبرني خبير ذو سمعة طيبة \(وإن كان غريب الأطوار إلى حد ما\) في كورفيد أن تكنولوجيا الغراب ليست بعيدة عن التكنولوجيا البشرية ، وستصل إلى البشر قريبًا..

على سبيل المثال ، تمتلك العديد من ثقافات الغراب القدرة على بناء أجهزة الكمبيوتر. هذه الأجهزة ليست إلكترونية مثل أجهزة الحوسبة البشرية ، لكنها تستغل سلوكيات الحشرات الصغيرة ، الأنواع القريبة من النمل الأبيض التي طورت علاقة تعايش مع الغربان. تزودهم الطيور بالطعام ، وفي المقابل تبني الحشرات وتدير مستعمراتها المعقدة التي تقوم بإجراء الحسابات بمساعدة الكائنات الحية الموجودة بداخلها.

عادة ما توجد هذه المستعمرات في أعشاش كبيرة طويلة العمر. تعمل الطيور والحشرات معًا لبناء شبكة من الهياكل الطينية المنتفخة ، مخبأة بين أغصان العش ، حيث تعيش الحشرات وتعمل فيها

للتفاعل مع الأجهزة الأخرى ، تستخدم هذه الأجهزة إشارات ضوئية. تعشش الغربان قطعًا من مادة عاكسة في سيقان خاصة مخصصة للتواصل ، وتستهدفها الحشرات لتسليط الضوء على عش آخر ، وتشفير البيانات في سلسلة من الومضات القصيرة. هذا يعني أن الأعشاش التي لديها اتصال مرئي فقط يمكنها التفاعل مع بعضها البعض.

قام صديق الغراب لدينا برسم خريطة لشبكة عش الغراب في قرية Hières-sur-Amby ، على ضفاف نهر الرون. تُظهر هذه الخريطة كيف تبدو الأعشاش ووصلاتها:

![](.gitbook/assets/image%20%2819%29.png)

في مثال مذهل للتطور المتقارب ، تشغل أجهزة الكمبيوتر الغراب JavaScript. في هذا الفصل سوف نكتب بعض وظائف الشبكات الأساسية لهم.

### Callbacks   وظائف رد الاتصال

تتمثل إحدى طرق البرمجة غير المتزامنة في جعل الوظائف التي تؤدي إجراءً بطيئًا تأخذ وسيطة إضافية ، وهي وظيفة رد الاتصال. في هذه الطريقة ، يتم تنفيذ الوظيفة الرئيسية وإنهائها ، ثم يتم استدعاء وظيفة رد الاتصال 'callback' بالنتائج المستلمة من الوظيفة الرئيسية.

على سبيل المثال ، وظيفة setTimeout ، المتوفرة في Node.js والمتصفحات ، تنتظر الجزء المحدد من الألف من الثانية  \(a second is a thousand milliseconds\)ثم تستدعي وظيفة.

```text
setTimeout(() => console.log("Tick"), 500);
```

هذا التوقع عادة ليس له العديد من التطبيقات الهامة ؛ لكن في بعض الأحيان قد يكون مفيدًا ، مثل تحديث رسم متحرك أو التحقق من مدة وجود شيء ما في البرنامج.

يعني إجراء العديد من العمليات غير المتزامنة في صف باستخدامcallback أنه يجب عليك الاستمرار في إرسال وظائف جديدة لمتابعة الحساب بعد كل عملية.

تحتوي معظم أجهزة الكمبيوتر في عش الغراب على مصباح تخزين بيانات طويل المدى ، حيث يتم حفر أجزاء من المعلومات في أغصان بحيث يمكن استرجاعها لاحقًا. يستغرق الحفر أو العثور على جزء من البيانات لحظة ، لذا فإن واجهة التخزين طويل المدى غير متزامنة وتستخدم وظائف رد الاتصال.

تخزن مصابيح التخزين أجزاء من البيانات القابلة للتشفير JSON تحت الأسماء. . قد يقوم الغراب بتخزين معلومات ذاكرة التخزين المؤقت للطعام على أنها "مخابئ للطعام" ، والتي يمكن أن تحتوي على مجموعة من الرسائل التي تشير إلى أجزاء أخرى من المعلومات ، وهي المعلومات التي تصف ذاكرة التخزين المؤقت الفعلية. للبحث عن مكان يختبئ فيه "food caches" في مناديل التخزين في Big Oak Nest ، يمكن للغراب تنفيذ رمز مثل ما يلي.

```text
import {bigOak} from "./crow-tech";

bigOak.readStorage("food caches", caches => {
  let firstCache = caches[0];
  bigOak.readStorage(firstCache, info => {
    console.log(info);
  });
});
```

تمت ترجمة جميع الأسماء والنصوص الملزمة من لغة الغراب إلى اللغة الإنجليزية

هذا النمط قابل للبرمجة. ولكن مع كل عملية غير متزامنة ، يزداد مقدار المسافة البادئة ، لأنه ستكون هناك حاجة إلى وظيفة أخرى. بالنسبة للمهام الأكثر تعقيدًا ، مثل إجراء عدة عمليات في نفس الوقت ، يمكن أن تكون تقنية التشفير هذه محرجة بعض الشيء.

تم تصميم أجهزة كمبيوتر Crow nest للتواصل باستخدام أزواج الطلب والاستجابة \(request-response\). هذا يعني أن عشًا ما يرسل رسالة إلى عش آخر ، والذي يرسل رسالة على الفور مرة أخرى ، لتأكيد الاستلام وربما يتضمن ردًا على سؤال تم طرحه في الرسالة.

يتم تمييز كل رسالة بعلامة type, الذي يحدد كيفية التعامل معها. يمكن أن تحدد الكود الخاص بنا معالجات لأنواع طلبات معينة ، وعندما يأتي مثل هذا الطلب ، يتم استدعاء المعالج لإنتاج استجابة.

توفر الواجهة التي تم تصديرها بواسطة وحدة "crow-tech/." وظائف قائمة على رد الاتصال للاتصال. الاعشاش لها طريقه تسمى send لاارسل الطلب. يتوقع اسم العش الهدف ونوع الطلب ومحتوى الطلب كوسائطه الثلاث الأولى ، ويتوقع استدعاء دالة عندما تأتي الاستجابة كوسيطة رابعة وأخيرة.

```text
bigOak.send("Cow Pasture", "note", "Let's caw loudly at 7PM",
            () => console.log("Note delivered."));
```

ولكن لجعل الأعشاش قادرة على تلقي هذا الطلب ، يتعين علينا أولاً تحديد نوع طلب باسم "note".  يجب تشغيل الكود الذي يتعامل مع الطلبات ليس فقط على هذا الكمبيوتر المتداخل ولكن على جميع الأعشاش التي يمكنها تلقي رسائل من هذا النوع. سنفترض فقط أن الغراب يطير ويثبت كود المعالج الخاص بنا على جميع الأعشاش.

```text
import {defineRequestType} from "./crow-tech";

defineRequestType("note", (nest, content, source, done) => {
  console.log(`${nest.name} received note: ${content}`);
  done();
});
```

تحدد الدالة selectRequestType نوع طلب جديدًا. في المثال ، تمت إضافة دعم طلبات "note" ، والتي ترسل في الواقع ملاحظة واحدة فقط إلى العش المحدد.  يستخدم التنفيذ الخاص بنا console.log للموافقة على الطلب. الأعشاش لها خاصية تسمى name الذي يحمل اسمه.

الوسيطة الرابعة المعطاة للمعالج ، done، هي وظيفة رد نداء يجب أن يستدعيها عند الانتهاء من الطلب. إذا استخدمنا قيمة الإرجاع \(عن طريق return\) لوظيفة المعالجة كقيمة استجابة ، فلن يتمكن معالج الطلب من إجراء عملية غير متزامنة بنفسه. عادةً ما تعود الوظيفة التي تقوم بمهمة غير متزامنة قبل القيام بهذه المهمة ويتم تعيينها لتنفيذ callback الاتصال بعد تنفيذ المهمة. لذلك نحن بحاجة إلى آليات غير متزامنة - في هذا المثال ، وظيفة رد اتصال أخرىcallback  - للإشارة إلى أن الإجابة جاهزة.

بطريقة ما ، عدم التناسق معدي. يجب أن تكون أي وظيفة تستدعي وظيفة تعمل بشكل غير متزامن نفسها غير متزامنة ، ويمكن إجراؤها باستخدام callback أو آلية مماثلة لتقديم النتيجة. يعد استدعاء callback أكثر تعقيدًا وإشكالية من إرجاع قيمة ببساطة ؛ لذلك ليس من المثير للاهتمام استخدام هذه الطريقة لبناء أجزاء كبيرة من برنامجك.

### Promises الوعود 

غالبًا ما يكون العمل مع المفاهيم المجردة أسهل عندما يمكن تمثيل هذه المفاهيم بالقيم. في حالة الإجراءات غير المتزامنة ، يمكنك ، بدلاً من ترتيب استدعاء دالة في وقت ما في المستقبل ، إرجاع كائن يمثل هذا الحدث المستقبلي.

هذا هو ما هو promise الصنف القياسي. الوعد promise هو إجراء غير متزامن قد يكتمل في مرحلة ما وينتج قيمة. وهي قادرة على إخطار أي شخص مهتم عندما تكون قيمتها متاحة.

أسهل طريقة لعمل وعد هي الاتصال  `Promise.resolve`. تضمن هذه الوظيفة أن المبلغ الذي تقدمه يتوافق مع promise. إذا كان وعدًا بالفعل ، فسيتم إعادته - وإلا ، فستتلقى وعدًا جديدًا سينتهي على الفور بقيمتك كنتيجة لذلك.

```text
let fifteen = Promise.resolve(15);
fifteen.then(value => console.log(`Got ${value}`));
// → Got 15
```

للحصول على نتيجة الوعد ، يمكنك استخدام طريقه then , تسجل هذه الطريقة دالة رد نداء يتم استدعاؤها عند الوفاء بوعد وإنشاء قيمة. . يمكنك إضافة وظائف رد نداء متعددة إلى الوعد ، وسيتم استدعاء كل منهم ، حتى إذا قمت بإضافتهم بعد الوفاء بالوعد.

ولكن هذا ليس كل ما تفعله طريقة then, تقوم بإرجاع وعد آخر ، والذي يحسم القيمة التي ترجعها دالة المعالج أو إذا أدى ذلك إلى إرجاع الوعد ، وانتظر هذا الوعد ثم قرر نتيجته.

من المفيد التفكير في الوعود كجهاز لنقل القيم إلى واقع غير متزامن. القيمة العادية موجودة ببساطة. القيمة الموعودة هي قيمة قد تكون موجودة بالفعل أو قد تظهر في وقت ما في المستقبل. الحسابات المعرفة من حيث الوعود تعمل على هذه القيم المغلفة ويتم تنفيذها بشكل غير متزامن عندما تصبح القيم متاحة.

لإنشاء وعد ، يمكنك استخدام Promise كمنشئ. لها واجهة غريبة إلى حد ما - يتوقع المنشئ وظيفة كوسيطة ، والتي يطلق عليها على الفور ، ويمررها وظيفة يمكن استخدامها لحل الوعد .إنه يعمل بهذه الطريقة ، بدلاً من طريقة resolveعلى سبيل المثال ، بحيث لا يمكن حلها إلا الكود الذي أنشأ الوعد.

هذه هي الطريقة التي يمكنك بها إنشاء واجهة قائمة على الوعد لوظيفة readStorage

```text
function storage(nest, name) {
  return new Promise(resolve => {
    nest.readStorage(name, result => resolve(result));
  });
}

storage(bigOak, "enemies")
  .then(value => console.log("Got", value));
```

تنتج هذه الوظيفة غير المتزامنة قيمة كبيرة. هذه هي الميزة الرئيسية للوعود - فهي تبسط استخدام الدوال غير المتزامنة.                                                                             بدلاً من الاضطرار إلى تمرير عمليات الاسترجاعات ، تبدو الدوال المستندة إلى الوعد مشابهة للوظائف العادية: فهي تأخذ المدخلات كوسيطات وتعيد مخرجاتها.                                  الاختلاف الوحيد هو أن الإخراج قد لا يكون متاحًا بعد.

### Failure

يمكن أن تفشل حسابات JavaScript العادية وتتسبب في حدوث استثناء. غالبًا ما تتطلب الحوسبة غير المتزامنة شيئًا مشابهًا. قد يفشل طلب الشبكة أو يُنشئ رمزًا استثنائيًا يعد جزءًا من عملية حسابية غير متزامنة.

واحدة من أكثر المشاكل إلحاحًا في أسلوب رد الاتصال للبرمجة غير المتزامنة هي أنه يجعل من الصعب للغاية التأكد من إبلاغ عمليات الاسترجاعات بالفشل بشكل صحيح.

أحد الحلول الشائعة هو النظر في وسيطة رد النداء الأولى لتحديد فشل الإجراء ، والوسيطة الثانية لاحتواء القيمة التي سيتم إنشاؤها في حالة نجاح الإجراء. يجب أن تتحقق وظائف رد الاتصال هذه دائمًا مما إذا كانت قد تلقت استثناءًا وأن تتأكد من أن أي مشاكل تسببها ، مثل الاستثناءات التي تم إنشاؤها ، تتم إدارتها بواسطة الوظائف التي تستدعيها وتعطيها للوظيفة الصحيحة.

الوعود تجعل هذا أسهل. يمكن حلها \(انتهى الإجراء بنجاح\) أو رفضها \(فشل\)حل معالجات يتم استدعاء وظائف معالجة النجاح \(المسجلة باستخدام طريقة then\) فقط عندما تنجح العملية ويتم تعيين حالات الرفض تلقائيًا إلى وعد جديد يتم إرجاعه بحلول ذلك الوقت. وعندما تُنشئ دالة handlerاستثناءً ، فإنها تتسبب تلقائيًا في رفض الوعد الذي تم إنشاؤه من خلال استدعاء أسلوبها آنذاك. لذلك إذا فشل أي عنصر في سلسلة من الإجراءات غير المتزامنة ، يتم تمييز نتيجة السلسلة بأكملها على أنها مرفوضة "rejected"، ولا يتم استدعاء معالجات ناجحة بعد النقطة التي فشلت فيها.

تمامًا مثل إبرام الوعد الذي قدم قيمة ، فإن رفضه يوفر أيضًا قيمة ، تُعرف عمومًا باسم سبب الرفض. عندما يتسبب استثناء في دالة معالجة في رفض ، يتم استخدام قيمة الاستثناء كسبب. وبالمثل ، عندما يعيد المعالج وعدًا تم رفضه ، يتدفق هذا الرفض إلى الوعد التالي. هناك وظيفة تسمى Promise.reject تنشئ على الفور وعدًا مرفوضًا جديدًا.

للتعامل بشكل صريح مع حالات الرفض هذه ، فإن للوعود طريقة catch التي تسجّل المعالج ليتم استدعاؤه عند رفض الوعد, على غرار then تستخدم العوامل للعثور على النتيجة الصحيحة. كما أنه يشبه then إلى حد كبير من حيث أنه يعود بوعد جديد ، التي تتناسب مع قيمة الوعد الأصلي إذا تم حلها بشكل طبيعي ونتيجة لمعالج المصيد بخلاف ذلك. إذا ألقى معالج catch خطأً ، فسيتم أيضًا رفض الوعد الجديد.

كطريقة أكثر إيجازًا ، يقبل التابع then أيضًا عامل عدم قبول باعتباره الوسيطة الثانية ، بحيث يمكنك تسجيل كلا المشغلين باستدعاء طريقة واحدة.

تتلقى الوظيفة المرسلة إلى مُنشئ  `Promise` وسيطة ثانية بجوار وظيفة resolve، والتي يمكن استخدامها لرفض promiseجديد.

يمكن اعتبار سلسلة قيم الوعد التي تم إنشاؤها بواسطة مكالمات then and catch بمثابة خط أنابيب أثناء القيم غير المتزامنة أو حالات الفشل.نظرًا لأن هذه السلسلة يتم إنشاؤها بواسطة سجلات السائقين ، فإن كل رابط له محرك للنجاح أو الرفض \(أو كليهما\) يتعلق بهما. لا يتم أخذ برامج التشغيل التي لا تتطابق مع نوع الإخراج \(نجاح أو فشل\) في الاعتبار.  ولكن يتم استدعاء العناصر المتطابقة ويحدد ناتجها نوع القيمة التي ستتبع - النجاح عندما تعود قيمة غير وعد ؛ ارفض عند إنشاء استثناء ، وإخراج وعد عند عودة أحدهما. 

```text
new Promise((_, reject) => reject(new Error("Fail")))
  .then(value => console.log("Handler 1"))
  .catch(reason => {
    console.log("Caught failure " + reason);
    return "nothing";
  })
  .then(value => console.log("Handler 2", value));
// → Caught failure Error: Fail
// → Handler 2 nothing
```

مثل الكثير من الاستثناءات غير المُدارة التي تعالجها البيئة ، يمكن لبيئات JavaScript اكتشاف متى تم تجاهل الإخفاق في الوعد وسوف تبلغ عنه كخطأ.

### Networks are hard  الشبكات صعبة

في بعض الأحيان لا يوجد ضوء كافٍ لنظام انعكاس ضوء الغربان لنقل الإشارة ، أو أن هناك شيئًا ما يعوق مسار الإشارة. قد يتم إرسال إشارة ولكن لم يتم استلامها.

في هذه الحالة ، سيؤدي ذلك إلى عدم استدعاء وظيفة رد الاتصال المعطاة لطريقة send مطلقًا ، مما قد يؤدي إلى إيقاف البرنامج دون أي مشكلة. سيكون من الرائع أن تنتهي صلاحية الطلب تلقائيًا وسيتم الإبلاغ عن الفشل بعد فترة زمنية معينة لم يتم تلقي أي استجابة.

كما هو الحال ، سيؤدي ذلك فقط إلى عدم استدعاء رد الاتصال المعطى للإرسال مطلقًا ، مما قد يتسبب في توقف البرنامج دون ملاحظة وجود مشكلة. سيكون من الجيد ، بعد فترة معينة من عدم الحصول على رد ، أن تنتهي مهلة الطلب ويبلغ عن الفشل.

غالبًا ما تكون حالات فشل الإرسال عبارة عن حوادث عشوائية ، مثل تداخل المصباح الأمامي للسيارة مع الإشارات الضوئية ، وقد تؤدي إعادة محاولة الطلب ببساطة إلى نجاحه. لذلك أثناء قيامنا بذلك ، دعنا نجعل وظيفة الطلب لدينا تعيد تلقائيًا محاولة إرسال الطلب عدة مرات قبل أن يستسلم.

ونظرًا لأننا أثبتنا أن الوعود شيء جيد ، فسنجعل أيضًا وظيفة الطلب لدينا ترجع الوعد. من حيث ما يمكنهم التعبير عنه ، فإن عمليات الاسترجاعات والوعود متكافئة. يمكن تغليف الوظائف المستندة إلى رد الاتصال لكشف واجهة قائمة على الوعد ، والعكس صحيح.

حتى عند تسليم طلب واستجابته بنجاح ، قد تشير الاستجابة إلى فشل - على سبيل المثال ، إذا حاول الطلب استخدام نوع طلب غير محدد أو قام بإنشاء معالج خطأ. لدعم هذا ،         `send` and `defineRequestType` 

اتبع الاصطلاح المذكور سابقًا ، حيث يكون الوسيط الأول الذي يتم تمريره إلى عمليات الاسترجاعات هو سبب الفشل ، إن وجد ، والثاني هو النتيجة الفعلية.

يمكن ترجمتها بقبول الوعد ورفضه بواسطة غلاف.

```text
class Timeout extends Error {}

function request(nest, target, type, content) {
  return new Promise((resolve, reject) => {
    let done = false;
    function attempt(n) {
      nest.send(target, type, content, (failed, value) => {
        done = true;
        if (failed) reject(failed);
        else resolve(value);
      });
      setTimeout(() => {
        if (done) return;
        else if (n < 3) attempt(n + 1);
        else reject(new Timeout("Timed out"));
      }, 250);
    }
    attempt(1);
  });
}
```

لأن الوعود يمكن حلها \(أو رفضها\) مرة واحدة فقط ، فهذا سينجح. أول مرة يسمى الحل أو الرفض يحدد نتيجة الوعد ، والمزيد من المكالمات الناتجة عن طلب يعود بعد انتهاء طلب آخر يتم تجاهلها.

لبناء حلقة غير متزامنة ، بالنسبة لعمليات إعادة المحاولة ، نحتاج إلى استخدام دالة تكرارية - لا تسمح لنا الحلقة العادية بالتوقف وانتظار إجراء غير متزامن. تقوم وظيفة  `attempt`  بمحاولة واحدة لإرسال طلب. كما أنه يحدد مهلة ، إذا لم تظهر أي استجابة بعد 250 مللي ثانية ، فإما أن تبدأ المحاولة التالية ، أو إذا كانت هذه هي المحاولة الثالثة ، يرفض الوعد مع وجود مثيل Timeout كسبب.

المحاولة مرة أخرى كل ربع ثانية والتوقف إذا لم تأتي إجابة بعد ثانية واحدة أمر مرغوب فيه بالتأكيد. بالطبع ، من الممكن حتى تلقي طلب ، لكن وظيفة المناولة بطيئة في التصرف ، مما يؤدي إلى تنفيذ عملية الاستلام عدة مرات. نكتب وظائف المعالجة لتغطية هذه المشكلة بحيث لا تضر الرسائل المكررة بالنظام.

بطبيعة الحال ، لن نبني شبكة عالمية مثالية اليوم. لكن هذا سيكون مقبولًا - الغربان ليس لديها توقعات عالية جدًا فيما يتعلق بالحسابات.

للتخلص من عمليات الاسترجاعات تمامًا ، سنذهب إلى أبعد من ذلك ونحدد أيضًا غلافًا لوظيفة selectRequestType التي تسمح لوظيفة المعالج بإرجاع وعد أو قيمة بسيطة وإرفاقها باستدعاء لنا.

```text
function requestType(name, handler) {
  defineRequestType(name, (nest, content, source,
                           callback) => {
    try {
      Promise.resolve(handler(nest, content, source))
        .then(response => callback(null, response),
              failure => callback(failure));
    } catch (exception) {
      callback(exception);
    }
  });
}
```

يتم استخدام Promise.resolve لتحويل القيمة التي أرجعها المعالج  `handler`  إلى وعد إذا لم يكن كذلك بالفعل.

لاحظ أنه يجب تغليف استدعاء المعالج في كتلة try للتأكد من أن أي استثناء يثيره مباشرة يتم إعطاؤه إلى رد الاتصال. يوضح هذا بوضوح صعوبة معالجة الأخطاء بشكل صحيح في نموذج رد الاتصال الأولي - قد ننسى بسهولة الإدارة السليمة للاستثناءات ؛ كما هو مذكور أعلاه ، إذا لم تقم بذلك ، فلن يتم إبلاغ رد الاتصال بالفواصل بشكل صحيح. في الوعود ، يتم ذلك تلقائيًا بحيث يكونون أقل عرضة للخطأ.

### Collections of promises

يحتفظ كل كمبيوتر متداخل بمجموعة من الأعشاش الأخرى ضمن مسافة الإرسال في خاصية neighbors. للتحقق من أي منها يمكن الوصول إليه حاليًا ، يمكنك كتابة وظيفة تحاول إرسال طلب "ping" \(طلب يسأل ببساطة عن استجابة\) لكل منهم ومعرفة أي منها سيعود.

يمكن أن تكون وظيفة Promise.all مفيدة عند العمل مع مجموعة من الوعود التي يتم تنفيذها في نفس الوقت. ترجع هذه الدالة وعدًا ينتظر أن تؤتي كل الوعود في المصفوفة ثمارها ، ثم تطرح النتيجة في مجموعة من القيم التي أوجدتها هذه الوعود \(بنفس الترتيب كما في المصفوفة الأصلية\). إذا تم رفض أي وعد ، فإن نتيجة Promise.all نفسها مرفوضة.

```text
requestType("ping", () => "pong");

function availableNeighbors(nest) {
  let requests = nest.neighbors.map(neighbor => {
    return request(nest, neighbor, "ping")
      .then(() => true, () => false);
  });
  return Promise.all(requests).then(result => {
    return nest.neighbors.filter((_, i) => result[i]);
  });
}
```

عندما لا يكون أحد الجيران متاحًا ، لا نريد أن يفشل الوعد المشترك بالكامل منذ ذلك الحين ، فنحن ما زلنا لا نعرف أي شيء. لذا فإن الوظيفة التي يتم تعيينها على مجموعة الجيران لتحويلها إلى وعود طلب ترفق معالجات تجعل الطلبات الناجحة تنتج الطلبات الصحيحة والمرفوضة تنتج كاذبة.

في محرك الأقراص المخصص لوعد المجموعة ، يزيل filter تلك العناصر ، ينفذ العناصر التي تكون قيمتها المقابلة falseمن مصفوفة  `neighbors` .  يستفيد هذا من حقيقة أن المرشح يرسل فهرس العنصر الحالي في المصفوفة كوسيطته الثانية إلى وظيفة filter الخاصة به \(مثل map أوsome  أو دوال المصفوفة الأخرى التي تعمل بشكل مشابه\)

### Network flooding   تدفق الفيضانات في الشبكة

حقيقة أن الأعشاش لا يمكنها التواصل إلا مع جيرانها تعيق فائدة هذه الشبكة.

تتمثل إحدى طرق الحصول على المعلومات عبر الشبكة في إعداد نوع طلب يتصل تلقائيًا بالجيران الآخرين. ثم يقوم هؤلاء الجيران بتمرير هذه المعلومات إلى جيرانهم حتى تتلقى الشبكة بالكامل الرسالة.

```text
import {everywhere} from "./crow-tech";

everywhere(nest => {
  nest.state.gossip = [];
});

function sendGossip(nest, message, exceptFor = null) {
  nest.state.gossip.push(message);
  for (let neighbor of nest.neighbors) {
    if (neighbor == exceptFor) continue;
    request(nest, neighbor, "gossip", message);
  }
}

requestType("gossip", (nest, message, source) => {
  if (nest.state.gossip.includes(message)) return;
  console.log(`${nest.name} received gossip '${
               message}' from ${source}`);
  sendGossip(nest, message, source);
});
```

لمنع إرسال نفس الرسالة باستمرار عبر الشبكة ، يحتوي كل عش على مجموعة من السلاسل التي تم عرضها مسبقًا. لتعريف هذه المجموعة, نستخدم وظيفة everything - التي تشغل التعليمات البرمجية في كل عش - لإضافة خاصية إلى كائن حالة العش, هذا هو المكان الذي سنحافظ فيه على الحالة المحلية للعش.

عندما يتلقى العش رسالة مكررة ، والتي من المحتمل أن يتم إرسالها حيث لا يرى كل عش الرسائل ، يتم تجاهل هذه الرسالة. ولكن عندما تتلقى رسالة جديدة ، فإنها ترسل هذه الرسالة بحماس إلى جميع الأعشاش باستثناء عش المرسل.

ينشر الأخبار على الشبكة تمامًا كما ينتشر الحبر في الماء. حتى في حالة عدم توفر بعض الاتصالات ، إذا كان هناك طريق بديل لعش معين ، فستصل الأخبار إلى هذا العش من خلاله.

يسمى هذا النوع من اتصالات الشبكة بالفيضان \(flooding\) - مثل الفيضان ، فهو يغطي الشبكة بالكامل بالمعلومات بدلاً من تغطية جميع العقد.

يمكننا الاتصال بـ sendGossip لنرى رسالة تتدفق عبر القرية.

```text
sendGossip(bigOak, "Kids with airgun in the park");
```

### Message routing

إذا أرادت عقدة معينة التحدث إلى عقدة واحدة أخرى ، فإن الفيضانات ليست طريقة فعالة للغاية. خاصة عندما تكون الشبكة كبيرة ، فقد يؤدي ذلك إلى الكثير من عمليات نقل البيانات غير المجدية.

البديل هو إيجاد طريقة للرسائل للانتقال من عقدة إلى أخرى حتى تصل الى وجهتها . تكمن مشكلة هذه الطريقة في أننا يجب أن نعرف خريطة الشبكة. لإرسال طلب إلى عقدة بعيدة ، نحتاج إلى معرفة الأعشاش المجاورة التي تجعل الرسالة أقرب إلى الوجهة. إن إرسالها في الاتجاه الخاطئ لا يقودنا إلى الهدف.

نظرًا لأن كل عش يعرف فقط عن جيرانه المباشرين ، فإنه لا يمتلك المعلومات التي يحتاجها لحساب المسار. يجب أن ننشر المعلومات حول هذه الروابط بطريقة ما إلى جميع الأعشاش ، ويفضل أن يكون ذلك بطريقة تسمح لها بالتغير بمرور الوقت ، عندما يتم التخلي عن الأعشاش أو بناء أعشاش جديدة.

```text
requestType("connections", (nest, {name, neighbors},
                            source) => {
  let connections = nest.state.connections;
  if (JSON.stringify(connections.get(name)) ==
      JSON.stringify(neighbors)) return;
  connections.set(name, neighbors);
  broadcastConnections(nest, name, source);
});

function broadcastConnections(nest, name, exceptFor = null) {
  for (let neighbor of nest.neighbors) {
    if (neighbor == exceptFor) continue;
    request(nest, neighbor, "connections", {
      name,
      neighbors: nest.state.connections.get(name)
    });
  }
}

everywhere(nest => {
  nest.state.connections = new Map();
  nest.state.connections.set(nest.name, nest.neighbors);
  broadcastConnections(nest, nest.name);
});
```

في المقارنة ، يتم استخدام JSON.stringify لأن == ، على الكائنات والمصفوفات ، ترجع صحيحًا فقط إذا كان لكلا الجانبين نفس القيمة ، وهذا ليس ما نحتاجه هنا. تعد مقارنة سلاسل JSON طريقة بدائية ولكنها فعالة لمقارنة محتواها.

تبدأ العقد على الفور في بث اتصالاتها ، والتي يجب ، ما لم تكن بعض الأعشاش غير قابلة للوصول تمامًا ، إعطاء كل عش خريطة للرسم البياني الحالي للشبكة بسرعة.

أحد الأشياء التي يمكن القيام بها في الرسوم البيانية هو إيجاد المسارات فيها ، كما رأينا في الفصل [Chapter 7](https://eloquentjavascript.net/07_robot.html#findRoute). إذا كان لدينا طريق إلى وجهة رسالة ، فنحن نعرف مكان إرسالها.

تبحث وظيفة findRoute هذه ، التي تشبه إلى حد بعيد وظيفة findRoute في الفصل [Chapter 7](https://eloquentjavascript.net/07_robot.html#findRoute) ، عن عقدة محددة على الشبكة. ولكن بدلاً من العودة إلى الوراء ، فإنها تأخذ الخطوة التالية فقط. سيستخدم العش التالي معلومات الشبكة الحالية الخاصة به ويقرر مكان إرسال الرسالة.

```text
function findRoute(from, to, connections) {
  let work = [{at: from, via: null}];
  for (let i = 0; i < work.length; i++) {
    let {at, via} = work[i];
    for (let next of connections.get(at) || []) {
      if (next == to) return via;
      if (!work.some(w => w.at == next)) {
        work.push({at: next, via: via || next});
      }
    }
  }
  return null;
}
```

يمكننا الآن إنشاء وظيفة يمكنها إرسال رسائل إلى مواقع بعيدة. إذا كانت الرسالة المقصودة إلى جار قريب ، فسيتم تسليمها عادةً. وبخلاف ذلك ، يتم وضعه داخل كائن وإرساله إلى جار أقرب إلى الهدف ، باستخدام نوع طلب "route" ، مما يتسبب في تكرار هذا الجار للسلوك.

```text
function routeRequest(nest, target, type, content) {
  if (nest.neighbors.includes(target)) {
    return request(nest, target, type, content);
  } else {
    let via = findRoute(nest.name, target,
                        nest.state.connections);
    if (!via) throw new Error(`No route to ${target}`);
    return request(nest, via, "route",
                   {target, type, content});
  }
}

requestType("route", (nest, {target, type, content}) => {
  return routeRequest(nest, target, type, content);
});
```

يمكننا الآن إرسال رسالة إلى العش في برج الكنيسة الذي يتطلب أربع خطوات في الشبكة.

```text
routeRequest(bigOak, "Church Tower", "note",
             "Incoming jackdaws!");
```

لقد أنشأنا عدة طبقات من الوظائف فوق نظام اتصال بدائي لجعله مناسبًا للاستخدام. هذا نموذج جميل \(رغم أنه مبسط\) لكيفية عمل شبكات الكمبيوتر الحقيقية.

من الخصائص المميزة لشبكات الكمبيوتر أنها غير موثوقة - يمكن أن تساعد الأفكار المجردة المبنية فوقها ، ولكن لا يمكنك التخلص من فشل الشبكة. لذا ، فإن برمجة الشبكات عادةً ما تدور حول توقع حالات الفشل والتعامل معها.

### Async functions

لتخزين المعلومات المهمة ، من المعروف أن الغربان تكررها عبر الأعشاش. بهذه الطريقة ، عندما يدمر الصقر عشًا ، لا تضيع المعلومات.

لاسترداد جزء من المعلومات غير موجود في النسيج الموجود في العش نفسه ، قد يتصل كمبيوتر العش بأعشاش عشوائية على الشبكة حتى يتم العثور على العش الذي يحتوي على المعلومات.

```text
requestType("storage", (nest, name) => storage(nest, name));

function findInStorage(nest, name) {
  return storage(nest, name).then(found => {
    if (found != null) return found;
    else return findInRemoteStorage(nest, name);
  });
}

function network(nest) {
  return Array.from(nest.state.connections.keys());
}

function findInRemoteStorage(nest, name) {
  let sources = network(nest).filter(n => n != nest.name);
  function next() {
    if (sources.length == 0) {
      return Promise.reject(new Error("Not found"));
    } else {
      let source = sources[Math.floor(Math.random() *
                                      sources.length)];
      sources = sources.filter(n => n != source);
      return routeRequest(nest, source, "storage", name)
        .then(value => value != null ? value : next(),
              next);
    }
  }
  return next();
}
```

لأن الاتصالات هي map، لن تستجيب Object.keys لها. ان لها طريقه المفاتيح keys.method, لكن هذا يعيد تكرارا بدلا من مصفوفه, يمكن تحويل العداد \(أو قيمة العداد\) إلى مصفوفة بواسطة Array.from.

حتى مع استخدام الوعود ، فإن هذا الرمز لا يبدو جيدًا نسبيًا. يتم ربط العديد من العمليات غير المتزامنة ببعضها البعض بطريقة لا يمكن قراءتها على الإطلاق.نحتاج مرة أخرى إلى دالة تكرارية \(next\) لنموذج الحلقات عبر الأعشاش.

وهذا ما يفعله هذا الكود في الواقع هو خطي تمامًا - فهو ينتظر دائمًا انتهاء العملية السابقة قبل بدء العملية التالية. في نموذج البرمجة المتزامن ، تكون هذه المهام أسهل في التنفيذ.

والخبر السار هو أن JavaScript يسمح لك بكتابة رمز المزامنة الزائفة.الوظيفة async هي وظيفة تُرجع ضمنيًا وعدًا ويمكن أن تنتظر وعودًا أخرى في جسدها باستخدام الأمر انتظار 'await' بحيث تبدو متزامنة.

يمكننا الكتابة فوق دالة findInStorage على النحو التالي.

```text
async function findInStorage(nest, name) {
  let local = await storage(nest, name);
  if (local != null) return local;

  let sources = network(nest).filter(n => n != nest.name);
  while (sources.length > 0) {
    let source = sources[Math.floor(Math.random() *
                                    sources.length)];
    sources = sources.filter(n => n != source);
    try {
      let found = await routeRequest(nest, source, "storage",
                                     name);
      if (found != null) return found;
    } catch (_) {}
  }
  throw new Error("Not found");
}
```

يتم تمييز وظيفة async بواسطة كلمة async  قبل الكلمة الأساسية للوظيفة.يمكن أيضًا جعل الطرق async عن طريق كتابة غير متزامن قبل اسمها. عندما يتم استدعاء هذه الوظيفة أو الطريقة ، فإنها ترجع وعدًا. بمجرد أن يعيد جسم الوظيفه  شيئًا ما ، يتم الوفاء بهذا الوعد. إذا ألقى استثناءً ، يرفض الوعد.

```text
findInStorage(bigOak, "events on 2017-12-21")
  .then(console.log);
```

ضمن دالة async  ، يمكن وضع الكلمةawait  في بداية العبارة بحيث يمكن للوظيفة الانتظار لتلقي نتيجة الوعد ثم متابعة تنفيذ الوظيفة.

مثل هذه الوظائف الأخرى ، مثل وظائف JavaScript العادية ، لا يتم تنفيذها دفعة واحدة من البداية إلى النهاية. بدلاً من ذلك ، قد يتوقفون أينما كان لديهم await ثم يواصلون طريقهم.

بالنسبة للشفرة غير المتزامنة غير التافهة ، يكون هذا الترميز عادةً أكثر ملاءمة من استخدام الوعود مباشرةً. . حتى إذا كنت بحاجة إلى القيام بشيء لا يتناسب مع النموذج المتزامن ، مثل تنفيذ إجراءات متعددة في نفس الوقت ، فمن السهل الجمع بين await والاستخدام المباشر للوعود.

### Generators

لا تقتصر إمكانية إيقاف الوظائف مؤقتًا ثم استئنافها مرة أخرى على الوظائف async .  تحتوي JavaScript أيضًا على ميزة تسمى وظائف المولد ' _generator_ '.                 هذه متشابهة ولكن من دون وعود.

عندما تحدد وظيفة ذات وظيفة \* \(ضع نجمة بعد الكلمة الأساسية للوظيفة\) ، فإنها تجعل هذه الوظيفة مولدًا. عندما يتم استدعاء دالة توليد ، فإنها تعيد مكررًا رأيناه سابقًا في الفصل  [Chapter 6](https://eloquentjavascript.net/06_object.html).

```text
function* powers(n) {
  for (let current = n;; current *= n) {
    yield current;
  }
}

for (let power of powers(3)) {
  if (power > 50) break;
  console.log(power);
}
// → 3
// → 9
// → 27
```

أولاً ، عند استدعاء وظيفة power، تتوقف الوظيفة في البداية. في كل مرة تقوم فيها بالاستدعاء next على المكرر ، يتم تنفيذ الوظيفة حتى يتم الوصول إلى بيان العائد 'yield', ويتم إيقافه مرة أخرى وتعتبر القيمة التي يحصل عليها yield هي القيمة التالية التي ينتجها المكرر. عندما ترجع الدالة \(التي في المثال لا تفعل ذلك أبدًا\) ، يتم تنفيذ المكرر.

غالبًا ما تكون كتابة المكرر أسهل بكثير عند استخدام وظائف المولد. يمكن كتابة المكرر Group class \(من التمرين في الفصل  [Chapter 6](https://eloquentjavascript.net/06_object.html#group_iterator)\) باستخدام هذا المولد:

```text
Group.prototype[Symbol.iterator] = function*() {
  for (let i = 0; i < this.members.length; i++) {
    yield this.members[i];
  }
};
```

لم تعد هناك حاجة لإنشاء كائن للاحتفاظ بحالة التكرار - تحفظ المولدات تلقائيًا حالتها المحلية في كل مرة تنتج فيها.

لا يمكن استخدام تعبيرات المحصول إلا مباشرةً داخل وظيفة المولد نفسها ، وليس ضمن الوظيفة التي تحددها داخل المولد. تشمل الحالة التي يخزنها المولد عند إجراء yieldفقط بيئته المحلية والموضع الذي يتم فيه تنفيذ yield.

الوظيفة غير المتزامنة هي نوع محدد من المولد. يولد وعدًا عند استدعائه ، والذي ينتج عند انتهاء الوظيفة ، ورفضه عند إنشاء استثناء. عندما يعطي \(ينتظر\) وعدًا ، تكون نتيجة ذلك الوعد \(قيمة أو استثناء\) نتيجة تعبير الانتظار.

### The event loop

تعمل البرامج غير المتزامنة في أقسام. قد يبدأ كل قسم المهام وجدولة التعليمات البرمجية للتنفيذ إذا اكتملت أو فشلت. بين هذه الأقسام ، يجلس البرنامج في وضع الخمول وينتظر الوظيفة التالية.

لذلك ، لا يتم استدعاء عمليات الاسترجاعات مباشرة من خلال الكود الذي قام بجدولتها. إذا اتصلت بوظيفة setTimeout من داخل إحدى الوظائف ، فسيتم إرجاع هذه الوظيفة عند استدعاء وظيفة رد الاتصال. وعندما يتم تنفيذ وظيفة رد الاتصال وإعادتها ، لن يعود التحكم في البرنامج إلى الوظيفة التي قامت بجدولتها.

يحدث السلوك غير المتزامن في مكدس استدعاء الوظيفة الفارغ الخاص به. هذا أحد الأسباب التي تجعل إدارة الاستثناءات عبر التعليمات البرمجية غير المتزامنة أمرًا صعبًا بدون وعود نظرًا لأن كل رد نداء يبدأ بمكدس فارغ في الغالب ، فلن تكون معالجات catch في المكدس عند طرح استثناء.

```text
try {
  setTimeout(() => {
    throw new Error("Woosh");
  }, 20);
} catch (_) {
  // This will not run
  console.log("Caught!");
}
```

بغض النظر عن مدى قرب وقوع الأحداث معًا - مثل المهلات أو الطلبات الواردة - ، فإن بيئة JavaScript ستشغل برنامجًا واحدًا فقط في كل مرة. يمكنك التفكير في هذا على أنه تشغيل حلقة كبيرة حول برنامجك ، تسمى حلقة الحدث. عندما لا يكون هناك شيء يمكن القيام به ، يتم إيقاف هذه الحلقة.ولكن عندما تأتي الأحداث ، تتم إضافتها إلى قائمة الانتظار ، ويتم تنفيذ التعليمات البرمجية الخاصة بها واحدة تلو الأخرى. نظرًا لعدم تشغيل شيئين في نفس الوقت ، فقد يؤدي تشغيل الكود البطيء إلى تأخير معالجة الأحداث الأخرى.

يعيّن هذا المثال مهلة ولكن بعد ذلك يسقط إلى ما بعد النقطة الزمنية المحددة للمهلة ، مما يتسبب في تأخير المهلة.

```text
let start = Date.now();
setTimeout(() => {
  console.log("Timeout ran at", Date.now() - start);
}, 20);
while (Date.now() < start + 50) {}
console.log("Wasted time until", Date.now() - start);
// → Wasted time until 50
// → Timeout ran at 55
```

يتم حل الوعود أو رفضها دائمًا كحدث جديد. حتى إذا تم الوفاء بالوعد بالفعل ، فإن انتظاره سيؤدي إلى تشغيل رد الاتصال بعد انتهاء النص الحالي ، وليس على الفور.

```text
Promise.resolve("Done").then(console.log);
console.log("Me first!");
// → Me first!
// → Done
```

سنرى في الفصول اللاحقة أنواعًا مختلفة من الأحداث التي تجري في حلقة الحدث.

### Asynchronous bugs

عندما يتم تشغيل برنامجك بشكل متزامن ، في تشغيل واحد ، لا يوجد تغيير في الحالة بخلاف تلك التي تم إنشاؤها بواسطة البرنامج نفسه. يختلف الموقف في البرامج غير المتزامنة - فقد تتضمن مقاطعات في تنفيذها حيث يمكن تنفيذ تعليمات برمجية أخرى.

لنلقي نظرة على مثال. من هوايات الغربان أن نحسب عدد الكتاكيت التي تفقس في جميع أنحاء القرية كل عام. تحافظ الأعشاش على هذا الرقم في أنسجة التخزين الخاصة بها. يحاول الكود التالي حساب جميع الأرقام في كل الأعشاش لمدة عام.

```text
function anyStorage(nest, source, name) {
  if (source == nest.name) return storage(nest, name);
  else return routeRequest(nest, source, "storage", name);
}

async function chicks(nest, year) {
  let list = "";
  await Promise.all(network(nest).map(async name => {
    list += `${name}: ${
      await anyStorage(nest, name, `chicks in ${year}`)
    }\n`;
  }));
  return list;
}
```

يشير الحقل async  =&gt; إلى أنه يمكن أيضًا إنشاء وظائف السهم غير متزامنة عن طريق وضع الكلمة غير المتزامنة في البداية.

لا يبدو الرمز مشبوهًا على الفور ... فهو يرسم وظيفة السهم غير المتزامن على مجموعة الأعشاش ، وينشئ مجموعة من الوعود ، ثم يستخدم Promise.all لانتظار كل هذه الأشياء قبل إعادة القائمة التي أنشأوها.

لكن هذا الرمز بالتأكيد لديه مشكلة. دائمًا ما يكون ناتجه هو العش الذي كان لديه أبطأ استجابة.

```text
chicks(bigOak, 2017).then(console.log);
```

هل يمكنك معرفة لماذا؟

تكمن المشكلة في عامل التشغيل  = +، الذي يأخذ القيمة الحالية list في الوقت الذي يبدأ فيه تنفيذ العبارة ،then  ، عندما ينتهي await ، يعيّن ربط list ليكون تلك القيمة بالإضافة إلى السلسلة المضافة.

ولكن بين الوقت الذي يبدأ فيه تنفيذ العبارة والوقت الذي تنتهي فيه ، توجد فجوة غير متزامنة. يتم تشغيل تعبير map قبل إضافة أي شيء إلى list ، لذلك يبدأ كل عامل من عوامل  = +من سلسلة فارغة وينتهي به الأمر, عند انتهاء استرجاع التخزين ، يتم ضبط list على قائمة من سطر واحد — نتيجة إضافة السطر إلى السلسلة الفارغة.

كان من الممكن تجنب ذلك بسهولة عن طريق إعادة الأسطر من الوعود المعينة والدعوة إلى join إلى نتيجة Promise.all. بدلاً من بناء القائمة  list عن طريق تغيير ارتباط. كالعادة ، فإن حساب القيم الجديدة أقل عرضة للخطأ من تغيير القيم الحالية.

```text
async function chicks(nest, year) {
  let lines = network(nest).map(async name => {
    return name + ": " +
      await anyStorage(nest, name, `chicks in ${year}`);
  });
  return (await Promise.all(lines)).join("\n");
}
```

تحدث مثل هذه الأخطاء بكل بساطة ، خاصة عندما نستخدم await، ويجب أن تكون على دراية بمكان حدوث الانقطاعات في التعليمات البرمجية الخاصة بك. تتمثل ميزة عدم التزامن الواضح لجافا سكريبت \(سواء من خلال عمليات الاسترجاعات أو الوعود أو الانتظار\) في أن اكتشاف هذه الفجوات أمر سهل نسبيًا.

### Summary





