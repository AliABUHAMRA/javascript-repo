# Regular Expressions

> يعتقد بعض الأشخاص ، عند مواجهة مشكلة ، "أعلم ، سأستخدم التعابير العادية". الآن لديهم مشكلتان



> Jamie Zawinski

> قال Yuan-Ma ، "عندما تقطع الخشب في الاتجاه المعاكس لأليافه ، فإنك تحتاج إلى مزيد من القوة. وعندما يتعلق الأمر بالبرمجة بطريقة خاطئة ، فأنت بحاجة إلى المزيد من التعليمات البرمجية.

> > Master Yuan-Ma, The Book of Programming

  

![](.gitbook/assets/image%20%285%29.png)







تتطور أدوات وتقنيات البرمجة وتتطور بمرور الوقت بطريقة غير منتظمة ومتطورة. لا تفوز دائمًا الشركات الجميلة أو الرائعة ، بل تلك التي تعمل بشكل جيد بما فيه الكفاية في المجال المناسب أو التي يتم دمجها مع قطعة تقنية أخرى ناجحة. 

في هذا الفصل ، سأناقش إحدى هذه الأدوات ،   _regular expressions_. التعبيرات العادية هي طريقة لوصف الأنماط في بيانات السلسلة. إنهم يشكلون لغة صغيرة منفصلة وهي جزء من JavaScript والعديد من اللغات والأنظمة الأخرى.

التعبيرات العادية محرجة للغاية وعملية للغاية في نفس الوقت. واجهات البرمجة والقواعد الخاصة بهم غير لاصقة بعض الشيء في JavaScript. . لكنها أدوات قوية جدًا لمعالجة وفحص السلاسل. إن فهم العبارات العادية سيجعلك مبرمجًا أفضل.

### Creating a regular expression أنشئ تعبيرات عادية

التعبير العادي هو نوع من الكائنات. يمكن إنشاؤه باستخدام مُنشئ RegExp ومباشرة عن طريق وضع قالب بين حرفين مائلين \(/\).

```text
let re1 = new RegExp("abc");
let re2 = /abc/;
```

يمثل كلا التعبيرين العاديين أعلاه نمطًا: الحرف a متبوعًا بـ b ثم c.

عند استخدام مُنشئ RegExp ، تتم كتابة القالب كسلسلة عادية ؛ لذا فإن القواعد المعتادة تنطبق على شخصية رد الفعل العكسي.

التدوين الثاني ، حيث يظهر النمط بين الأحرف المائلة ، يعامل الخط المائل العكسي بشكل مختلف إلى حد ما. أولاً ، نظرًا لأن الشرطة المائلة للأمام تنهي النمط ، نحتاج إلى وضع شرطة مائلة للخلف قبل أي شرطة مائلة للأمام نريد أن نكون جزءًا من النمط. بالإضافة إلى ذلك ، سيتم الاحتفاظ بالردود العكسية التي ليست جزءًا من رمز حرف خاص \(مثل  n\) ، على عكس وضع السلسلة ، وستغير معنى النمط. بعض الأحرف ، مثل علامات الاستفهام وعلامات الجمع ، لها معاني خاصة في التعبيرات العادية ويجب أن تسبقها شرطة مائلة للخلف إذا كان المقصود منها تمثيل الحرف نفسه.

```text
let eighteenPlus = /eighteen\+/;
```

### Testing for matches اختبار الانماط

كائنات التعبير العادي لها عدد من الطرق. أبسطها هو الاختبار. إذا قمت بتمريرها سلسلة ، فإنها ستعيد قيمة منطقية تخبرك ما إذا كانت السلسلة تحتوي على تطابق من النمط في التعبير.

```text
console.log(/abc/.test("abcde"));
// → true
console.log(/abc/.test("abxde"));
// → false
```

يمثل التعبير العادي الذي يتكون من أحرف غير خاصة فقط هذا التسلسل من الأحرف.  إذا حدث abc في أي مكان في السلسلة التي نقوم باختبارها \(ليس فقط في البداية\) ، فسيعود test إلى true.

### Sets of characters مجموعات من الشخصيات

يمكن أيضًا معرفة ما إذا كانت السلسلة تحتوي على abc جيدًا باستخدام طريقة indexOf. تسمح لنا التعبيرات العادية بإنشاء أنماط أكثر تعقيدًا.

افترض أننا نريد تحديد كل الأرقام. في التعبير العادي ، يؤدي وضع مجموعة من الأحرف داخل القوس إلى مطابقة هذا الجزء من التعبير لأي حرف يظهر بين الأقواس.

تتضمن كلتا العبارتين التاليتين جميع السلاسل التي تحتوي على أرقام:

```text
console.log(/[0123456789]/.test("in 1992"));
// → true
console.log(/[0-9]/.test("in 1992"));
// → true
```

لتحديد نطاق من الأحرف ، يمكنك استخدام حرف \(-\) بين حرفين داخل الأقواس ، يتم تحديد ترتيبها بواسطة رمز Unicode الخاص بهم. تقع الأحرف من 0 إلى 9 بجوار بعضها البعض في نطاق Unicode \(الرموز من 48 إلى 57\) لذا فإن \[0-9\] تغطيها جميعًا وتتضمن كل رقم.

عدد مجموعات الأحرف المشتركة لها الاختصارات المضمنة الخاصة بها. الأرقام إحداها: 

  `\d` means the same thing as `[0-9]`.

```text

\d	Any digit character
\w	An alphanumeric character (“word character”)
\s	Any whitespace character (space, tab, newline, and similar)
\D	A character that is not a digit
\W	A nonalphanumeric character
\S	A nonwhitespace character
.	Any character except for newline
```

لذلك يمكنك مطابقة تنسيق التاريخ والوقت مثل 01-30-2003 15:20 بالتعبير التالي:

```text
let dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log(dateTime.test("01-30-2003 15:20"));
// → true
console.log(dateTime.test("30-jan-2003 15:20"));
// → false
```

هذا يبدو فظيعًا تمامًا ، أليس كذلك؟ نصفها عبارة عن خطوط مائلة للخلف ، مما ينتج عنه ضوضاء في الخلفية تجعل من الصعب تحديد النمط الفعلي المعبر عنه. سنرى نسخة محسّنة قليلاً من هذا التعبير لاحقا  [later](https://eloquentjavascript.net/09_regexp.html#date_regexp_counted).

يمكن أيضًا استخدام رموز الخط المائل العكسي داخل الأقواس المربعة. على سبيل المثال ، يعني \[. d\\] أي رقم أو حرف نقطة. لكن النقطة نفسها تفقد معناها الخاص عند وضعها داخل القوس. الشيء نفسه ينطبق على الأحرف الخاصة الأخرى ، مثل +.

لعكس مجموعة من الأحرف — أي للتعبير عن رغبتك في مطابقة أي حرف باستثناء الأحرف الموجودة في المجموعة — يمكنك كتابة حرف علامة الإقحام \(^\) بعد قوس الفتح.

```text
let notBinary = /[^01]/;
console.log(notBinary.test("1100100010100110"));
// → false
console.log(notBinary.test("1100100010200110"));
// → true
```

### Repeating parts of a pattern  كرر أجزاء من النمط

نحن نعرف الآن كيفية مطابقة رقم واحد. ماذا لو أردنا مطابقة رقم صحيح - تسلسل من رقم واحد أو أكثر؟

عندما تضع علامة الجمع \(+\) بعد شيء ما في التعبير العادي ، فإنها تشير إلى أن العنصر قد يتكرر أكثر من مرة. وبالتالي ، /  d + / يطابق واحدًا أو أكثر من الأحرف الرقمية.

```text
console.log(/'\d+'/.test("'123'"));
// → true
console.log(/'\d+'/.test("''"));
// → false
console.log(/'\d*'/.test("'123'"));
// → true
console.log(/'\d*'/.test("''"));
// → true
```

النجمة \(\*\) لها معنى مشابه ولكنها تسمح أيضًا للنمط بمطابقة صفر مرة. شيء ما بنجمة بعده لا يمنع أبدًا نمطًا من المطابقة - لن يتطابق مع أي مثيل فقط إذا لم يتمكن من العثور على أي نص مناسب لمطابقته.

تجعل علامة الاستفهام \(?\)جزءًا من النمط اختياريًا ، مما يعني أنه قد يحدث صفر مرة أو مرة واحدة. في المثال التالي ، يُسمح بحرف u ، ولكن النمط يتطابق أيضًا عندما يكون مفقودًا.

```text
let neighbor = /neighbou?r/;
console.log(neighbor.test("neighbour"));
// → true
console.log(neighbor.test("neighbor"));
// → true
```

للإشارة إلى أن النمط يجب أن يحدث بعدد محدد من المرات ، استخدم الأقواس. يتطلب وضع {4} بعد عنصر ما ، على سبيل المثال ، أن يحدث أربع مرات بالضبط. من الممكن أيضًا تحديد نطاق بهذه الطريقة: {2،4} تعني أن العنصر يجب أن يحدث مرتين على الأقل وأربع مرات على الأكثر.

لدينا هنا إصدار آخر من نمط التعرف على التاريخ والوقت يمكنه اكتشاف اليوم والشهر والساعة بالتنسيقات المكونة من رقم واحد ومزدوجة الرقم. أيضًا ، هذا النمط أسهل في الفهم من النمط السابق.

```text
let dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
console.log(dateTime.test("1-30-2003 8:45"));
// → true
```

يمكنك أيضًا تحديد نطاقات مفتوحة عند استخدام الأقواس عن طريق حذف الرقم بعد الفاصلة. إذن ، {5،} تعني خمس مرات أو أكثر.

### Grouping subexpressions  تجميع التعبيرات الفرعية

لاستخدام عامل تشغيل مثل \* أو + على أكثر من عنصر واحد في نفس الوقت ، يجب عليك استخدام الأقواس. من وجهة نظر عوامل التشغيل التي تم وضعها بعد العبارات بين قوسين ، يتم اعتبار كل عبارة محاطة بأقواس كعنصر.

```text
let cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test("Boohoooohoohooo"));
// → true
```































