# Regular Expressions

> يعتقد بعض الأشخاص ، عند مواجهة مشكلة ، "أعلم ، سأستخدم التعابير العادية". الآن لديهم مشكلتان



> Jamie Zawinski

> قال Yuan-Ma ، "عندما تقطع الخشب في الاتجاه المعاكس لأليافه ، فإنك تحتاج إلى مزيد من القوة. وعندما يتعلق الأمر بالبرمجة بطريقة خاطئة ، فأنت بحاجة إلى المزيد من التعليمات البرمجية.

> > Master Yuan-Ma, The Book of Programming

  

![](.gitbook/assets/image%20%287%29.png)







تتطور أدوات وتقنيات البرمجة وتتطور بمرور الوقت بطريقة غير منتظمة ومتطورة. لا تفوز دائمًا الشركات الجميلة أو الرائعة ، بل تلك التي تعمل بشكل جيد بما فيه الكفاية في المجال المناسب أو التي يتم دمجها مع قطعة تقنية أخرى ناجحة. 

في هذا الفصل ، سأناقش إحدى هذه الأدوات ،   _regular expressions_. التعبيرات العادية هي طريقة لوصف الأنماط في بيانات السلسلة. إنهم يشكلون لغة صغيرة منفصلة وهي جزء من JavaScript والعديد من اللغات والأنظمة الأخرى.

التعبيرات العادية محرجة للغاية وعملية للغاية في نفس الوقت. واجهات البرمجة والقواعد الخاصة بهم غير لاصقة بعض الشيء في JavaScript. . لكنها أدوات قوية جدًا لمعالجة وفحص السلاسل. إن فهم العبارات العادية سيجعلك مبرمجًا أفضل.

### Creating a regular expression أنشئ تعبيرات عادية

التعبير العادي هو نوع من الكائنات. يمكن إنشاؤه باستخدام مُنشئ RegExp ومباشرة عن طريق وضع قالب بين حرفين مائلين \(/\).

```text
let re1 = new RegExp("abc");
let re2 = /abc/;
```

يمثل كلا التعبيرين العاديين أعلاه نمطًا: الحرف a متبوعًا بـ b ثم c.

عند استخدام مُنشئ RegExp ، تتم كتابة القالب كسلسلة عادية ؛ لذا فإن القواعد المعتادة تنطبق على شخصية رد الفعل العكسي.

التدوين الثاني ، حيث يظهر النمط بين الأحرف المائلة ، يعامل الخط المائل العكسي بشكل مختلف إلى حد ما. أولاً ، نظرًا لأن الشرطة المائلة للأمام تنهي النمط ، نحتاج إلى وضع شرطة مائلة للخلف قبل أي شرطة مائلة للأمام نريد أن نكون جزءًا من النمط. بالإضافة إلى ذلك ، سيتم الاحتفاظ بالردود العكسية التي ليست جزءًا من رمز حرف خاص \(مثل  n\) ، على عكس وضع السلسلة ، وستغير معنى النمط. بعض الأحرف ، مثل علامات الاستفهام وعلامات الجمع ، لها معاني خاصة في التعبيرات العادية ويجب أن تسبقها شرطة مائلة للخلف إذا كان المقصود منها تمثيل الحرف نفسه.

```text
let eighteenPlus = /eighteen\+/;
```

### Testing for matches اختبار الانماط

كائنات التعبير العادي لها عدد من الطرق. أبسطها هو الاختبار. إذا قمت بتمريرها سلسلة ، فإنها ستعيد قيمة منطقية تخبرك ما إذا كانت السلسلة تحتوي على تطابق من النمط في التعبير.

```text
console.log(/abc/.test("abcde"));
// → true
console.log(/abc/.test("abxde"));
// → false
```

يمثل التعبير العادي الذي يتكون من أحرف غير خاصة فقط هذا التسلسل من الأحرف.  إذا حدث abc في أي مكان في السلسلة التي نقوم باختبارها \(ليس فقط في البداية\) ، فسيعود test إلى true.

### Sets of characters مجموعات من الشخصيات

يمكن أيضًا معرفة ما إذا كانت السلسلة تحتوي على abc جيدًا باستخدام طريقة indexOf. تسمح لنا التعبيرات العادية بإنشاء أنماط أكثر تعقيدًا.

افترض أننا نريد تحديد كل الأرقام. في التعبير العادي ، يؤدي وضع مجموعة من الأحرف داخل القوس إلى مطابقة هذا الجزء من التعبير لأي حرف يظهر بين الأقواس.

تتضمن كلتا العبارتين التاليتين جميع السلاسل التي تحتوي على أرقام:

```text
console.log(/[0123456789]/.test("in 1992"));
// → true
console.log(/[0-9]/.test("in 1992"));
// → true
```

لتحديد نطاق من الأحرف ، يمكنك استخدام حرف \(-\) بين حرفين داخل الأقواس ، يتم تحديد ترتيبها بواسطة رمز Unicode الخاص بهم. تقع الأحرف من 0 إلى 9 بجوار بعضها البعض في نطاق Unicode \(الرموز من 48 إلى 57\) لذا فإن \[0-9\] تغطيها جميعًا وتتضمن كل رقم.

عدد مجموعات الأحرف المشتركة لها الاختصارات المضمنة الخاصة بها. الأرقام إحداها: 

  `\d` means the same thing as `[0-9]`.

```text

\d	Any digit character
\w	An alphanumeric character (“word character”)
\s	Any whitespace character (space, tab, newline, and similar)
\D	A character that is not a digit
\W	A nonalphanumeric character
\S	A nonwhitespace character
.	Any character except for newline
```

لذلك يمكنك مطابقة تنسيق التاريخ والوقت مثل 01-30-2003 15:20 بالتعبير التالي:

```text
let dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log(dateTime.test("01-30-2003 15:20"));
// → true
console.log(dateTime.test("30-jan-2003 15:20"));
// → false
```

هذا يبدو فظيعًا تمامًا ، أليس كذلك؟ نصفها عبارة عن خطوط مائلة للخلف ، مما ينتج عنه ضوضاء في الخلفية تجعل من الصعب تحديد النمط الفعلي المعبر عنه. سنرى نسخة محسّنة قليلاً من هذا التعبير لاحقا  [later](https://eloquentjavascript.net/09_regexp.html#date_regexp_counted).

يمكن أيضًا استخدام رموز الخط المائل العكسي داخل الأقواس المربعة. على سبيل المثال ، يعني \[. d\\] أي رقم أو حرف نقطة. لكن النقطة نفسها تفقد معناها الخاص عند وضعها داخل القوس. الشيء نفسه ينطبق على الأحرف الخاصة الأخرى ، مثل +.

لعكس مجموعة من الأحرف — أي للتعبير عن رغبتك في مطابقة أي حرف باستثناء الأحرف الموجودة في المجموعة — يمكنك كتابة حرف علامة الإقحام \(^\) بعد قوس الفتح.

```text
let notBinary = /[^01]/;
console.log(notBinary.test("1100100010100110"));
// → false
console.log(notBinary.test("1100100010200110"));
// → true
```

### Repeating parts of a pattern  كرر أجزاء من النمط

نحن نعرف الآن كيفية مطابقة رقم واحد. ماذا لو أردنا مطابقة رقم صحيح - تسلسل من رقم واحد أو أكثر؟

عندما تضع علامة الجمع \(+\) بعد شيء ما في التعبير العادي ، فإنها تشير إلى أن العنصر قد يتكرر أكثر من مرة. وبالتالي ، /  d + / يطابق واحدًا أو أكثر من الأحرف الرقمية.

```text
console.log(/'\d+'/.test("'123'"));
// → true
console.log(/'\d+'/.test("''"));
// → false
console.log(/'\d*'/.test("'123'"));
// → true
console.log(/'\d*'/.test("''"));
// → true
```

النجمة \(\*\) لها معنى مشابه ولكنها تسمح أيضًا للنمط بمطابقة صفر مرة. شيء ما بنجمة بعده لا يمنع أبدًا نمطًا من المطابقة - لن يتطابق مع أي مثيل فقط إذا لم يتمكن من العثور على أي نص مناسب لمطابقته.

تجعل علامة الاستفهام \(?\)جزءًا من النمط اختياريًا ، مما يعني أنه قد يحدث صفر مرة أو مرة واحدة. في المثال التالي ، يُسمح بحرف u ، ولكن النمط يتطابق أيضًا عندما يكون مفقودًا.

```text
let neighbor = /neighbou?r/;
console.log(neighbor.test("neighbour"));
// → true
console.log(neighbor.test("neighbor"));
// → true
```

للإشارة إلى أن النمط يجب أن يحدث بعدد محدد من المرات ، استخدم الأقواس. يتطلب وضع {4} بعد عنصر ما ، على سبيل المثال ، أن يحدث أربع مرات بالضبط. من الممكن أيضًا تحديد نطاق بهذه الطريقة: {2،4} تعني أن العنصر يجب أن يحدث مرتين على الأقل وأربع مرات على الأكثر.

لدينا هنا إصدار آخر من نمط التعرف على التاريخ والوقت يمكنه اكتشاف اليوم والشهر والساعة بالتنسيقات المكونة من رقم واحد ومزدوجة الرقم. أيضًا ، هذا النمط أسهل في الفهم من النمط السابق.

```text
let dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
console.log(dateTime.test("1-30-2003 8:45"));
// → true
```

يمكنك أيضًا تحديد نطاقات مفتوحة عند استخدام الأقواس عن طريق حذف الرقم بعد الفاصلة. إذن ، {5،} تعني خمس مرات أو أكثر.

### Grouping subexpressions  تجميع التعبيرات الفرعية

لاستخدام عامل تشغيل مثل \* أو + على أكثر من عنصر واحد في نفس الوقت ، يجب عليك استخدام الأقواس. من وجهة نظر عوامل التشغيل التي تم وضعها بعد العبارات بين قوسين ، يتم اعتبار كل عبارة محاطة بأقواس كعنصر.

```text
let cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test("Boohoooohoohooo"));
// → true
```

يتم تطبيق الحرفين الأول والثاني + فقط على الحرفين o الثاني في boo و hoo ، على التوالي. ينطبق الثالث + على المجموعة بأكملها \(hoo +\) ، ويتطابق مع تسلسل واحد أو أكثر من هذا القبيل.

يجعل الحرف i في نهاية جملة المثال التعبير العادي غير حساس لحالة الأحرف. السماح له بمطابقة الحرف الكبير B في سلسلة الإدخال ، على الرغم من أن النمط نفسه كله أحرف صغيرة.

### Matches and groups

طريقة test هي أبسط طريقة لمطابقة التعبير العادي. يخبرك فقط ما إذا كان متطابقًا أم لا. تحتوي التعبيرات العادية أيضًا على أسلوب exec \(تنفيذ\) والذي سيعيد قيمة فارغة null إذا لم يتم العثور على تطابق ويعيد كائنًا بمعلومات حول المطابقة بخلاف ذلك.

```text
let match = /\d+/.exec("one two 100");
console.log(match);
// → ["100"]
console.log(match.index);
// → 8
```

الكائن الذي تم إرجاعه من طريقة exec له خاصية تسمى index والتي توضح لنا نقطة بداية التطابق الموجود في السلسلة. بخلاف ذلك ، يبدو الكائن \(وهو في الواقع\) مصفوفة من السلاسل ، عنصرها الأول هو السلسلة التي تمت مطابقتها. في المثال السابق ، هذا هو تسلسل الأرقام الذي كنا نبحث عنه.

تحتوي قيم السلسلة على طريقة تسمى match تعمل بنفس الطريقة.

```text
console.log("one two 100".match(/\d+/));
// → ["100"]
```

عندما يحتوي التعبير العادي على أقواس مجمعة بين أقواس ، فسيتم أيضًا عرض النص الذي يطابق هذه المجموعات داخل مصفوفة. تكون المطابقة المثالية دائمًا في نفس العنصر مثل الأول. ينتمي العنصر التالي من المصفوفة إلى الجزء الذي تم تعديله بواسطة المجموعة الأولى \(المجموعة التي يبدأ أقواسها في العبارة الأولى\) ، ثم المجموعة الثانية ، وهكذا.

```text
let quotedText = /'([^']*)'/;
console.log(quotedText.exec("she said 'hello'"));
// → ["'hello'", "hello"]
```

عندما لا ينتهي الأمر بمطابقة مجموعة على الإطلاق \(على سبيل المثال ، عند اتباعها بعلامة استفهام\) ، فإن موضعها في مصفوفة الإخراج سيظل undefiend. وبالمثل ، عندما تتم مطابقة مجموعة عدة مرات ، تنتهي المباراة الأخيرة فقط في المصفوفة.

```text
console.log(/bad(ly)?/.exec("bad"));
// → ["bad", undefined]
console.log(/(\d)+/.exec("123"));
// → ["123", "3"]
```

يمكن استخدام قدرة المجموعات لاستخراج أجزاء من سلسلة. على سبيل المثال ، عندما لا يكون من المهم بالنسبة لنا مجرد وجود تاريخ في سلسلة ونريد استخراجه من القلب وإنشاء كائن يحتوي عليه ، يمكننا استخدام الأقواس مباشرة في نمط الأرقام افصل نتيجة exec.

لكن أولاً ، دعنا نأخذ استراحة قصيرة ونتحدث قليلاً عن الطريقة المحددة مسبقًا لعرض قيم الوقت والتاريخ في JavaScript.

### The Date class

تحتوي JavaScript على فئة قياسية لعرض التواريخ - أو النقاط الزمنية. يطلق عليه Date, إذا قمت ببساطة بإنشاء كائن date باستخدام new . تحصل على date  والوقت time الحاليين.

```text
console.log(new Date());
// → Mon Nov 13 2017 16:19:11 GMT+0100 (CET)
```

يمكنك أيضًا إنشاء كائن لفترة زمنية محددة.

```text
console.log(new Date(2009, 11, 9));
// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)
console.log(new Date(2009, 11, 9, 12, 59, 59, 999));
// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)
```

يستخدم JavaScript اصطلاحًا حيث تبدأ أرقام الأشهر من الصفر \(لذا فإن ديسمبر هو 11\) ، ومع ذلك تبدأ أرقام اليوم من واحد. هذا محير وسخيف. كن حذرا.

الوسيطات  الاربع الاخيره \(hours, minutes, seconds, and milliseconds\) اختيارية وتعتبر صفراً في حالة عدم تقديمها.

يتم تخزين الطوابع الزمنية \(Timestamps\)على أنها عدد المللي ثانية منذ بداية 1970 ، في المنطقة الزمنية UTC. تعتمد هذه الطريقة على "Unix time" الذي تم اختراعه في نفس العام تقريبًا. يمكنك استخدام الأرقام السالبة لمرات ما قبل 1970. تقوم طريقة getTime بإنشاء هذا الرقم في كائن التاريخ. هذا الرقم كبير بقدر ما يمكنك تخمينه.

```text
console.log(new Date(2013, 11, 19).getTime());
// → 1387407600000
console.log(new Date(1387407600000));
// → Thu Dec 19 2013 00:00:00 GMT+0100 (CET)
```

إذا أعطيت منشئ التاريخ وسيطة واحدة, يتم التعامل مع هذه الوسيطة على أنها عدد ميلي ثانية. يمكنك الحصول على عدد الملي ثانية الحالي عن طريق إنشاء كائن   `Date`new و استدعاء getTime عليه أو عن طريق استدعاء وظيفة Date.now.

توفر كائنات التاريخ طرقًا مثل getFullYear و getMonth و getDate و getHours و getMinutes و getSeconds لاستخراج مكوناتها. إلى جانب getFullYear ، هناك أيضًا getYear ، والتي تمنحك السنة ناقص 1900 \(98 أو 119\) وهي في الغالب عديمة الفائدة.

بوضع أقواس حول أجزاء التعبير التي نهتم بها ، يمكننا الآن إنشاء كائن تاريخ من سلسلة.

```text
function getDate(string) {
  let [_, month, day, year] =
    /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
  return new Date(year, month - 1, day);
}
console.log(getDate("1-30-2003"));
// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)
```

حرف التسطير السفلي \(\_\) المستخدم في المثال كمتغير ليس له أي فائدة هنا ويستخدم فقط لتمرير الخلية الأولى من صفيف الإخراج exec.

### Word and string boundaries  حدود الكلمات والسلسلة

من أجل الراحة ، يعد اختبار getDate أيضًا تاريخًا عشوائيًا مثل 00-1-3000 من السلسلة "100-1-30000". من الممكن قد يحدث التطابق في أي مكان في السلسلة ، لذلك في هذه الحالة ، سيبدأ فقط عند الحرف الثاني وينتهي عند الحرف الثاني إلى الأخير.

إذا أردنا أن تتضمن المطابقة السلسلة بأكملها ، فعلينا القيام بذلك باستخدام علامة ^ و $. يشير الحرف ^ إلى بداية سلسلة الإدخال ، بينما يقوم الحرف $ بهذا في النهاية. . إذن /$+d\^/ سيتطابق مع سلسلة تحتوي على رقم واحد أو أكثر في المجموع ، /! ^ / يطابق أي سلسلة تبدأ بعلامة تعجب , / ^x  / لا يطابق أي سلسلة\(لا يمكن تخيل حرف x قبل أن يبدأ الحرف سلسلة\).

من ناحية أخرى ، إذا أردنا التأكد من أن التاريخ يبدأ وينتهي عند حدود الكلمة ، فيمكننا استخدام علامة  b \.     يمكن أن يكون حد الكلمة هو بداية السلسلة النصية أو نهايتها أو أي نقطة في السلسلة تحتوي على حرف كلمة \(كما في  w \\) على جانب واحد وحرف nonword على الجانب الآخر.

```text
console.log(/cat/.test("concatenate"));
// → true
console.log(/\bcat\b/.test("concatenate"));
// → false
```

لاحظ أن علامة الحدود لا تتطابق مع الحرف نفسه. لاحظ أن علامة الحدود لا تتطابق مع الحرف نفسه. تتسبب هذه العلامة في تطبيق التعبير النمطي فقط عند استيفاء شرط معين عند النقطة التي تكون فيها العلامة في النمط.

### Choice patterns

لنفترض أننا نريد أن نعرف ما إذا كان جزء من النص لا يحتوي فقط على رقم بل على رقم متبوع بإحدى الكلمات خنزير أو بقرة أو دجاج أو أي من صيغ الجمع.

يمكننا كتابة ثلاثة تعبيرات نمطية واختبارها بدورها ، ولكن هناك طريقة أفضل. يشير حرف الأنبوب \(\|\) إلى الاختيار بين النمط على يساره والنمط على يمينه. لذلك أستطيع أن أقول هذا:

```text
let animalCount = /\b\d+ (pig|cow|chicken)s?\b/;
console.log(animalCount.test("15 pigs"));
// → true
console.log(animalCount.test("15 pigchickens"));
// → false
```

يمكن استخدام الأقواس لتقييد أجزاء من النمط الذي يتم تطبيق مشغل الأنبوب عليه ، ويمكن تجميع العديد من مشغلي الأنابيب معًا للسماح بالاختيار بين أكثر من بديلين. 

### The mechanics of matching

من الناحية المفاهيمية ، عند استخدام أسلوب exec أو test ، يبحث محرك تعبير العبارة عن تطابق في السلسلة ويحاول القيام بذلك عن طريق مطابقة العبارة في بداية السلسلة ، ثم الحرف الثاني. ، وهكذا حتى تعثر على تطابق أو تصل إلى نهاية سلسلة معينة. في نهاية السلسلة ، تقوم إما بإرجاع أول تطابق ممكن أو فشل البحث.

يتعامل محرك JavaScript مع التعبير العادي مثل مخطط انسيابي للمطابقة. الرسم البياني أدناه هو مثال لحيوان:

![](.gitbook/assets/image%20%2815%29.png)

يتطابق تعبيرنا إذا تمكنا من إيجاد مسار من الجانب الأيسر للشكل إلى الجانب الأيمن. نحتفظ بالموقع الحالي في السلسلة ، وفي كل مرة نتحرك فيها عبر مربع ، نتحقق من أن جزء السلسلة بعد موضعنا الحالي يطابق هذا المربع.

لذلك إذا حاولنا مطابقة " the pigs 3 " من الموضع 4 ، فسيبدو تقدمنا ​​خلال مخطط التدفق كما يلي:

* في الموضع 4 ، يوجد حد للكلمة ، لذا يمكننا تجاوز المربع الأول.
* ما زلنا في الموضع 4 ، ونرى رقمًا ، لذا يمكننا عبور المستطيل التالي أيضًا.
* في الموضع 5 ، يعود أحد المسارات إلى المستطيل الثاني \(رقم\) ، بينما ينتقل المسار الآخر إلى المستطيل الذي يحتوي على حرف مسافة فارغة. هناك مساحة فارغة هنا ، وليس رقمًا ، لذلك علينا أن نسير في الاتجاه الثاني.
* نحن الآن في الموضع 6 \(بداية سلسلة الخنازير\) وفي الفرع ثلاثي الاتجاهات من المخطط. نحن لا نرى بقرة ودجاج هنا ، لكننا نرى خنزير ، لذلك نذهب إلى ذلك الفرع.
* في الموضع 9 ، بعد الفرع ثلاثي الاتجاهات ، يتجاهل أحد المسارات المستطيل s ويذهب مباشرة إلى حد الكلمة الأخيرة ، بينما يتطابق المسار الآخر مع s. يوجد حرف s هنا ، وليس حدًا للكلمة ، لذلك ننتقل عبر المربع s.
* نحن في الموضع 10 \(نهاية السلسلة\) ويمكننا مطابقة حد كلمة فقط نهاية السلسلة تعني حد الكلمة ؛ ننتقل إلى المستطيل الأخير ونطبق هذه السلسلة بنجاح.

### Backtracking   التراجع <a id="backtracking"></a>

التعبير /b \(\[01\] + b \| \[ \da-f\] + h \| \ d +\)  \b \/ يتوافق مع أحد الأرقام التالية: رقم ثنائي متبوعًا بـ a b ,  رقم سداسي عشري \(رقم أساسي 16 بالأحرف من a إلى f للأرقام من 10 إلى 15\) متبوعًا بحرف h ، أو رقم عشري عادي بدون لاحقة.الرسم البياني التالي يتعلق بهذه العبارة:

![](.gitbook/assets/image%20%281%29.png)

عند مطابقة هذا التعبير ، غالبًا ما يحدث أن يتم إدخال الفرع العلوي \(الثنائي\) على الرغم من أن الإدخال لا يحتوي بالفعل على رقم ثنائي. عند مطابقة السلسلة "103" ، على سبيل المثال ، يتضح فقط عند الرقم 3 أننا في الفرع الخطأ. السلسلة لا تتطابق مع التعبير ، وليس الفرع الذي نحن فيه حاليًا.

لذلك يقوم المحول بالانعكاس. عند دخول فرع ، يتذكر موقعه الحالي \(هنا ، في بداية السلسلة ، قبل مستطيل الحد الأول \(النطاق\) في الرسم التخطيطي\) ، يمكن أن يعود للخلف ويذهب إلى فرع آخر إذا لم يستجب الفرع الحالي. بالنسبة للسلسلة "103" ، بعد مواجهة الحرف 3 ، تنتقل إلى فرع الأرقام السداسية العشرية ، الذي لن يعمل لأنه لا يوجد حرف h بعد الرقم. لذلك يذهب إلى فرع الأرقام العشري. هذا الفرع هو الاختيار الصحيح ويتم الإبلاغ عن التكيف في النهاية.

يتوقف المحول بمجرد تطابقه بالكامل. هذا يعني أنه في حالة وجود العديد من الفروع المحتملة لمطابقة سلسلة ، فسيتم استخدام الفرع الأول فقط \(بالترتيب الذي تم وضع الفرع به في التعبير العادي\).

يمكن كتابة التعبيرات العادية التي يتم فيها تنفيذ عدد كبير من الانحدارات. تحدث هذه المشكلة عندما يمكن للقالب تكييف إدخال بعدة طرق مختلفة. على سبيل المثال ، إذا لم نتوخى الحذر عند كتابة تعبير عادي لرقم ثنائي ، فقد نكتب عن طريق الخطأ شيئًا مثل:

/\(\[01\]+\)+b/

![](.gitbook/assets/image%20%284%29.png)



إذا حاول هذا النمط مطابقة سلسلة طويلة من الأصفار والآحاد بدون الحرف الأخير b ، ينتقل المحول أولاً إلى الحلقة الداخلية حتى يتم استخدام جميع الأرقام. ثم يدرك أن الحرف b غير موجود ، لذا فهو يعكس مكانًا ، ويذهب إلى الحلقة الخارجية مرة واحدة ولا يحصل على أي نتائج ، ويعود مرة أخرى للخروج من الحلقة الداخلية. أي أن مقدار العمل المنجز لكل شخصية يتضاعف. حتى بالنسبة لبضع عشرات من الشخصيات ، فإن إجراء المطابقة سيستغرق في الواقع إلى الأبد.

### The replace method  طريقة الاستبدال

تحتوي قيم السلسلة على طريقة تسمى replace يمكن استخدامها لاستبدال جزء من سلسلة بسلاسل أخرى.

```text
console.log("papa".replace("p", "m"));
// → mapa
```

يمكن أن تكون الوسيطة الأولى لهذه الطريقة أيضًا تعبيرًا عاديًا ، وفي هذه الحالة يتم استبدال المطابقة الأولى التي تم العثور عليها بواسطة التعبير العادي بالسلسلة المطلوبة. عند إضافة الخيار g \(global\) إلى التعبير العادي ، سيتم استبدال جميع التطابقات الموجودة في السلسلة بدلاً من استبدال الأول.

```text
console.log("Borobudur".replace(/[ou]/, "a"));
// → Barobudur
console.log("Borobudur".replace(/[ou]/g, "a"));
// → Barabadar
```

يبدو من الأفضل أن يكون هناك خيار بين استبدال جميع المباريات أو مباراة واحدة,  تم تعريفه على أنه وسيطة منفصلة لطريقة replace أو تم النظر في طريقة مختلفة لها ؛ مثل replaceAll. لكن لسوء الحظ ، يعتمد هذا الخيار على خاصية في التعبير النمطي.

تتمثل القوة الرئيسية لاستخدام التعبيرات النمطية بواسطة طريقة replace في أنه يمكننا الرجوع إلى المجموعات المكيفة في المجال البديل. على سبيل المثال ، لنفترض أن لدينا سلسلة كبيرة تحتوي على أسماء الأشخاص ، وهناك اسم في كل سطر وتنسيقه هو  `Firstname`  ،  `lasttname` . إذا أردنا تغيير ترتيب الحروف وإزالة الفاصلة بينها ، فيمكننا استخدام الكود التالي:

```text
console.log(
  "Liskov, Barbara\nMcCarthy, John\nWadler, Philip"
    .replace(/(\w+), (\w+)/g, "$2 $1"));
// → Barbara Liskov
//   John McCarthy
//   Philip Wadler
```

يشير $ 1 و $ 2 في سلسلة الاستبدال إلى المجموعات الموجودة بين قوسين في النموذج. يتم استبدال $ 1 بالنص المطابق للمجموعة الأولى ، و 2 دولارًا بالثانية ، وهكذا ، حتى 9 دولارات. يمكن الإشارة إلى المباراة بأكملها      بـ $ &.

يمكن تمرير دالة بدلاً من سلسلة كوسيطة ثانية لطريقة الاستبدال. لكل استبدال ، يتم استدعاء هذه الوظيفة أثناء تمرير الدُفعة المطابقة \(بالإضافة إلى المطابقة الكاملة\) كوسيطة ، ويتم وضع القيمة التي ترجعها في السلسلة الجديدة.



فكر في المثال الصغير التالي:

```text
let s = "the cia and fbi";
console.log(s.replace(/\b(fbi|cia)\b/g,
            str => str.toUpperCase()));
// → the CIA and FBI
```

ومثال أكثر إثارة للاهتمام:

```text

1
let stock = "1 lemon, 2 cabbages, and 101 eggs";
2
function minusOne(match, amount, unit) {
3
  amount = Number(amount) - 1;
4
  if (amount == 1) { // only one left, remove the 's'
5
    unit = unit.slice(0, unit.length - 1);
6
  } else if (amount == 0) {
7
    amount = "no";
8
  }
9
  return amount + " " + unit;
10
}
11
console.log(stock.replace(/(\d+) (\w+)/g, minusOne));
12
// → no lemon, 1 cabbage, and 100 eggs
```

يأخذ هذا سلسلة ، ويجد جميع تكرارات رقم متبوعًا بكلمة أبجدية رقمية ، ويعيد سلسلة حيث يتم إنقاص كل تكرار من قبل واحد.

يتم استخدام المجموعة \( +d \\) كوسيطة المبلغ في الوظيفة ، ويتم تعيين المجموعة \( +w \\) للوحدة.  تقوم هذه الوظيفة amount  بتحويل المبلغ إلى رقم - سيعمل هذا دائمًا بشكل صحيح لأنه يتم مطابقته بـ  +d\  - وتغييره إذا كان هناك واحد فقط وصفر متبقي.

### Greed المشغلين الجشعين

```text
function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*\*\//g, "");
}
console.log(stripComments("1 + /* 2 */3"));
// → 1 + 3
console.log(stripComments("x = 10;// ten!"));
// → x = 10;
console.log(stripComments("1 /* a */+/* b */ 1"));
// → 1  1
```

سيتوافق الجزء الذي يظهر قبل عامل التشغيل "أو" \(or\) مع حرفين مائلتين يمكن أن يتبعهما أي حرف غير أحرف السطر الجديد .الجزء المتعلق بالأوصاف متعددة الأسطر أكثر تعقيدًا بعض الشيء. لقد استخدمنا \[^\] \(أي أي حرف لا يتناسب مع مجموعة فارغة من الأحرف\) كطريقة لمطابقة جميع الأحرف. لا يمكننا استخدام نقطة واحدة فقط \(.\) لهذا الغرض هنا لأن كتل التعليقات يمكن كتابتها في أسطر متعددة ولا يتطابق الحرف النقطي مع أحرف السطور الجديدة.

لكن يبدو أن ناتج السطر الأخير خاطئ. لماذا ا؟

الجزء  \* \[^\]العبارة ، كما أوضحت في قسم الانعكاس ، تناسبها في البداية بقدر الإمكان. إذا تسبب هذا في فشل الجزء التالي من النمط ، فسيعود محول الشخصية ويحاول مرة أخرى من تلك النقطة. في المثال أعلاه ، يحاول المحول أولاً مطابقة السلسلة المتبقية بالكامل ثم يتراجع. سيؤدي هذا إلى مطابقة مثيل من  /\* بعد إرجاع أربعة أحرف. لم يكن هذا ما كنا نبحث عنه - كان هدفنا مطابقة تفسير ، وليس التمرير إلى نهاية كود البرنامج للعثور على نهاية كتلة الوصف الأخيرة

بسبب هذا السلوك ، نقول إن عوامل التكرار \(+ ، \* ،؟ ، و {}\) جشعون ، مما يعني أنها تتطابق قدر الإمكان وتتراجع من هناك. إذا وضعت علامة استفهام بعدهم \(+ ؟، \* ؟، ؟؟، {}؟\) ، فإنهم يصبحون غير متفقين ويبدأون بالمطابقة بأقل قدر ممكن ، ومطابقة أكثر فقط عندما لا يتناسب النمط المتبقي مع التطابق الأصغر.

وهذا بالضبط ما نريده في هذه الحالة. من خلال مطابقة أصغر فترات الأحرف مع النجمة التي تقودنا إلى / \* ، اخترنا كتلة وصف واحدة فقط وليس أكثر.

```text
function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*?\*\//g, "");
}
console.log(stripComments("1 /* a */+/* b */ 1"));
// → 1 + 1
```

عندما يعمل عامل غير جشع بشكل أفضل لحل مشكلة ما ، إذا كنت تستخدم عامل تشغيل جشع بدون سبب أو وعي ، فقد تواجه العديد من الأخطاء في البرنامج. عند استخدام عامل تكرار ، من الأفضل اختيار الإصدار غير الجشع أولاً.

ولكن يمكنك إنشاء سلسلة واستخدام مُنشئ RegExp عليها. فكر في مثال:

```text
let name = "harry";
let text = "Harry is a suspicious character.";
let regexp = new RegExp("\\b(" + name + ")\\b", "gi");
console.log(text.replace(regexp, "_$1_"));
// → _Harry_ is a suspicious character.
```

عند كتابة علامات الحدود  b ، يجب أن نستخدم خطوتين عكسيتين لأننا نكتبهما في سلسلة عادية ، وليس تعبيرًا عاديًا محاطًا بشرطة مائلة. . الوسيطة الثانية لمنشئ RegExp مرتبطة بخيارات التعبير العادي - في هذا المثال ، يتم استخدام "gi" لتحديد الأحرف الكبيرة والصغيرة.

ولكن ماذا لو كان اسم المستخدم المعني "dea + hl \[\] rd" ، الذي ينتمي إلى مراهق خبير في استخدام الكمبيوتر؟ يتسبب هذا الاسم في إنشاء عبارة لا معنى لها لا تتطابق مع اسم المستخدم.

حل هذه المشكلة هو إضافة رد فعل عنيف قبل كل حرف له معنى خاص.

```text
let name = "dea+hl[]rd";
let text = "This dea+hl[]rd guy is super annoying.";
let escaped = name.replace(/[\\[.+*?(){|^$]/g, "\\$&");
let regexp = new RegExp("\\b" + escaped + "\\b", "gi");
console.log(text.replace(regexp, "_$&_"));
// → This _dea+hl[]rd_ guy is super annoying.
```

### The search method طريقه البحث 

لا يمكن استدعاء طريقة indexOf على السلاسل بتعبير عادي. ولكن هناك طريقة أخرى تسمى search تحصل على تعبير منتظم. تمامًا مثل indexOf ، تقوم هذه الطريقة بتعيين خلية الإخراج الأولى للتعبير الموجود أو إرجاع 1- إذا لم يتم العثور على نتيجة.

```text
console.log("  word".search(/\S/));
// → 2
console.log("    ".search(/\S/));
// → -1
```

لسوء الحظ ، لا توجد طريقة لتحديد نقطة بداية للمطابقة \(على غرار ما يمكننا القيام به باستخدام وسيطة indexOf الثانية\) التي كانت ستنجح لو كانت كذلك.

### The lastIndex property

وبالمثل ، لا توفر طريقة exec طريقة مناسبة لبدء البحث من موضع معين في السلسلة. لكنها توفر طريقة غير مريحة.

كائنات التعبير العادي تمتلك خصائص,  أحد هذه الخصائص هو المصدر' source' ، الذي يحتوي على السلسلة التي تم إنشاء التعبير منها. خاصية أخرى هي lastIndex ، والتي تتحكم بطريقة محدودة في مكان بدء المطابقة التالية.

الشرط هو أن التعبير النمطي يجب أن يحتوي على الخيارين العام \(g\) أو الثابت \(y\) ممكّنين ، ويجب إجراء المطابقة باستخدام طريقة ‌exec. مرة أخرى ، قد يكون الحل الأقل إرباكًا هو السماح بتمرير وسيطة إضافية إلى طريقة exec للقيام بذلك ، ولكن الارتباك هو سمة أساسية لواجهة التعبير العادي في JavaScript.

```text
let pattern = /y/g;
pattern.lastIndex = 3;
let match = pattern.exec("xyzzy");
console.log(match.index);
// → 4
console.log(pattern.lastIndex);
// → 5
```

إذا كانت المطابقة ناجحة ، فسيقوم استدعاء exec تلقائيًا بتحديث خاصية lastIndex للإشارة إلى النقطة بعد المباراة. إذا لم يتم العثور على تطابق ، فسيأخذ lastIndex القيمة صفر ، وهي القيمة التي يحملها الكائن عند إنشاء تعبير تعبير جديد.

يتمثل الاختلاف بين الخيارين العام والخيار الثابت في أنه عند تمكين الخيار الثابت ، ستنجح المطابقة عندما تبدأ مباشرةً من نقطة الفهرس الأخيرة lastIndex ، بينما في الوضع العام ، سيتم إعادة توجيه البحث إلى موضع يمكن بدء المطابقة فيه. 

```text
let global = /abc/g;
console.log(global.exec("xyz abc"));
// → ["abc"]
let sticky = /abc/y;
console.log(sticky.exec("xyz abc"));
// → null
```

يمكن أن تكون هذه التحديثات التلقائية لـ lastIndex مشكلة إذا استخدمنا تعبير قاعدة شائعة لاستدعاءات exec متعددة. قد يبدأ تعبيرك العادي عن طريق الخطأ بفهرس متبقٍ من المكالمة السابقة.

```text
let digit = /\d/g;
console.log(digit.exec("here it is: 1"));
// → ["1"]
console.log(digit.exec("and now: 1"));
// → null
```

تأثير آخر مثير للاهتمام للخيار العام هو أنه يغير طريقة عمل method المطابقة على السلاسل. عندما يتم استدعاؤها بتعبير عام ، بدلاً من إرجاع مصفوفة مماثلة لتلك التي تم إرجاعها بواسطة exec ، فإن match سوف تعثر على جميع تطابقات النمط في السلسلة وتعيد مصفوفة تحتوي على السلاسل المتطابقة.

```text
console.log("Banana".match(/an/g));
// → ["an", "an"]
```

لذا كن حذرًا مع التعبيرات العادية والعامة. عادةً ما يكون الشيء الوحيد الذي تحتاج إلى الذهاب إليه هو عندما تحتاج إلى استدعاء طريقة الاستبدال  `replace`  ، وكذلك عندما تحتاج إلى استخدام LastIndex بشكل صريح.

#### Looping over matches تكرار المباريات

تتمثل إحدى المهام الشائعة في تتبع جميع مثيلات النمط في السلسلة إلى جسم الحلقة بحيث يكون الكائن المطابق متاحًا لنا. للقيام بذلك ، يمكننا استخدام طرق lastIndex و exec.

```text
let input = "A string with 3 numbers in it... 42 and 88.";
let number = /\b\d+\b/g;
let match;
while (match = number.exec(input)) {
  console.log("Found", match[0], "at", match.index);
}
// → Found 3 at 14
//   Found 42 at 33
//   Found 88 at 40
```

### Parsing an INI file تحليل ملف <a id="ini"></a>

في ختام الفصل ، سننظر في مشكلة تستدعي التعبيرات العادية. تخيل أننا نكتب برنامجًا لجمع المعلومات تلقائيًا عن أعدائنا من الإنترنت. \(لن نكتب هذا البرنامج هنا ، فقط الجزء الذي يقرأ ملف التكوين. عذرًا.\) ملف التكوين يبدو كالتالي:

> ```text
> searchengine=https://duckduckgo.com/?q=$1
> spitefulness=9.7
>
> ; comments are preceded by a semicolon...
> ; each section concerns an individual enemy
> [larry]
> fullname=Larry Doe
> type=kindergarten bully
> website=http://www.geocities.com/CapeCanaveral/11451
>
> [davaeorn]
> fullname=Davaeorn
> type=evil wizard
> outputdir=/home/marijn/enemies/davaeorn
> ```

القواعد الخاصة بهذا الملف \(وهو تنسيق شائع جدًا ويسمى عادةً ملف INI\) هي كما يلي:

* يتم تجاهل الأسطر والأسطر الفارغة التي تبدأ بفواصل منقوطة.
* لف الخطوط في \[and\] تبدأ قسمًا جديدًا.
* تضيف الأسطر التي تحتوي على معرف مكون من حرف رقمي متبوعًا بحرف = خيارًا إلى إعدادات القسم الحالية.
* أي شيء غير ما سبق يعتبر باطلاً.

مهمتنا هي تحويل سلسلة مثل هذه إلى كائن تحتوي خصائصه على سلاسل للإعدادات المكتوبة قبل رأس القسم الأول والكائنات الفرعية للأقسام ، مع احتفاظ تلك الكائنات الفرعية بإعدادات القسم.

نظرًا لأنه يجب معالجة هذا التنسيق سطرًا بسطر ، فإن تقسيم الملف إلى أسطر منفصلة يبدو بداية جيدة. لقد رأينا طريقة الانقسام split في الفصل  [Chapter 4](https://eloquentjavascript.net/04_data.html#split).  بعض أنظمة التشغيل ، لأي سبب كان ، لا تستخدم فقط حرف السطر الجديد لفصل السطور ، ولكن تستخدم أيضًا حرفًا يعود إلى بداية السطر ثم حرف سطر جديد للقيام بذلك \(" r \ n\"\). مع العلم أنه يمكننا إرسال تعبير عادي إلى طريقة التقسيم ، يمكننا فصل الأسطر بتعبير عادي مثل /  n\؟r \/ ، مما يتسبب في كلاً من " n\" و " r\  n\" .

```text
function parseINI(string) {
  // Start with an object to hold the top-level fields
  let result = {};
  let section = result;
  string.split(/\r?\n/).forEach(line => {
    let match;
    if (match = line.match(/^(\w+)=(.*)$/)) {
      section[match[1]] = match[2];
    } else if (match = line.match(/^\[(.*)\]$/)) {
      section = result[match[1]] = {};
    } else if (!/^\s*(;.*)?$/.test(line)) {
      throw new Error("Line '" + line + "' is not valid.");
    }
  });
  return result;
}

console.log(parseINI(`
name=Vasilis
[address]
city=Tessaloniki`));
// → {name: "Vasilis", address: {city: "Tessaloniki"}}
```

يعمل الكود أعلاه عن طريق معالجة ملف سطرًا بسطر وإنشاء كائن. يتم تخزين خصائص الجزء العلوي مباشرة داخل الكائن ، بينما يتم تخزين خصائص الأجزاء بشكل منفصل لكل جزء من الكائن. يشير متغير section إلى كائن القسم الحالي.

هناك نوعان بارزان من الخطوط - رؤوس الأقسام أو سطور الخصائص. عندما يمثل السطر خاصية مشتركة ، يتم تخزينه في section الحالي. عندما يمثل رأس قسم ، يتم إنشاء كائن جديد للمقطع ويتم تعيين قسم له.

لاحظ أن الاستخدام المتكرر لـ ^ و $ هو التأكد من تطابق العبارة مع السطر بأكمله ، وليس جزءًا منه فقط. إذا تركت دون إدارة ، يمكن أن تترك في ضلال وتفقد المسار الصحيح. 

يشبه النمط\(\(...\) if \(match = string.match  خدعة استخدام مهمة كشرط لـ while .غالبًا ما تكون غير متأكد من أن مكالمتك لـ match ستنجح. حتى تتمكن من الوصول إلى الكائن الناتج فقط داخل عبارة if التي تختبر ذلك. لمنع كسر السلسلة else if, قمنا بتعيين نتيجة التطابق إلى متغير واستخدمنا هذا التخصيص على الفور كشرط لتعليمة if.

إذا لم يكن السطر هو رأس مقطع أو خاصية ، فإن الدالة تستخدم التعبير / ^\s_\(؛._\)؟$/ للتحقق مما إذا كان هذا السطر تفسيرًا أم سطرًا فارغًا. هل لاحظت كيف يعمل؟ هل يتطابق الجزء الموجود بين قوسين مع الوصف وعلامة الاستفهام؟ يضمن تحديد الخطوط التي هي مجرد مساحة فارغة. إذا كان الخط لا يتطابق مع أي من الأشكال المتوقعة ، تقوم الدالة بإنشاء استثناء.

### International characters شخصيات دولية

نظرًا لأن التطبيق الأولي لجافا سكريبت كان بسيطًا جدًا ، وحقيقة أن هذا النهج المبسط قد اعتُبر لاحقًا معيارًا للسلوك ، فإن التعبيرات العادية في JavaScript بسيطة نسبيًا للأحرف غير الإنجليزية. ليس لديهم ما يقولونه. على سبيل المثال ، في عبارات JavaScript العادية ، يحتوي "حرف الكلمة" على 26 حرفًا لاتينيًا فقط \(أحرف كبيرة وصغيرة\) وأرقام عشرية ، ولسبب ما على حرف الشرطة السفلية. أشياء مثل é أو β ، والتي هي بالتأكيد أحرف كلمة ، لا تتم مطابقتها بـ  w \(ويقابلها  W ، مجموعة من الأحرف غير المكونة لكلمة\).

نظرًا لحدوث غير معروف في الماضي ، لا توجد هذه المشكلة  s\ \(مسافة فارغة\) وتتضمن جميع الأحرف التي يعتبرها معيار Unicode مساحة فارغة ، مثل الأحرف مثل الفواصل المنقوطة وحروف العلة في المنغولية.

مشكلة أخرى هي أن التعبيرات النمطية بشكل افتراضي تعمل على وحدات من التعليمات البرمجية ؛ ليس على الشخصيات الحقيقية. كما تمت مناقشته في الفصل 5  [Chapter 5](https://eloquentjavascript.net/05_higher_order.html#code_units). هذا يعني أن الأحرف التي تتكون من وحدتين من الكود يتم التعامل معها بشكل عشوائي.

```text
console.log(/🍎{3}/.test("🍎🍎🍎"));
// → false
console.log(/<.>/.test("<🌹>"));
// → false
console.log(/<.>/u.test("<🌹>"));
// → true
```

تكمن المشكلة في أن 🍎 في السطر الأول تُعرف بوحدتين من التعليمات البرمجية ، و {3} تنطبق فقط على الوحدة الثانية. وبالمثل ، يتعرف مشغل النقطة على وحدة واحدة فقط من الكود ، وليس الوحدتين اللتين تشكلان الرمز التعبيري الوردي.

يجب عليك استخدام خيار u \(Unicode\) للنظر في التعبير العادي لهذه الأحرف. لسوء الحظ ، سيحدث هذا افتراضيًا ، حيث قد يتسبب تغييره في حدوث مشكلات في التعليمات البرمجية المكتوبة مسبقًا والتي تعتمد على هذا السلوك. 

على الرغم من أن هذا قد تم توحيده للتو ، إلا أنه في وقت كتابة هذا التقرير ، لا يزال غير مدعوم على نطاق واسع ، يمكن استخدام  P\ في تعبير عادي \(تعبير يجب أن يتم تمكين خيار Unicode به\) لمطابقة جميع الأحرف التي يكون لمعيار Unicode خاصية لها.

```text
console.log(/\p{Script=Greek}/u.test("α"));
// → true
console.log(/\p{Script=Arabic}/u.test("α"));
// → false
console.log(/\p{Alphabetic}/u.test("α"));
// → true
console.log(/\p{Alphabetic}/u.test("!"));
// → false
```

يحدد Unicode عددًا من الخصائص المفيدة ، على الرغم من أن العثور على الخاصية التي تحتاجها قد لا يكون دائمًا سهلاً.  يمكنك استخدام الأمر

 \p {Property=Value} تُستخدم لمطابقة أي حرف له قيمة معينة له

إذا قمنا بحذف اسم الخاصية كما ترى في  {p {Name \. ، فإن اسمه يعتبر خاصية ثنائية مثل Alphabetic أو فئة مثل Number.

### Summary <a id="summary_regexp"></a>









