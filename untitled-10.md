# Project: A Programming Language

## مشروع : لغة برمجة <a id="&#x645;&#x634;&#x631;&#x648;&#x639;--&#x644;&#x63A;&#x629;-&#x628;&#x631;&#x645;&#x62C;&#x629;"></a>

”المُقَدِّر، ذاك الَّذي يُحَدِّدُ معنى التعابير في لغة البرمجة، ما هو إلَّا برنامجٌ آخر.“ ـــ هال أبيلسون وَجيرالد سوزمان، هيكليَّة وَتفسير لغات الحاسِب.

11 مَشْرُوْعٌ: لُغَةُ بَرمَجَةٍ

إنَّ بناء لغة برمجةٍ خاصَّةٍ بك بِانذهالٍ أمرٌ سَهلٌ \(طالما أنَّك لا تطمح عاليًا!\) ومُنيرٌ جدًّا للعقل. الشيء الرئيسي الَّذي أُريد عرضَه في هذا الفصل أنَّهُ لا يوجد سحرٌ منخرط في عمليَّة بناء لغتك الخاصَّة. فقد شَعرتُ غالبًا أنَّ بعض إختراعات البشر ذكيَّة ومُعَقَّدة كثيرًا وأنَّني لن أكون قادرًا على فهمها أبدًا. ولكن بقليلٍ من القراءة والتفكير، تصبح هذه الأشياء عاديَّة تمامًا. سنبني لُغَةَ بَرمَجَةٍ تُدعى "بيضة" Egg. وستكون لغة صغيرة وبسيطة ولكن قويَّة كفايةً لِتُعَبِّر عن أي حَوسَبَةٍ تُفَكِّرُ بِهَا. وستسمح أيضًا بفِكْرِ التجريد abstraction البسيط المُعتمد على الدوال.

## الإعراب Parsing <a id="&#x627;&#x644;&#x625;&#x639;&#x631;&#x627;&#x628;-parsing"></a>

أَوَّلُ جُزءٍ يُرى من لُغَةِ البرمجة هو نَحْوِيَّتُها syntax أو تَرقِيْمُهَا notation. والمُعَرِّبُ parser هو برنامج يقرأ قِطْعَة نَصِّيَّة ويُنْتِجُ هيكليَّة بيانات تعكس بُنية البرنامج المُحتوى في النص. وإن لم يُشَكِّل النص برنامجًا صالِحًا، فيجب عندئذٍ أن يَحتَجَّ المُعَرِّبُ ويُشيرَ إلى الخطأ. سيكون للغتنا نَحْوِيَّة بسيطة وَمُوَحَّدَة. وكل شيء في Egg هو تَعْبِيْرٌ expression. فيمكن للتعبير أن يكون مُتَغَيِّرًا variable، عَدَدًا number، سِلْسِلَةً نَصِّيَّةً string، أو تَطْبِيْقًا application. حيثُ تُستَخدم التطبيقات لإستدعاءات الدالة ولكن أيضًا من أجل التركيبات مثل "إذا" if أو "طالما" while. ولإبقاء المُعَرِّب بسيطًا، فإنَّ السلاسل النصيَّة في Egg لا تدعم أيَّ شيءٍ مِثْلَ مُهَرِّبات الشَّرِطَة الخَلفيَّة &lt;&gt; backslash escapes. وإنَّ السلاسل النصيَّة ببساطة عبارة عن تتَالي من المَحارف وليست إقتباسات مُضَاعَفَة &lt;"&gt; مُغَلَّفَة بِإقتباسات مُضاعفة أخرى. والعدد هو تتَالي من الأرقام. والمُتَغَيِّرات هي أسماءٌ تتألَّف من أي مَحرَف عدا المسافة البيضاء whitespace ولا يجب أن يكون لها معنىً خاص بِنَحَوِيَّةِ اللُّغة syntax. تُكْتَبُ التطبيقات كما هو الحال في الجافا سكرِبت، بوضع أقواس بعد التعبير حاويةً عددًا من الجَدَليَّات بين هذه الأقواس ومفصولةً بفواصِل.

```text
do(define(x, 10),
    if(>(x , 5),
        print("large"),
        print("small")))
```

الإتِّسَاق في لغة Egg يعني أنَّ الأشياء الَّتي تُعتَبَر مُعَامِلات operators في الجافا سكرِبت \(مثل &lt;\) هي مُتَغَيِّرَات عاديَّة في هذه اللُّغة، مُطَبَّقَة كما الوظائف الأخرى. وبما أنَّهُ ليس لِلْنَحَوِيَّةِ مفهوم الحاجِز block، فسنحتاج البُنْيَة do للقيام بالعديد من الأمور. هيكليَّة البيانات الَّتي سييتخدمها المُعَرِّب لوصف البرنامج ستتألَّف من كائنات تعبيريَّة، وكل منها له خاصيَّة نوع تشير لصنف التعبير وخواصٌّ أخرى لوصف محتوياتها. تُمَثَّلُ التعابير من نوع "قيمة" "value" سلاسل نَصِّيَّة أو عدديَّة. وتحوي قيمة خاصيَّتها النص أو العدد الَّذي تُمَثَّله. تُستَخدم التعابير من نوع "كلمة" "word" من أجل المُعَرِّفات identifiers \(أسماءٌ\). وهكذا كائنات لها الخاصيَّة "إسم" name الَّتي تحمل إسم المُعَرِّف كَسلسلة نَصِّيَّة. وأخيرًا، تُمَثِّلُ تعابير "طَبِّق" apply التطبيقات. ولها الخاصيَّة مُعَامِل operator الَّتي تُشير إلى التعبير الَّذي يُطَبَّق، والخاصيَّة "جَدَلِيَّات -حُذفت بعض أحرف الكلمة الإنكليزيَّة-" args الَّتي تُشير إلى مصفوفة array من تعابير جدليَّة. وبذلك، سَيُمَثَّل جزء البرنامج السابق &gt;\(x, 5\) هكذا:

```text
{
    type:"apply",
    operator:{type:"word", name:">"},
    args:[
        {type:"word", name:"x"},
        {type:"value", value:5}
    ]
}
```

وهيكليَّة البيانات هذه تُدعى الشجرة النحويَّة syntax tree. فإذا تَخَيَّلتَ الكائنات كَنُقَط dots والروابط بينها كَخُطوط lines \(بين هذه النقاط\)، عندئذٍ سيكون شكلها شبيه-بالشجرة tree-like. فحقيقة إحتواء التعابير تعابيرًا أخرى، والَّتي بدورها قد تحوي تعابيرًا أكثر، إنَّهُ أمرٌ شبيه بتفرُّع الأغصان مُجَدَّدًا ومُجَدَّدًا.

![](https://rabahboudia.gitbooks.io/arabic-eloquent-js/content/syntax_tree.svg)

وهذا بِتَبَايُنٍ مع المُعَرِّب الَّذي كتبناه لإعداد صيغة ملف في الفصل 9، والَّذي له هيكليَّة بسيطة: فهو يفصل الدخل input إلى أسطُر ويستوعِب هذه الأسطر كُلٌّ على حِدَىً. وكان يُسمَح للأسطُر أن تَملُك القليل فقط من الأشكال البسيطة. يجب علينا هُنَا أن نجد نَهْجًا مُختَلِفًا. فالتعابير ليست مفصولةً إلى أسطُر، ولها هيكليَّة تِكْرَارِيَّة recursive. وتحوي تعابير التطبيق تعابيرًا أخرى. وَلِحُسْنِ الحَظِّ، يمكن حَل هذه المُشكلة بِرُقِيٍّ من خلال كتابة دالَّة المُعَرِّب الَّتي هي تكراريَّة بطريقة تعكس طبيعة اللُّغة التكراريَّة. لقد عَرَّفنَا الدالَّة "أعرب التعبير" parseExpression، الَّتي تأخُذ سلسلة نَصِّيَّة كَدخل وتعود بكائن يحوي هيكليَّة بيانات التعبير الَّذي في بداية السلسلة النصيَّة، إضافةً لِجزء السلسلة النصيَّة المُتَبَقِّيَة بعد إعراب هذا التعبير. عند إعراب التعابير الفرعيَّة \(كمثال، جدليَّة تعابيرٍ ما\)، فإنَّ إعادة إستدعاء الدالَّة يبقى مُمكِنًا، وذلك مُنتِجٌ لِتعبير الجدليَّة بالإضافة إلى النص المُتَبَقِّي. وهذا النص بدوره يحوي المزيد من الجدليَّات أو رُبَّمَا يكون القوس الغالِق الَّذي يُنْهِي قائمة الجدليَّات.

هذا أَوَّلُ جُزءٍ من المُعَرِّب:

```text
{
  program = skipSpace(program);
  var match, expr;
  if (match = /^"([^"]*)"/.exec(program)) 
    expr = {type:"value", value:match[1]};
  else if (match = /^\d+\b/.exec(program))
    expr = {type:"value", value:Number(match[0])};
  else if (match = /^[^\s(),"]+/.exec(program))
    expr = {type:"word", name:match[0]};
  else
    throw new SyntaxError("Unexpected syntax:"+program);
  return parseApply(expr, program.slice(match[0].length));
}
function skipSpace(string){
  var first = string.search(/\S/);
  if ( first == -1) return "";
  return string.slice(first);
}
```

وَبِسَبَبْ سماح Egg لأي كميَّة من المسافات البيضاء بين عناصِرها، سنحتاج لِقَصِّ المسافات البيضاء بتكرار من بداية سلسلة البرنامج النصيَّة. وهذا ما تُساعِد بِهِ الدالَّة "حذف مسافة" skipSpace. بعد حذف أي مسافة بِدئيَّة، تَستخدِم parseExpression ثلاثة تعابير نمطيَّة regular expressions لِإلقاء الضوء على العناصر الثلاثة البسيطة \(المُتناهية الصغر\) الَّتي تدعمُها Egg: السلاسل النصيَّة، الأعداد، والكَلِمات. فيقوم المُعَرِّب بِبناء نوع بيانات مُختلف إعتمادًا على الَّذي طابَقَه منها. وإذا لم يُطابِق الدخل أيٍّ من العناصر الثلاثة، سيكون تعابيرًا غير مسموحٍ به، وعندها يرمي المُعَرِّب خَطَأً. "خطأ نحوي" SyntaxError وهو نوع كائن خطأ قياسيٌّ، والَّذي يعتلي عند محاولة تشغيل برنامج جافا سكرِبت غير مسموحٍ به. يمكننا إقتصاص الجزء الَّذي طابقناه من البرنامج وتمرير البرنامج إضافةً لِكائن التعبير إلى "طَبِّق الإعراب" parseApply، والَّتي تتحقَّق فيما إذا كان التعبير تَطْبِيْقًا أم لا. فإذا كان تَطْبِيْقًا، تقوم بإعراب قائمة الجدليَّات المحصورة.

```text
{
  program = skipSpace(program);
  if (program[0] != "(")
    return {expr:expr, rest:program};
  program = skipSpace(program.slice(1));
  expr = {type:"apply", operator:expr, args:[]};
  while (program[0] != ")"){
    var arg = parseExpression(program);
    expr.args.push(arg.expr);
    program = skipSpace(arg.rest);
    if (program[0] == ",")
      program = skipSpace(program.slice(1));
    else if (program[0] != ")")
      throw new SyntaxError("Expected', 'or')'");
  }
  return parseApply(expr, program.slice(1));
}
```

إذا لم يكن المَحرَف التالي في البرنامج قَوسًا مفتوحًا، فعندها هذا ليس بتطبيقٍ، وببساطة تعود parseApply بالتعبير الَّذي أُعطي لها بدايةً. بخلاف ذلك، فهي تتخطَّى القوس المفتوح وتُنشئ كائن الشَّجرة النحويَّة لتعبير هذا التطبيق. وبعدها تستدعي parseExpression بتكرارٍ لإعراب كل جدليَّة حتَّى إيجاد قوس الإغلاق. ويكون التكرار غير مباشَرٍ عبر parseApply وَإستدعاء parseExpression لنفسها مُجَدَّدًا. بسبب إمكانيَّة تطبيق تعبير التطبيق \(كما في multiplier\(2\)\(1\)\)، يجب على parseApply أن تستدعي نفسها مجدَّدًا بعد أن تَعرُب التطبيق؛ للتحقُّق فيما إذا قد أُتبعَت بزوج آخر من الأقواس. هذا كل ما نحتاجُه لإعراب Egg. فقد قُمنا بِلَفِّهَا بدالَّة إعراب مُلائِمة، والَّتي وصلت نهاية السلسلة النصيَّة المُدخَلة بعد إعراب التعبير \(فبرنامج Egg عبارة عن تعبيرٍ مُفرَد\)، وهذا أعطانا هيكليَّة بيانات البرنامج.

```text
{
  var result = parseExpression(program);
  if (skipSpace(result.rest).length>0)
    throw new SyntaxError("Unexpected text after program");
  return result.expr;
}
console.log(parse("+(a, 10)"));
//→ {type:"apply", 
// operator:{type:"word", name:"+"}, 
// args:[{type:"word", name:"a"}, 
// {type:"value", value:10}]}
```

إنَّها تعمل! ولكنَّها لا تعطينا الكثير من المعلومات المفيدة عندما تفشل ولا تُخَزِّن السطر والعمود الَّذي يبدأ عنده كل تعبير، وإرفاق هذه المعلومات قد يكون مفيدًا عند الإبلاغ عن خطأ لاحقًا، لكنَّها جيِّدة كفايةً لأهدافنا.

## المُقَدِّر The evaluator <a id="&#x627;&#x644;&#x645;&#x64F;&#x642;&#x64E;&#x62F;&#x651;&#x650;&#x631;-the-evaluator"></a>

بماذا تفيد الشَّجرة النحويَّة برنامجنا؟ تَشغِيلِهِ، بالطبع! وهذا ما يقوم به المُقَدِّر. فأنت تعطيه الشَّجرة النحويَّة وكائن البيئة الَّذي يربط الأسماء مع القيم، وسيُقَيِّم التعبير الَّذي تُمَثِّلُه الشَّجرة ويعود بالقيم المُنتَجَة.

```text
const specialForms = Object.create(null);

function evaluate(expr, scope) {
  if (expr.type == "value") {
    return expr.value;
  } else if (expr.type == "word") {
    if (expr.name in scope) {
      return scope[expr.name];
    } else {
      throw new ReferenceError(
        `Undefined binding: ${expr.name}`);
    }
  } else if (expr.type == "apply") {
    let {operator, args} = expr;
    if (operator.type == "word" &&
        operator.name in specialForms) {
      return specialForms[operator.name](expr.args, scope);
    } else {
      let op = evaluate(operator, scope);
      if (typeof op == "function") {
        return op(...args.map(arg => evaluate(arg, scope)));
      } else {
        throw new TypeError("Applying a non-function.");
      }
    }
  }
}
```

لدى المُقَدِّر رِماز\(شِفرة\) لكلِّ نوع من التعابير. فهو ببساطة يُنتج قيمة تعبير القيمة المَحرَفيَّة literal. \(على سبيل المثال، يُقَدَّرُ التعبير 100 بالرَّقم 100\). ومن أجل مُتَغَيِّرٍ ما، يجب أوَّلًا التحقُّق فيما إذا كان مُعَرَّفًا حقًّا في البيئة، فإذا كان كذلك، يقوم بالإيتاء بقيمة المُتَغَيِّر. والتطبيقات مُكْتَنَفة أكثر. فإذا كانت صياغةً خاصَّة، مثل if، لا نقوم بتقييم أي شيء وببساطة نُمَرِّر تعابير الجدليَّات، إضافة للبيئة، إلى الدالَّة المُستَوعِبَة لهذه الصياغة. وإذا كانت إستدعاءً عاديًّا، عندها نُقَدِّر المُعَاْمِل، مِمَّا يؤكِّد أنَّها دالَّة، وَتُستَدعَى عندئذٍ بنتيجة تقدير الجدليَّات. سنستخدم قيم دالَّة جافا سكرِبت بَحْتَة لتمثيل قيم دالَّة Egg. وسنعود لهذا لاحقًا، عندما تُعَرَّفُ الصيغة الخاصَّة الَّتي تُدعى fun. تُماثل البُنية التكراريَّة recursive لِلْمُقَدِّر بنية المُعَرِّب parser. فكلاهما يعكس بنية اللُّغة بحد ذاتها. ومن الممكن دمج المُعَرِّب مع المُقَدِّر وبالتالي التقدير خلال الإعراب، ولكن فصلهما بهذه الطريقة يجعل البرنامج مقروءًا أكثر. حقيقةً هذا كل ما يلزم لتفسير Egg. إنها بهذه البساطة. ولكن دون تعريف القليل من الصيغ الخاصَّة وإضافة بعض القيم المُفيدة إلى البيئة، لا يمكنك القيام بأي شيء بهذه اللُّغة حتَّى الآن.

### Special forms

يتم استخدام كائن specialForm لتعريف قواعد خاصة في Egg. يقوم هذا الكائن بتعيين كلمات للوظائف التي تقيم هذه الأشكال. هذا الكائن فارغ حاليا. دعونا نضيف if .

```text
specialForms.if = (args, scope) => {
  if (args.length != 3) {
    throw new SyntaxError("Wrong number of args to if");
  } else if (evaluate(args[0], scope) !== false) {
    return evaluate(args[1], scope);
  } else {
    return evaluate(args[2], scope);
  }
};
```

تتطلب بنية if في Egg ثلاث حجج بالضبط. يقيم الحجة الأولى ، وإذا لم تكن النتيجة خاطئة ، ينتقل إلى التقييم الثاني. خلاف ذلك ، يتم تقييم الوسيطة الثالثة.، هذا إذا كان النموذج يشبه إلى حد كبير الشكل الثلاثي لجافا سكريبت؟: عامل تشغيل منه إلى JavaScript's if . إنه تعبير وليس بيانًا ، وينتج قيمة ، أي نتيجة الوسيطة الثانية أو الثالثة.

يختلف Egg أيضًا عن JavaScript في كيفية تعامله مع قيمة الشرط إلى if. لن يتعامل مع أشياء مثل الصفر أو السلسلة الفارغة على أنها خاطئة ، فقط القيمة الدقيقة false.

يختلف Egg أيضًا عن JavaScript في كيفية تعامله مع قيمة الشرط في عبارة if. لا تعتبر هذه العبارة أشياء مثل الصفر أو السلسلة الفارغة خاطئة ، ولكنها تعتبر فقط القيمة الدقيقة للخطأ.

سبب عرض ما إذا كان نموذجًا خاصًا بدلاً من دالة عادية هو أن جميع الوسائط في الدوال يتم تقييمها قبل استدعاء الوظيفة ، بينما إذا كان يجب تقييمها فقط بعد إحدى الوسيطتين الثانية أو الثالثة ، اعتمادًا على قيمة الوسيطة الأولى. .

الشكل المحدد لـ while هو نفسه.

```text
specialForms.while = (args, scope) => {
  if (args.length != 2) {
    throw new SyntaxError("Wrong number of args to while");
  }
  while (evaluate(args[0], scope) !== false) {
    evaluate(args[1], scope);
  }

  // Since undefined does not exist in Egg, we return false,
  // for lack of a meaningful result.
  return false;
};
```

كتلة أخرى هي بنية do الأساسية التي تنفذ جميع وسائطها من أعلى إلى أسفل. قيمتها تساوي القيمة الناتجة عن الوسيطة الأخيرة.

```text
specialForms.do = (args, scope) => {
  let value = false;
  for (let arg of args) {
    value = evaluate(arg, scope);
  }
  return value;
};
```

لتكون قادرًا على إنشاء روابط ومنحهم قيمًا جديدة ، نقوم أيضًا بإنشاء نموذج يسمى define. ويتوقع أن تكون الكلمة هي الوسيطة الأولى لها وتعبير ينتج القيمة التي يجب تعيينها لتلك الكلمة كوسيطة ثانية لها. نظرًا لأن التعريف ، مثل كل شيء ، هو تعبير ، يجب أن يُرجع قيمة. سنجعله يعرض القيمة التي تم تعيينها \(تمامًا مثل عامل التشغيل = في JavaScript\).

```text
specialForms.define = (args, scope) => {
  if (args.length != 2 || args[0].type != "word") {
    throw new SyntaxError("Incorrect use of define");
  }
  let value = evaluate(args[1], scope);
  scope[args[0].name] = value;
  return value;
};
```

### The environment

النطاق المقبول من خلال  `evaluate` هو كائن له خصائص تتوافق أسماؤه مع أسماء الربط والقيم التي تتوافق مع القيم التي ترتبط بها تلك الارتباطات. دعونا نحدد كائنًا لتمثيل النطاق العالمي.

لتتمكن من استخدام بنية if التي حددناها للتو ، يجب أن يكون لدينا وصول إلى القيم المنطقية. نظرًا لوجود قيمتين منطقيتين فقط ، فإننا لا نحتاج إلى صياغة خاصة لهما. نحن ببساطة نربط اسمين بالقيم true و false ونستخدمها.

```text
const topScope = Object.create(null);

topScope.true = true;
topScope.false = false;
```

يمكننا الآن تقييم تعبير بسيط ينفي قيمة منطقية.

```text
let prog = parse(`if(true, false, true)`);
console.log(evaluate(prog, topScope));
// → false
```

لتوفير عوامل الحساب والمقارنة الرئيسية ، سنضيف أيضًا بعض قيم الوظائف إلى المجال. من أجل الإيجاز في الترميز ، بدلاً من تحديد كل واحد على حدة ، نستخدم مُنشئ الوظيفة لدمج العديد من وظائف المشغل في حلقة واحدة.

```text
for (let op of ["+", "-", "*", "/", "==", "<", ">"]) {
  topScope[op] = Function("a, b", `return a ${op} b;`);
}
```

سيكون وجود طريقة لطباعة القيم مفيدًا جدًا أيضًا ، لذلك وضعنا console.log في دالة وقمنا بتسميتها print:

```text
topScope.print = value => {
  console.log(value);
  return value;
};
```

هذا يعطينا أدوات أولية كافية لكتابة برامج بسيطة. توفر الوظيفة التالية طريقة ملائمة لتحليل برنامج وتشغيله في نطاق جديد:

```text
function run(program) {
  return evaluate(parse(program), Object.create(topScope));
}
```

سنستخدم سلسلة النموذج الأولي للكائن لتمثيل المجالات المتداخلة ، بحيث يمكن للبرنامج إضافة متغيراته الخاصة إلى المجال المحلي دون تغيير المجال الرئيسي.

```text
run(`
do(define(total, 0),
   define(count, 1),
   while(<(count, 11),
         do(define(total, +(total, count)),
            define(count, +(count, 1)))),
   print(total))
`);
// → 55
```

هذا هو البرنامج الذي رأيناه عدة مرات من قبل, الذي يحسب مجموع الأرقام من 1 إلى 10 ، معبرًا عنه بالبيض Egg. من المؤكد أنها تبدو أقبح من نظيرتها في JavaScript - ولكنها ليست سيئة بالنسبة للغة برمجة مطبقة بأقل من 150 سطرًا من التعليمات البرمجية.

### Functions <a id="egg_fun"></a>

لغة البرمجة بدون وظائف هي لغة ضعيفة.

لحسن الحظ ، من السهل إضافة بنية fun إلى اللغة ، والتي تعتبر الوسيطة الأخيرة كجسم للوظيفة وتستخدم الحجج السابقة كاسم معلمات الوظيفة.

```text
specialForms.fun = (args, scope) => {
  if (!args.length) {
    throw new SyntaxError("Functions need a body");
  }
  let body = args[args.length - 1];
  let params = args.slice(0, args.length - 1).map(expr => {
    if (expr.type != "word") {
      throw new SyntaxError("Parameter names must be words");
    }
    return expr.name;
  });

  return function() {
    if (arguments.length != params.length) {
      throw new TypeError("Wrong number of arguments");
    }
    let localScope = Object.create(scope);
    for (let i = 0; i < arguments.length; i++) {
      localScope[params[i]] = arguments[i];
    }
    return evaluate(body, localScope);
  };
};
```

الوظائف في Egg تتلقى أراضيها المحلية. الدالة التي تم إنشاؤها بواسطة fun تنشئ منطقتها المحلية وتربط حججها بها. ثم تقوم بتقييم جسم الوظيفة في هذا المجال وإرجاع النتيجة.

```text
run(`
do(define(plusOne, fun(a, +(a, 1))),
   print(plusOne(10)))
`);
// → 11

run(`
do(define(pow, fun(base, exp,
     if(==(exp, 0),
        1,
        *(base, pow(base, -(exp, 1)))))),
   print(pow(2, 10)))
`);
// → 1024
```

### Compilation

ما بنيناه هو مترجم. أثناء التقييم ، يعمل بشكل مباشر على تمثيل البرنامج الذي ينتجه المحلل اللغوي.

التجميع هو عملية يتم فيها إضافة خطوة أخرى بين تفسير البرنامج وتنفيذه ، والذي يحول كود البرنامج إلى شيء يمكن تقييمه بشكل أكثر كفاءة ، ويتم ذلك عن طريق القيام بأكبر قدر ممكن من العمل قبل مرحلة التقييم. على سبيل المثال ، في اللغات المصممة جيدًا ، من الواضح ، لكل استخدام للربط ، الذي يشار إليه الربط ، دون تشغيل البرنامج فعليًا. يمكن استخدام هذا لتجنب البحث عن الارتباط بالاسم في كل مرة يتم الوصول إليه ، بدلاً من جلبه مباشرةً من موقع ذاكرة محدد مسبقًا.

تقليديا ، يتضمن التجميع تحويل البرنامج إلى رمز آلة ، وهو التنسيق الأولي الذي يمكن لمعالج الكمبيوتر تنفيذه. ولكن يمكن اعتبار أي عملية تحول برنامجًا إلى تمثيل مختلف بمثابة تجميع.

سيكون من الممكن كتابة إستراتيجية تقييم بديلة لـ Egg ، استراتيجية تقوم أولاً بتحويل البرنامج إلى برنامج JavaScript ، وتستخدم الوظيفة لاستدعاء مترجم JavaScript عليها ، ثم تقوم بتشغيل النتيجة. عند القيام بذلك بشكل صحيح ، فإن هذا سيجعل Egg يعمل بسرعة كبيرة بينما يظل سهل التنفيذ.

إذا كنت مهتمًا بهذا الموضوع وتريد قضاء بعض الوقت فيه ، أقترح عليك تطبيق هذا المجمع كتمرين.

### Cheating

عندما حددنا if  أمwhile  ، فمن المحتمل أنك لاحظت أنها كانت أغلفة تافهة إلى حد ما حول جافا سكريبت الخاصةif  وwhile . وبالمثل ، فإن القيم في Egg هي مجرد قيم JavaScript قديمة عادية.

إذا قارنت تطبيق Egg ، الذي يعتمد على JavaScript ، مع مقدار العمل والتعقيد المطلوبين لبناء لغة برمجة تعتمد بشكل مباشر على القدرات الأولية للجهاز ، فإن الاختلاف مهم للغاية. بغض النظر ، آمل أن يكون هذا المثال قد أعطاك فهمًا لكيفية عمل لغات البرمجة.

وعندما يلزم القيام بشيء ما ، يكون الغش أكثر فعالية من فعل كل شيء بنفسك. بالطبع ، لا تؤدي اللغة التي تم إنشاؤها للتدريس في هذا الفصل المهمة بشكل أفضل من نظيرتها في JavaScript ، ولكن هناك مواقف يمكن فيها استخدام كتابة لغات صغيرة للقيام بأشياء حقيقية.

مثل هذه اللغة لا يجب أن تشبه لغة برمجة نموذجية. إذا لم تكن JavaScript مزودة بتعبيرات عادية ، على سبيل المثال ، يمكنك كتابة المحلل اللغوي والمقيم الخاصين بالتعبيرات العادية.

أو تخيل أنك تبني ديناصورًا آليًا عملاقًا وتحتاج إلى برمجة سلوكه. قد لا تكون JavaScript هي الطريقة الأكثر فعالية للقيام بذلك. يمكنك بدلاً من ذلك اختيار لغة تبدو كالتالي:



```text
behavior walk
  perform when
    destination ahead
  actions
    move left-foot
    move right-foot

behavior attack
  perform when
    Godzilla in-view
  actions
    fire laser-eyes
    launch arm-rockets
```

هذا ما يسمى عادة لغة خاصة بالمجال ، لغة مصممة للتعبير عن مجال ضيق من المعرفة. يمكن أن تكون هذه اللغة أكثر تعبيرًا من لغة عامة الغرض لأنها مصممة لوصف الأشياء التي تحتاج إلى وصف في مجالها بالضبط ، ولا شيء آخر.

### Exercises



